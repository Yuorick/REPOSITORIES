//---------------------------------------------------------------------------


#pragma hdrstop

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "TruncatedConeCircle.h"


  TTruncatedConeCircle ::TTruncatedConeCircle()
{

	mR = 0. ;
	mr = 0. ;
	mH = 0.;
	mM = 0.;


}
TTruncatedConeCircle ::TTruncatedConeCircle( const double R, const double r,const double H,const double M)
{
 mR = R;
 mr = r;
 mH = H;
 mM = M;

}

// конструктор копирования
 TTruncatedConeCircle ::TTruncatedConeCircle (const TTruncatedConeCircle &R)
 {
	mR  = R.mR;
	mr = R.mr ;
	mH = R.mH;
	mM = R.mM   ;
 }
 // оператор присваивания
 TTruncatedConeCircle TTruncatedConeCircle::operator=(TTruncatedConeCircle  R)
 {
	mR  = R.mR;
	mr = R.mr ;
	mH = R.mH;
	mM = R.mM   ;
	return *this ;
  }


// вычисление объема
double TTruncatedConeCircle::calcCapacity()
{
 return  M_PI * mH * (mR * mR + mR * mr + mr * mr)/3.;
}

// вычисление координат центра тяжести
void TTruncatedConeCircle::calcCentreOfGravity(double *arrCentreGrav)
{
  arrCentreGrav [0] = 0.;
  arrCentreGrav [1] = mH * (mR * mR + 2. * mR * mr + 3. * mr * mr)/ (mR * mR + mR * mr + mr * mr) / 4.;
  arrCentreGrav [2] = 0.;
}

// вычисление тензора моментов инерции
// это диагональная матрица
// относительно оси вращения считается по формуле
// относительно осей X и Z прмиенятся формула Штейнера
//  усеченный конус достраивается до неусеченного, большого.
// То есть добавляется маленький конус сверху.
// Вычисляются координаты центра тяжести усеченного, большого и малого конусов.
// вычисляютмся моменты инерции большого и малого конусов.
// По теореме Штейнера находится момент инерции относительно осей  X и Z
void TTruncatedConeCircle::calcInertiaTensor(double *arrInertTens)
{
  // 1. высисление момента инерции относительно оси Y
  memset(arrInertTens, 0, 9 * sizeof(double));
  arrInertTens[4] = 3. * mM * (mR*mR*mR*mR*mR - mr*mr*mr*mr*mr)/ (mR*mR*mR - mr*mr*mr) / 10.;
  ////


  double arrCentreGravLittle [3] = {0.}  ,arrCentreGravBig [3] = {0.};
  // 2. вычисление высот малого и большого конусов
   double valHLittle = mH * mr / (mR - mr);
	double valHBig =  valHLittle + mH;
	///


   //  3. вычисление  координат центра масс малого конуса
   calcCentreOfGravity_For_ConeCircle(valHLittle, arrCentreGravLittle) ;
   arrCentreGravLittle [1] += mH;
   ///

   // 4. вычисление  координат центра масс большого конуса
   calcCentreOfGravity_For_ConeCircle(valHBig, arrCentreGravBig) ;
   ///


   //       5.   вычисление массы малого конуса
  double valMLittle = mM / calcCapacity() * calcCapacity_For_ConeCircle(mr, valHLittle);
   ///


   //    6. вычисление массы , большого  конуса
  double valMBig = mM + valMLittle;
  ///



   // 7. вычисление  координат центра масс усеченного  конуса
   double arrCentreGrav[3] = {0.};
   calcCentreOfGravity(arrCentreGrav)  ;
   ///
   double valDelRLittle =  arrCentreGravLittle[1] - arrCentreGravBig[1];
   double valDelR =  arrCentreGrav[1] - arrCentreGravBig[1];

   arrInertTens[0] = calcJxx_For_ConeCircle(mR, valHBig,valMBig) - calcJxx_For_ConeCircle(mr, valHLittle,valMLittele)
				  -valMLittele * valDelRLittle * valDelRLittle - mM * valDelR * valDelR;

   arrInertTens[8] = arrInertTens[0];



}

double TTruncatedConeCircle::calcJyy_For_ConeCircle(const double VAlR, const double VAlM)
{
return 3. * VAlM * VAlR * VAlR /10.;

}
double TTruncatedConeCircle::calcJxx_For_ConeCircle(const double VAlR, const double VAlH, const double VAlM)
{
return 3. * VAlM * (VAlR * VAlR   +  VAlH * VAlH / 4.)/20.;

}

double TTruncatedConeCircle::calcCapacity_For_ConeCircle(const double VAlR, const double VAlH)
{
  return  M_PI * VAlR *VAlR * VAlH / 3.;
}

void TTruncatedConeCircle::calcCentreOfGravity_For_ConeCircle(const double VAlH, double *arrCentreGrav)
{
  arrCentreGrav [0] = 0.;
  arrCentreGrav [1] = VAlH ;
  arrCentreGrav [2] = 0.;
}
// вычисление тензора моментов инерции
void TTruncatedConeCircle::calcInertiaTensor_For_ConeCircle(const double VAlR, const double VAlH, const double VAlM
,double *arrInertTens)
{
   memset(arrInertTens, 0, 9 * sizeof(double));
   arrInertTens [0] = calcJxx_For_ConeCircle(VAlR,VAlH, VAlM);
   arrInertTens [2] = arrInertTens [0] ;
   arrInertTens [1] = calcJyy_For_ConeCircle(const double VAlR, const double VAlM);

}
#pragma package(smart_init)
