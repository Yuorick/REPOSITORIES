// ---------------------------------------------------------------------------

#pragma hdrstop

#include "NeighbourhoodAppPoint.h"
#include <string.h>
#include <math.h>
#include "MatrixProccess.h"
#include "Detonator.h"
#include "Gauss.h"
#include "CalcCorMatrx.h"
#include "YrRastr.h"
#include "Gauss.h"
#include "URPolygon.h"
#include "URPointXY.h"
#include "ProbabilityTheory.h"
#include "GameTheory.h"
#include "Fight.h"
#include "CoastTargNeibourhood.h"
#include "Table_2D.h"
#include "Table_1D.h"
#include "Table_3D.h"

extern const double NODATA;

#define NumMaxQuantPlanePolygons 50 // максимально возможное число плоских полигонов, которое можно вообразить
//////////////////////////////////////////////////////////////
///////    ЗАКОНЫ ПОРАЖЕНИЯ ДЛЯ МФИВУ В ТАБЛИЧНОЙ ФОРМЕ  ///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
/*
// 1. GARPUN V=300
// промах
double parrUZP_Ca130_MFIVU_GARPUN_300_ArgTab1[] = {
	0., 4., 5., 6., 7., 8., 9., 10.
};
int NumUZP_Ca130_MFIVU_GARPUN_300_ColsTab1 = 8;

// дальность
double parrUZP_Ca130_MFIVU_GARPUN_300_ArgTab2[] = {
	800., 6000.
};
int NumUZP_Ca130_MFIVU_GARPUN_300_ColsTab2 = 2;

// высота
double parrUZP_Ca130_MFIVU_GARPUN_300_ArgTab3[] = {
	4., 20., 50., 100., 300., 1001.
};
int NumUZP_Ca130_MFIVU_GARPUN_300_ColsTab3 = 6;

double parrUZP_Ca130_MFIVU_GARPUN_300_Val[] = {
	1., 1., 1., 0.166, 0., 0., 0., 0., 1., 1., 1., 1., 0.997, 0.981, 0.929, 0.

		, 1., 1., 1., 0.166, 0., 0., 0., 0., 1., 1., 1., 1., 0.997, 0.981,
	0.929, 0., 1., 1., 1., 0.252, 0., 0., 0., 0., 1., 1., 1., 1., 0.997, 0.981,
	0.929, 0., 1., 1., 1., 0.317, 0., 0., 0., 0., 1., 1., 1., 1., 0.997, 0.981,
	0.929, 0., 1., 1., 0.804, 0.462, 0., 0., 0., 0., 1., 1., 1., 1., 0.997,
	0.981, 0.929, 0., 1., 1., 0.5, 0.25, 0., 0., 0., 0., 1., 1., 1., 1., 0.997,
	0.981, 0.929, 0.
};

const TTable_3D TableUZP_Ca130_MFIVU_GARPUN_300
	(parrUZP_Ca130_MFIVU_GARPUN_300_ArgTab1,
	NumUZP_Ca130_MFIVU_GARPUN_300_ColsTab1, parrUZP_Ca130_MFIVU_GARPUN_300_ArgTab2,
	NumUZP_Ca130_MFIVU_GARPUN_300_ColsTab2, parrUZP_Ca130_MFIVU_GARPUN_300_ArgTab3,
	NumUZP_Ca130_MFIVU_GARPUN_300_ColsTab3, parrUZP_Ca130_MFIVU_GARPUN_300_Val);

///

// 2. GARPUN V=700
// промах
double parrUZP_Ca130_MFIVU_GARPUN_700_ArgTab1[] = {
	0., 3., 4., 5., 6.
};
int NumUZP_Ca130_MFIVU_GARPUN_700_ColsTab1 = 5;

// дальность
double parrUZP_Ca130_MFIVU_GARPUN_700_ArgTab2[] = {
	800., 6000.
};
int NumUZP_Ca130_MFIVU_GARPUN_700_ColsTab2 = 2;

// высота
double parrUZP_Ca130_MFIVU_GARPUN_700_ArgTab3[] = {
	9., 50., 100., 300., 1001.
};
int NumUZP_Ca130_MFIVU_GARPUN_700_ColsTab3 = 5;

double parrUZP_Ca130_MFIVU_GARPUN_700_Val[] = {
	1., 1., 0.965, 0., 0., 1., 1., 1., 0.882, 0. // высота 9
	, 1., 1., 0.962, 0., 0., 1., 1., 1., 0.884, 0. // высота 50
	, 1., 1., 0.939, 0., 0., 1., 1., 1., 0.889, 0. // высота 100
	, 1., 1., 0.734, 0., 0., 1., 1., 1., 0.91, 0. // высота 300
	, 1., 1., 0.2, 0., 0., 1., 1., 1., 0.25, 0. // высота 1001
};

const TTable_3D TableUZP_Ca130_MFIVU_GARPUN_700
	(parrUZP_Ca130_MFIVU_GARPUN_700_ArgTab1,
	NumUZP_Ca130_MFIVU_GARPUN_700_ColsTab1, parrUZP_Ca130_MFIVU_GARPUN_700_ArgTab2,
	NumUZP_Ca130_MFIVU_GARPUN_700_ColsTab2, parrUZP_Ca130_MFIVU_GARPUN_700_ArgTab3,
	NumUZP_Ca130_MFIVU_GARPUN_700_ColsTab3, parrUZP_Ca130_MFIVU_GARPUN_700_Val);

///
/*
// 2. F-14
// промах
double parrUZP_Ca130_MFIVU_F14_ArgTab1[] = {0.,9.,10.,10.01
};
int NumUZP_Ca130_MFIVU_F14_ColsTab1 = 4;

// дальность
double parrUZP_Ca130_MFIVU_F14_ArgTab2[] = {5800., 10000.
};
int NumUZP_Ca130_MFIVU_F14_ColsTab2 = 2;

// высота
double parrUZP_Ca130_MFIVU_F14_ArgTab3[] = {250., 500.,1000.,2001.
};
int NumUZP_Ca130_MFIVU_F14_ColsTab3 =  4;


double parrUZP_Ca130_MFIVU_F14_Val[] = { 1.,1.,0.281,0.,   1.,1.,0.517, 0.  // высота 250
,1.,1.,0.282,0.,   1.,1.,0.529, 0.  // высота 500
,1.,1.,0.34, 0.,   1.,1.,0.452, 0.  // высота 1000
,1.,1.,0.517,0.,   1.,1.,0.439, 0.  // высота 2001
};

const TTable_3D TableUZP_Ca130_MFIVU_F14( parrUZP_Ca130_MFIVU_F14_ArgTab1
,  NumUZP_Ca130_MFIVU_F14_ColsTab1, parrUZP_Ca130_MFIVU_F14_ArgTab2,  NumUZP_Ca130_MFIVU_F14_ColsTab2
,parrUZP_Ca130_MFIVU_F14_ArgTab3,  NumUZP_Ca130_MFIVU_F14_ColsTab3, parrUZP_Ca130_MFIVU_F14_Val ) ;
 */
///

//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
// РАДИОВЗРЫВ //
// Новый условный закон поражения, 100 мм, тип А1+B
double X_yzp0[10] = {
	0.0, 0.5, 0.75, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 3.6
};
double Y_yzp0[10] = {
	1.0, 1.0, 0.96, 0.904, 0.704, 0.496, 0.296, 0.144, 0.064, 0.
};
TURPolyLine plnUZP_Calibro100_AR32_Garpun300(X_yzp0, Y_yzp0, 10);
/*
//Новый условный закон поражения, 100 мм, тип А1
double X_yzp[6]={0.0,0.5,1.0,1.5,2.0,2.5};
double Y_yzp[6]={1.0,1.0,0.85,0.45,0.1,0.0};
 */
/*
//Новый условный закон поражения, 100 мм, тип В
double X_yzp[8]={0.0,0.5,1.0,1.5,2.0,2.5,3.0,3.5};
double Y_yzp[8]={1.0,0.6,0.3,0.45,0.43,0.3,0.15,0.06};
 */

// Новый условный закон поражения, 130 мм, Гарпун 300, АР-32
double X_yzp1[7] = {
	0.0, 1.0, 1.5, 2.0, 2.5, 3.0, 3.05
};
double Y_yzp1[7] = {
	1.0, 1.0, 0.65, 0.264, 0.155, 0.013, 0.
};
TURPolyLine plnUZP_Calibro130_AR32_Garpun300(X_yzp1, Y_yzp1, 7);

// Новый условный закон поражения, 130 мм , Vц = 700 m/sб , АР-32
double X_yzp_Garpun700_TypeB[8] = {
	0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.1
};
double Y_yzp_Garpun700_TypeB[8] = {
	1.0, 0.41, 0.26, 0.4, 0.45, 0.18, 0.1, 0.
};
TURPolyLine plnUZP_Calibro130_AR32_Garpun700(X_yzp_Garpun700_TypeB,
	Y_yzp_Garpun700_TypeB, 8);

//////////////////////////////////////////////////////////////
///////    ЗАКОНЫ ПОРАЖЕНИЯ ДЛЯ 76 ШТАТНОГО  В ТАБЛИЧНОЙ ФОРМЕ  ///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////

// 1.1.1 76 ШТАТНЫЙ GARPUN V=300 D=2 km
// недолет
double parrUZP_Ca76_Shtat_GARPUN_300_D_2_ArgTab1[] = {
	-16.020000, -15.520000, -15.020000, -14.520000, -14.020000, -13.520000,
	-13.020000, -12.520000, -12.020000, -11.520000, -11.020000, -10.520000,
	-10.020000, -9.520000, -9.020000, -8.520000, -8.020000, -7.520000, -7.020000,
	-6.520000, -6.020000, -5.520000, -5.020000, -4.520000, -4.020000, -3.520000,
	-3.020000, -2.520000, -2.020000, -1.520000, -1.020000, -0.520000, -0.020000,
	0.480000, 0.980000, 1.480000, 1.980000, 2.480000, 2.980000, 3.480000
};
int NumUZP_Ca76_Shtat_GARPUN_300_D_2 = 40;

// промах
double parrUZP_Ca76_Shtat_GARPUN_300_D_2_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Shtat_GARPUN_300_D_2_ColsTab2 = 6;

double parrUZP_Ca76_Shtat_GARPUN_300_D_2_Val[] = {

	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.880000, 0.980000,
	0.980000, 0.720000, 0.430000, 0.590000, 0.800000, 0.730000, 0.670000,
	0.200000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.420000, 0.620000, 0.620000,
	0.630000, 0.670000, 0.700000, 0.490000, 0.400000, 0.400000, 0.360000,
	0.260000, 0.250000, 0.030000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.210000, 0.350000, 0.350000, 0.350000,
	0.390000, 0.410000, 0.460000, 0.480000, 0.410000, 0.240000, 0.200000,
	0.200000, 0.180000, 0.120000, 0.070000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.120000, 0.200000, 0.200000, 0.210000, 0.230000, 0.240000,
	0.280000, 0.290000, 0.290000, 0.290000, 0.290000, 0.220000, 0.110000,
	0.110000, 0.110000, 0.090000, 0.060000, 0.050000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.080000, 0.150000, 0.150000, 0.150000, 0.160000, 0.180000, 0.200000,
	0.210000, 0.210000, 0.210000, 0.210000, 0.210000, 0.210000, 0.210000,
	0.150000, 0.080000, 0.080000, 0.060000, 0.040000, 0.010000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Shtat_GARPUN_300_D_2(
	parrUZP_Ca76_Shtat_GARPUN_300_D_2_ArgTab1,
	NumUZP_Ca76_Shtat_GARPUN_300_D_2, parrUZP_Ca76_Shtat_GARPUN_300_D_2_ArgTab2,
	NumUZP_Ca76_Shtat_GARPUN_300_D_2_ColsTab2,
	parrUZP_Ca76_Shtat_GARPUN_300_D_2_Val);

// 1.1.2. 76 ШТАТНЫЙ GARPUN V=300 D=4 km
// недолет
double parrUZP_Ca76_Shtat_GARPUN_300_D_4_ArgTab1[] = {
	-14.280000, -13.780000, -13.280000, -12.780000, -12.280000, -11.780000,
	-11.280000, -10.780000, -10.280000, -9.780000, -9.280000, -8.780000, -8.280000,
	-7.780000, -7.280000, -6.780000, -6.280000, -5.780000, -5.280000,
	-4.780000, -4.280000, -3.780000, -3.280000, -2.780000, -2.280000, -1.780000, -1.280000,
	-0.780000, -0.280000, 0.220000, 0.720000, 1.220000, 1.720000, 2.220000,
	2.720000, 3.220000, 3.720000, 4.220000
};
int NumUZP_Ca76_Shtat_GARPUN_300_D_4 = 38;

// промах
double parrUZP_Ca76_Shtat_GARPUN_300_D_4_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Shtat_GARPUN_300_D_4_ColsTab2 = 6;

double parrUZP_Ca76_Shtat_GARPUN_300_D_4_Val[] = {

	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.920000, 0.990000, 0.990000, 0.780000,
	0.500000, 0.660000, 0.850000, 0.820000, 0.740000, 0.270000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.330000, 0.520000, 0.520000, 0.530000, 0.570000, 0.600000, 0.340000,
	0.330000, 0.330000, 0.300000, 0.230000, 0.200000, 0.050000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.240000, 0.390000, 0.390000,
	0.390000, 0.430000, 0.460000, 0.460000, 0.520000, 0.530000, 0.530000,
	0.330000, 0.230000, 0.230000, 0.210000, 0.160000, 0.140000, 0.020000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.140000, 0.240000, 0.240000, 0.250000, 0.270000,
	0.290000, 0.290000, 0.330000, 0.350000, 0.350000, 0.200000, 0.140000,
	0.140000, 0.120000, 0.090000, 0.080000, 0.010000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.090000,
	0.160000, 0.160000, 0.160000, 0.180000, 0.190000, 0.220000, 0.230000,
	0.230000, 0.230000, 0.230000, 0.230000, 0.230000, 0.230000, 0.230000,
	0.100000, 0.090000, 0.090000, 0.070000, 0.050000, 0.040000, 0.010000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Shtat_GARPUN_300_D_4(
	parrUZP_Ca76_Shtat_GARPUN_300_D_4_ArgTab1,
	NumUZP_Ca76_Shtat_GARPUN_300_D_4, parrUZP_Ca76_Shtat_GARPUN_300_D_4_ArgTab2,
	NumUZP_Ca76_Shtat_GARPUN_300_D_4_ColsTab2,
	parrUZP_Ca76_Shtat_GARPUN_300_D_4_Val);

// 1.1.3. 76 ШТАТНЫЙ GARPUN V=300 D=6 km
// недолет
double parrUZP_Ca76_Shtat_GARPUN_300_D_6_ArgTab1[] = {
	-11.790000, -11.290000, -10.790000, -10.290000, -9.790000, -9.290000,
	-8.790000, -8.290000, -7.790000, -7.290000, -6.790000, -6.290000, -5.790000,
	-5.290000, -4.790000, -4.290000, -3.790000, -3.290000, -2.790000, -2.290000,
	-1.790000, -1.290000, -0.790000, -0.290000, 0.210000, 0.710000, 1.210000,
	1.710000, 2.210000, 2.710000, 3.210000, 3.710000, 4.210000, 4.710000,
	5.210000, 5.710000,
};
int NumUZP_Ca76_Shtat_GARPUN_300_D_6 = 36;

// промах
double parrUZP_Ca76_Shtat_GARPUN_300_D_6_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Shtat_GARPUN_300_D_6_ColsTab2 = 6;

double parrUZP_Ca76_Shtat_GARPUN_300_D_6_Val[] = {

	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.920000,
	0.990000, 0.990000, 0.840000, 0.550000, 0.670000, 0.860000, 0.820000,
	0.760000, 0.250000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.470000, 0.690000, 0.690000, 0.700000, 0.740000,
	0.770000, 0.560000, 0.470000, 0.470000, 0.420000, 0.330000, 0.280000,
	0.040000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.250000, 0.410000,
	0.410000, 0.410000, 0.460000, 0.480000, 0.540000, 0.560000, 0.410000,
	0.280000, 0.250000, 0.250000, 0.200000, 0.150000, 0.090000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.200000, 0.340000, 0.340000, 0.340000, 0.380000,
	0.400000, 0.450000, 0.470000, 0.470000, 0.470000, 0.470000, 0.390000,
	0.230000, 0.200000, 0.200000, 0.160000, 0.120000, 0.070000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.090000, 0.160000,
	0.160000, 0.160000, 0.180000, 0.190000, 0.220000, 0.230000, 0.230000,
	0.230000, 0.230000, 0.230000, 0.230000, 0.230000, 0.160000, 0.090000,
	0.090000, 0.090000, 0.070000, 0.050000, 0.010000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Shtat_GARPUN_300_D_6(
	parrUZP_Ca76_Shtat_GARPUN_300_D_6_ArgTab1,
	NumUZP_Ca76_Shtat_GARPUN_300_D_6, parrUZP_Ca76_Shtat_GARPUN_300_D_6_ArgTab2,
	NumUZP_Ca76_Shtat_GARPUN_300_D_6_ColsTab2,
	parrUZP_Ca76_Shtat_GARPUN_300_D_6_Val);

///
// 1.1.4  РЕЗУЛЬТЬИРУЮЩИЙ
// дальности
double parrKZP_Ca76_Shtat_GARPUN_300_ArgTab3[] = {
	2000., 4000., 6000.
};

TTable_3D Table_3D_KZP_Ca76_Shtat_GARPUN_300(
	parrKZP_Ca76_Shtat_GARPUN_300_ArgTab3,
	Table_2D_KZP_Ca76_Shtat_GARPUN_300_D_2,
	Table_2D_KZP_Ca76_Shtat_GARPUN_300_D_4,
	Table_2D_KZP_Ca76_Shtat_GARPUN_300_D_6);

////
////
/////////////////////////////////////////////////////
////////   76 ШТАТНЫЙ && GARPUN_700 /////////////////////////////////////////////
/////////////////////////////////////////////////////

// 1.2.1 76 ШТАТНЫЙ GARPUN V=700 D=2 km
// недолет
double parrUZP_Ca76_Shtat_GARPUN_700_D_2_ArgTab1[] = {
	-20.870000, -20.370000, -19.870000, -19.370000, -18.870000, -18.370000,
	-17.870000, -17.370000, -16.870000, -16.370000, -15.870000, -15.370000,
	-14.870000, -14.370000, -13.870000, -13.370000, -12.870000, -12.370000,
	-11.870000, -11.370000, -10.870000, -10.370000, -9.870000, -9.370000,
	-8.870000, -8.370000, -7.870000, -7.370000, -6.870000, -6.370000, -5.870000, -5.370000,
	-4.870000, -4.370000, -3.870000, -3.370000, -2.870000, -2.370000, -1.870000,
	-1.370000, -0.870000, -0.370000, 0.130000, 0.630000, 1.130000, 1.630000,
	2.130000, 2.630000, 3.130000
};
int NumUZP_Ca76_Shtat_GARPUN_700_D_2 = 49;

// промах
double parrUZP_Ca76_Shtat_GARPUN_700_D_2_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Shtat_GARPUN_700_D_2_ColsTab2 = 6;

double parrUZP_Ca76_Shtat_GARPUN_700_D_2_Val[] = {
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.920000,
	0.990000, 0.990000, 0.860000, 0.540000, 0.650000, 0.860000, 0.800000,
	0.730000, 0.260000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.470000, 0.680000,
	0.680000, 0.690000, 0.740000, 0.750000, 0.630000, 0.440000, 0.440000,
	0.430000, 0.320000, 0.280000, 0.070000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.250000, 0.400000, 0.400000,
	0.410000, 0.450000, 0.470000, 0.520000, 0.540000, 0.540000, 0.340000,
	0.230000, 0.230000, 0.210000, 0.170000, 0.140000, 0.030000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.130000, 0.230000, 0.230000, 0.230000, 0.260000,
	0.270000, 0.310000, 0.320000, 0.320000, 0.320000, 0.320000, 0.320000,
	0.190000, 0.120000, 0.120000, 0.120000, 0.080000, 0.070000, 0.020000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.090000, 0.160000, 0.160000, 0.160000, 0.190000, 0.190000,
	0.220000, 0.230000, 0.230000, 0.230000, 0.230000, 0.230000, 0.230000,
	0.230000, 0.230000, 0.130000, 0.090000, 0.090000, 0.080000, 0.060000,
	0.050000, 0.020000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Shtat_GARPUN_700_D_2(
	parrUZP_Ca76_Shtat_GARPUN_700_D_2_ArgTab1,
	NumUZP_Ca76_Shtat_GARPUN_700_D_2, parrUZP_Ca76_Shtat_GARPUN_700_D_2_ArgTab2,
	NumUZP_Ca76_Shtat_GARPUN_700_D_2_ColsTab2,
	parrUZP_Ca76_Shtat_GARPUN_700_D_2_Val);

// 1.2.2. 76 ШТАТНЫЙ GARPUN V=700 D=4 km
// недолет
double parrUZP_Ca76_Shtat_GARPUN_700_D_4_ArgTab1[] = {
	-18.830000, -18.330000, -17.830000, -17.330000, -16.830000, -16.330000,
	-15.830000, -15.330000, -14.830000, -14.330000, -13.830000, -13.330000,
	-12.830000, -12.330000, -11.830000, -11.330000, -10.830000, -10.330000,
	-9.830000, -9.330000, -8.830000, -8.330000, -7.830000, -7.330000, -6.830000,
	-6.330000, -5.830000, -5.330000, -4.830000, -4.330000, -3.830000, -3.330000,
	-2.830000, -2.330000, -1.830000, -1.330000, -0.830000, -0.330000, 0.170000,
	0.670000, 1.170000, 1.670000, 2.170000, 2.670000, 3.170000
};
int NumUZP_Ca76_Shtat_GARPUN_700_D_4 = 45;

// промах
double parrUZP_Ca76_Shtat_GARPUN_700_D_4_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Shtat_GARPUN_700_D_4_ColsTab2 = 6;

double parrUZP_Ca76_Shtat_GARPUN_700_D_4_Val[] = {

	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.920000,
	0.990000, 0.990000, 0.860000, 0.540000, 0.650000, 0.860000, 0.800000,
	0.730000, 0.260000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.470000, 0.680000,
	0.680000, 0.690000, 0.740000, 0.750000, 0.630000, 0.440000, 0.440000,
	0.430000, 0.320000, 0.280000, 0.070000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.250000, 0.400000, 0.400000,
	0.410000, 0.450000, 0.470000, 0.520000, 0.540000, 0.540000, 0.340000,
	0.230000, 0.230000, 0.210000, 0.170000, 0.140000, 0.030000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.130000, 0.230000, 0.230000, 0.230000, 0.260000,
	0.270000, 0.310000, 0.320000, 0.320000, 0.320000, 0.320000, 0.320000,
	0.190000, 0.120000, 0.120000, 0.120000, 0.080000, 0.070000, 0.020000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.090000, 0.160000, 0.160000, 0.160000, 0.190000, 0.190000,
	0.220000, 0.230000, 0.230000, 0.230000, 0.230000, 0.230000, 0.230000,
	0.230000, 0.230000, 0.130000, 0.090000, 0.090000, 0.080000, 0.060000,
	0.050000, 0.020000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Shtat_GARPUN_700_D_4(
	parrUZP_Ca76_Shtat_GARPUN_700_D_4_ArgTab1,
	NumUZP_Ca76_Shtat_GARPUN_700_D_4, parrUZP_Ca76_Shtat_GARPUN_700_D_4_ArgTab2,
	NumUZP_Ca76_Shtat_GARPUN_700_D_4_ColsTab2,
	parrUZP_Ca76_Shtat_GARPUN_700_D_4_Val);

// 1.2.3. 76 ШТАТНЫЙ GARPUN V=700 D=6 km
// недолет
double parrUZP_Ca76_Shtat_GARPUN_700_D_6_ArgTab1[] = {
	-16.440000, -15.940000, -15.440000, -14.940000, -14.440000, -13.940000,
	-13.440000, -12.940000, -12.440000, -11.940000, -11.440000, -10.940000,
	-10.440000, -9.940000, -9.440000, -8.940000, -8.440000, -7.940000, -7.440000,
	-6.940000, -6.440000, -5.940000, -5.440000, -4.940000, -4.440000, -3.940000,
	-3.440000, -2.940000, -2.440000, -1.940000, -1.440000, -0.940000, -0.440000,
	0.060000, 0.560000, 1.060000, 1.560000, 2.060000, 2.560000, 3.060000,
	3.560000, 4.060000
};
int NumUZP_Ca76_Shtat_GARPUN_700_D_6 = 42;

// промах
double parrUZP_Ca76_Shtat_GARPUN_700_D_6_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Shtat_GARPUN_700_D_6_ColsTab2 = 6;

double parrUZP_Ca76_Shtat_GARPUN_700_D_6_Val[] = {

	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.930000,
	0.990000, 0.990000, 1.000000, 0.510000, 0.670000, 0.860000, 0.820000,
	0.750000, 0.280000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.480000, 0.700000, 0.700000, 0.700000, 0.750000, 0.770000, 0.600000,
	0.460000, 0.460000, 0.430000, 0.330000, 0.290000, 0.060000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.250000, 0.400000, 0.400000, 0.410000, 0.450000, 0.470000, 0.530000,
	0.550000, 0.550000, 0.340000, 0.240000, 0.240000, 0.220000, 0.160000,
	0.140000, 0.020000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.150000, 0.260000, 0.260000, 0.260000, 0.290000, 0.300000,
	0.350000, 0.360000, 0.360000, 0.360000, 0.360000, 0.300000, 0.180000,
	0.140000, 0.140000, 0.120000, 0.090000, 0.070000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.100000, 0.170000, 0.170000, 0.170000, 0.190000, 0.200000,
	0.230000, 0.240000, 0.240000, 0.240000, 0.240000, 0.240000, 0.240000,
	0.240000, 0.200000, 0.110000, 0.090000, 0.090000, 0.070000, 0.050000,
	0.040000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Shtat_GARPUN_700_D_6(
	parrUZP_Ca76_Shtat_GARPUN_700_D_6_ArgTab1,
	NumUZP_Ca76_Shtat_GARPUN_700_D_6, parrUZP_Ca76_Shtat_GARPUN_700_D_6_ArgTab2,
	NumUZP_Ca76_Shtat_GARPUN_700_D_6_ColsTab2,
	parrUZP_Ca76_Shtat_GARPUN_700_D_6_Val);

///

// ДАЛЬНОСТИ
double parrKZP_Ca76_Shtat_GARPUN_700_ArgTab3[] = {
	2000., 4000., 6000.
};

TTable_3D Table_3D_KZP_Ca76_Shtat_GARPUN_700(
	parrKZP_Ca76_Shtat_GARPUN_700_ArgTab3,
	Table_2D_KZP_Ca76_Shtat_GARPUN_700_D_2,
	Table_2D_KZP_Ca76_Shtat_GARPUN_700_D_4,
	Table_2D_KZP_Ca76_Shtat_GARPUN_700_D_6);

/////////////////////////////////////////////////////
////////   76 ШТАТНЫЙ && GARPUN_1000 /////////////////////////////////////////////
/////////////////////////////////////////////////////
/// 1.3.1 ДАЛЬНОСТЬ 2
// недолет
double parrUZP_Ca76_Shtat_GARPUN_1000_D_2_ArgTab1[] = {
	-24.390000, -23.890000, -23.390000, -22.890000, -22.390000, -21.890000,
	-21.390000, -20.890000, -20.390000, -19.890000, -19.390000, -18.890000,
	-18.390000, -17.890000, -17.390000, -16.890000, -16.390000, -15.890000,
	-15.390000, -14.890000, -14.390000, -13.890000, -13.390000, -12.890000,
	-12.390000, -11.890000, -11.390000, -10.890000, -10.390000, -9.890000,
	-9.390000, -8.890000, -8.390000, -7.890000, -7.390000, -6.890000, -6.390000,
	-5.890000, -5.390000, -4.890000, -4.390000, -3.890000, -3.390000, -2.890000,
	-2.390000, -1.890000, -1.390000, -0.890000, -0.390000, 0.110000, 0.610000,
	1.110000, 1.610000, 2.110000
};
int NumUZP_Ca76_Shtat_GARPUN_1000_D_2 = 54;

// промах
double parrUZP_Ca76_Shtat_GARPUN_1000_D_2_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Shtat_GARPUN_1000_D_2_ColsTab2 = 6;

double parrUZP_Ca76_Shtat_GARPUN_1000_D_2_Val[] = {
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.930000, 0.990000,
	0.990000, 0.870000, 0.490000, 0.640000, 0.860000, 0.820000, 0.730000,
	0.260000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.480000, 0.680000, 0.680000, 0.690000, 0.730000, 0.750000, 0.630000,
	0.440000, 0.440000, 0.430000, 0.340000, 0.280000, 0.070000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.250000, 0.400000, 0.400000, 0.400000, 0.440000,
	0.460000, 0.520000, 0.540000, 0.540000, 0.380000, 0.230000, 0.230000,
	0.220000, 0.170000, 0.130000, 0.030000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.150000, 0.250000,
	0.250000, 0.250000, 0.280000, 0.290000, 0.340000, 0.350000, 0.350000,
	0.350000, 0.350000, 0.350000, 0.230000, 0.130000, 0.130000, 0.130000,
	0.100000, 0.080000, 0.020000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.090000, 0.160000, 0.160000, 0.160000, 0.180000, 0.190000, 0.220000,
	0.230000, 0.230000, 0.230000, 0.230000, 0.230000, 0.230000, 0.230000,
	0.230000, 0.180000, 0.100000, 0.080000, 0.080000, 0.060000, 0.050000,
	0.040000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Shtat_GARPUN_1000_D_2(
	parrUZP_Ca76_Shtat_GARPUN_1000_D_2_ArgTab1,
	NumUZP_Ca76_Shtat_GARPUN_1000_D_2,
	parrUZP_Ca76_Shtat_GARPUN_1000_D_2_ArgTab2,
	NumUZP_Ca76_Shtat_GARPUN_1000_D_2_ColsTab2,
	parrUZP_Ca76_Shtat_GARPUN_1000_D_2_Val);

// 1.3.2. 76 ШТАТНЫЙ GARPUN V=1000 D=4 km
// недолет
double parrUZP_Ca76_Shtat_GARPUN_1000_D_4_ArgTab1[] = {
	-18.830000, -18.330000, -17.830000, -17.330000, -16.830000, -16.330000,
	-15.830000, -15.330000, -14.830000, -14.330000, -13.830000, -13.330000,
	-12.830000, -12.330000, -11.830000, -11.330000, -10.830000, -10.330000,
	-9.830000, -9.330000, -8.830000, -8.330000, -7.830000, -7.330000, -6.830000,
	-6.330000, -5.830000, -5.330000, -4.830000, -4.330000, -3.830000, -3.330000,
	-2.830000, -2.330000, -1.830000, -1.330000, -0.830000, -0.330000, 0.170000,
	0.670000, 1.170000, 1.670000, 2.170000, 2.670000, 3.170000
};
int NumUZP_Ca76_Shtat_GARPUN_1000_D_4 = 51;

// промах
double parrUZP_Ca76_Shtat_GARPUN_1000_D_4_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Shtat_GARPUN_1000_D_4_ColsTab2 = 6;

double parrUZP_Ca76_Shtat_GARPUN_1000_D_4_Val[] = {

	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.900000, 0.980000, 0.980000, 0.840000, 0.440000,
	0.600000, 0.820000, 0.780000, 0.680000, 0.230000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.430000, 0.630000, 0.630000, 0.640000, 0.680000,
	0.710000, 0.580000, 0.400000, 0.400000, 0.390000, 0.310000, 0.250000,
	0.060000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.220000, 0.360000, 0.360000, 0.360000, 0.400000,
	0.420000, 0.470000, 0.480000, 0.480000, 0.340000, 0.200000, 0.200000,
	0.200000, 0.150000, 0.120000, 0.030000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.130000, 0.210000, 0.210000, 0.220000, 0.240000,
	0.260000, 0.290000, 0.310000, 0.310000, 0.310000, 0.310000, 0.310000,
	0.200000, 0.120000, 0.120000, 0.110000, 0.090000, 0.070000, 0.020000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.080000, 0.140000, 0.140000, 0.140000, 0.160000,
	0.170000, 0.200000, 0.210000, 0.210000, 0.210000, 0.210000, 0.210000,
	0.210000, 0.210000, 0.210000, 0.210000, 0.140000, 0.080000, 0.080000,
	0.070000, 0.060000, 0.040000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Shtat_GARPUN_1000_D_4(
	parrUZP_Ca76_Shtat_GARPUN_1000_D_4_ArgTab1,
	NumUZP_Ca76_Shtat_GARPUN_1000_D_4,
	parrUZP_Ca76_Shtat_GARPUN_1000_D_4_ArgTab2,
	NumUZP_Ca76_Shtat_GARPUN_1000_D_4_ColsTab2,
	parrUZP_Ca76_Shtat_GARPUN_1000_D_4_Val);
// 1.3.3. 76 ШТАТНЫЙ GARPUN V=1000 D=6 km
// недолет
double parrUZP_Ca76_Shtat_GARPUN_1000_D_6_ArgTab1[] = {
	-20.000000, -19.500000, -19.000000, -18.500000, -18.000000, -17.500000,
	-17.000000, -16.500000, -16.000000, -15.500000, -15.000000, -14.500000,
	-14.000000, -13.500000, -13.000000, -12.500000, -12.000000, -11.500000,
	-11.000000, -10.500000, -10.000000, -9.500000, -9.000000, -8.500000, -8.000000,
	-7.500000, -7.000000, -6.500000, -6.000000, -5.500000, -5.000000,
	-4.500000, -4.000000, -3.500000, -3.000000, -2.500000, -2.000000, -1.500000, -1.000000,
	-0.500000, 0.000000, 0.500000, 1.000000, 1.500000
};
int NumUZP_Ca76_Shtat_GARPUN_1000_D_6 = 44;

// промах
double parrUZP_Ca76_Shtat_GARPUN_1000_D_6_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Shtat_GARPUN_1000_D_6_ColsTab2 = 6;

double parrUZP_Ca76_Shtat_GARPUN_1000_D_6_Val[] = {
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.930000, 0.990000,
	0.990000, 0.870000, 0.500000, 0.660000, 0.860000, 0.820000, 0.740000,
	0.270000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.490000,
	0.700000, 0.700000, 0.700000, 0.750000, 0.770000, 0.590000, 0.460000,
	0.460000, 0.420000, 0.330000, 0.290000, 0.060000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.260000, 0.420000, 0.420000, 0.420000, 0.460000, 0.480000, 0.540000,
	0.550000, 0.550000, 0.360000, 0.240000, 0.240000, 0.220000, 0.180000,
	0.140000, 0.030000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.150000, 0.250000, 0.250000, 0.260000, 0.290000, 0.300000,
	0.340000, 0.360000, 0.360000, 0.360000, 0.360000, 0.360000, 0.240000,
	0.140000, 0.140000, 0.120000, 0.090000, 0.080000, 0.010000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.100000, 0.170000, 0.170000, 0.170000, 0.190000,
	0.200000, 0.230000, 0.240000, 0.240000, 0.240000, 0.240000, 0.240000,
	0.240000, 0.240000, 0.240000, 0.130000, 0.090000, 0.090000, 0.080000,
	0.060000, 0.050000, 0.010000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Shtat_GARPUN_1000_D_6(
	parrUZP_Ca76_Shtat_GARPUN_1000_D_6_ArgTab1,
	NumUZP_Ca76_Shtat_GARPUN_1000_D_6,
	parrUZP_Ca76_Shtat_GARPUN_1000_D_6_ArgTab2,
	NumUZP_Ca76_Shtat_GARPUN_1000_D_6_ColsTab2,
	parrUZP_Ca76_Shtat_GARPUN_1000_D_6_Val);

///

// 1.3.4 РЕЗУЛЬТИРУЮЩИЙ
// ДАЛЬНОСТИ
double parrKZP_Ca76_Shtat_GARPUN_1000_ArgTab3[] = {
	2000., 4000., 6000.
};

TTable_3D Table_3D_KZP_Ca76_Shtat_GARPUN_1000(
	parrKZP_Ca76_Shtat_GARPUN_1000_ArgTab3,
	Table_2D_KZP_Ca76_Shtat_GARPUN_1000_D_2,
	Table_2D_KZP_Ca76_Shtat_GARPUN_1000_D_4,
	Table_2D_KZP_Ca76_Shtat_GARPUN_1000_D_6);

//////////////////////////////////////////////////////////////
///////    ЗАКОНЫ ПОРАЖЕНИЯ ДЛЯ 76 ПЕРСПЕКТИВНОГО БАРЬЕР  В ТАБЛИЧНОЙ ФОРМЕ  ///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////

// 2.1.1. 76 ПЕРСПЕКТ GARPUN V=300 D=2 km
// недолет
double parrUZP_Ca76_Prosp_GARPUN_300_D_2_ArgTab1[] = {
	-10.330000, -9.830000, -9.330000, -8.830000, -8.330000, -7.830000,
	-7.330000, -6.830000, -6.330000, -5.830000, -5.330000, -4.830000, -4.330000,
	-3.830000, -3.330000, -2.830000, -2.330000, -1.830000, -1.330000, -0.830000,
	-0.330000, 0.170000, 0.670000, 1.170000, 1.670000, 2.170000, 2.670000, 3.170000
};
int NumUZP_Ca76_Prosp_GARPUN_300_D_2 = 28;

// промах
double parrUZP_Ca76_Prosp_GARPUN_300_D_2_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Prosp_GARPUN_300_D_2_ColsTab2 = 6;

double parrUZP_Ca76_Prosp_GARPUN_300_D_2_Val[] = {

	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.990000, 1.000000, 1.000000, 0.940000,
	0.630000, 0.920000, 0.990000, 0.980000, 0.960000, 0.330000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.720000,
	0.930000, 0.930000, 0.910000, 0.930000, 0.890000, 0.710000, 0.760000,
	0.750000, 0.650000, 0.560000, 0.170000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.450000, 0.680000, 0.680000, 0.690000, 0.740000,
	0.760000, 0.820000, 0.830000, 0.600000, 0.470000, 0.470000, 0.420000,
	0.340000, 0.300000, 0.040000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.290000, 0.480000,
	0.480000, 0.480000, 0.530000, 0.550000, 0.620000, 0.640000, 0.640000,
	0.640000, 0.460000, 0.300000, 0.300000, 0.290000, 0.230000, 0.180000,
	0.070000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.200000, 0.350000, 0.350000, 0.350000, 0.380000, 0.410000,
	0.460000, 0.480000, 0.480000, 0.480000, 0.480000, 0.480000, 0.480000,
	0.360000, 0.210000, 0.210000, 0.200000, 0.160000, 0.120000, 0.050000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Prosp_GARPUN_300_D_2(
	parrUZP_Ca76_Prosp_GARPUN_300_D_2_ArgTab1,
	NumUZP_Ca76_Prosp_GARPUN_300_D_2, parrUZP_Ca76_Prosp_GARPUN_300_D_2_ArgTab2,
	NumUZP_Ca76_Prosp_GARPUN_300_D_2_ColsTab2,
	parrUZP_Ca76_Prosp_GARPUN_300_D_2_Val);

// 2.1.2 76 ПЕРСПЕКТИВНЫЙ GARPUN V=300 D=4 km
// недолет
double parrUZP_Ca76_Prosp_GARPUN_300_D_4_ArgTab1[] = {
	-8.400000, -7.900000, -7.400000, -6.900000, -6.400000, -5.900000,
	-5.400000, -4.900000, -4.400000, -3.900000, -3.400000, -2.900000, -2.400000, -1.900000,
	-1.400000, -0.900000, -0.400000, 0.100000, 0.600000, 1.100000, 1.600000,
	2.100000, 2.600000, 3.100000, 3.600000
};
int NumUZP_Ca76_Prosp_GARPUN_300_D_4 = 25;

// промах
double parrUZP_Ca76_Prosp_GARPUN_300_D_4_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Prosp_GARPUN_300_D_4_ColsTab2 = 6;

double parrUZP_Ca76_Prosp_GARPUN_300_D_4_Val[] = {

	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.990000, 1.000000, 1.000000, 0.880000, 0.750000, 0.920000, 0.990000,
	0.990000, 0.940000, 0.390000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.720000, 0.900000, 0.900000, 0.910000, 0.930000, 0.740000,
	0.720000, 0.770000, 0.750000, 0.570000, 0.560000, 0.220000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.430000, 0.640000, 0.640000, 0.650000, 0.700000,
	0.700000, 0.700000, 0.770000, 0.790000, 0.620000, 0.470000, 0.470000,
	0.330000, 0.340000, 0.300000, 0.040000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.270000, 0.440000, 0.440000, 0.440000, 0.490000,
	0.520000, 0.590000, 0.590000, 0.590000, 0.590000, 0.510000, 0.300000,
	0.300000, 0.210000, 0.240000, 0.180000, 0.100000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.190000, 0.320000, 0.320000, 0.320000,
	0.360000, 0.380000, 0.440000, 0.500000, 0.500000, 0.500000, 0.500000,
	0.500000, 0.500000, 0.320000, 0.210000, 0.200000, 0.170000, 0.040000,
	0.040000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Prosp_GARPUN_300_D_4(
	parrUZP_Ca76_Prosp_GARPUN_300_D_4_ArgTab1,
	NumUZP_Ca76_Prosp_GARPUN_300_D_4, parrUZP_Ca76_Prosp_GARPUN_300_D_4_ArgTab2,
	NumUZP_Ca76_Prosp_GARPUN_300_D_4_ColsTab2,
	parrUZP_Ca76_Prosp_GARPUN_300_D_4_Val);

// 3. 76 ПЕРСПЕКТИВНЫЙ GARPUN V=300 D=6 km
// недолет
double parrUZP_Ca76_Prosp_GARPUN_300_D_6_ArgTab1[] = {
	-7.370000, -6.870000, -6.370000, -5.870000, -5.370000, -4.870000,
	-4.370000, -3.870000, -3.370000, -2.870000, -2.370000, -1.870000, -1.370000, -0.870000,
	-0.370000, 0.130000, 0.630000, 1.130000, 1.630000, 2.130000, 2.630000,
	3.130000, 3.630000, 4.130000, 4.630000
};
int NumUZP_Ca76_Prosp_GARPUN_300_D_6 = 25;

// промах
double parrUZP_Ca76_Prosp_GARPUN_300_D_6_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Prosp_GARPUN_300_D_6_ColsTab2 = 6;

double parrUZP_Ca76_Prosp_GARPUN_300_D_6_Val[] = {

	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 1.000000, 1.000000, 1.000000, 0.950000, 0.870000, 0.970000,
	1.000000, 0.990000, 0.980000, 0.190000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.780000, 0.940000, 0.940000, 0.940000, 0.960000, 0.850000,
	0.730000, 0.800000, 0.790000, 0.650000, 0.570000, 0.180000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.610000, 0.820000, 0.820000, 0.830000, 0.860000, 0.720000, 0.550000,
	0.600000, 0.590000, 0.510000, 0.400000, 0.120000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.410000, 0.630000, 0.630000, 0.630000, 0.680000, 0.700000, 0.760000,
	0.780000, 0.780000, 0.780000, 0.620000, 0.410000, 0.410000, 0.380000,
	0.290000, 0.250000, 0.070000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.210000, 0.360000, 0.360000, 0.360000, 0.400000, 0.420000, 0.480000,
	0.490000, 0.490000, 0.490000, 0.490000, 0.490000, 0.440000, 0.260000,
	0.210000, 0.210000, 0.180000, 0.120000, 0.090000, 0.010000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000

};

TTable_2D Table_2D_KZP_Ca76_Prosp_GARPUN_300_D_6(
	parrUZP_Ca76_Prosp_GARPUN_300_D_6_ArgTab1,
	NumUZP_Ca76_Prosp_GARPUN_300_D_6, parrUZP_Ca76_Prosp_GARPUN_300_D_6_ArgTab2,
	NumUZP_Ca76_Prosp_GARPUN_300_D_6_ColsTab2,
	parrUZP_Ca76_Prosp_GARPUN_300_D_6_Val);
// дальности
double parrKZP_Ca76_Prosp_GARPUN_300_ArgTab3[] = {
	2000., 4000., 6000.
};

TTable_3D Table_3D_KZP_Ca76_Prosp_GARPUN_300(
	parrKZP_Ca76_Prosp_GARPUN_300_ArgTab3,
	Table_2D_KZP_Ca76_Prosp_GARPUN_300_D_2,
	Table_2D_KZP_Ca76_Prosp_GARPUN_300_D_4,
	Table_2D_KZP_Ca76_Prosp_GARPUN_300_D_6);

////
////

/////////////////////////////////////////////////////
////////  76  ПЕРСПЕКТИВНЫЙ  && GARPUN_700 /////////////////////////////////////////////
/////////////////////////////////////////////////////

// 2.2.1. 76 ПЕРСПЕКТИВНЫЙ   GARPUN V=700 D=2 km
// недолет
extern double parrUZP_Ca76_Prosp_GARPUN_700_D_2_ArgTab1[] = {
	-13.090000, -12.590000, -12.090000, -11.590000, -11.090000, -10.590000,
	-10.090000, -9.590000, -9.090000, -8.590000, -8.090000, -7.590000, -7.090000,
	-6.590000, -6.090000, -5.590000, -5.090000, -4.590000, -4.090000, -3.590000,
	-3.090000, -2.590000, -2.090000, -1.590000, -1.090000, -0.590000, -0.090000,
	0.410000, 0.910000, 1.410000, 1.910000, 2.410000, 2.910000

};
extern int NumUZP_Ca76_Prosp_GARPUN_700_D_2 = 33;

// промах
extern double parrUZP_Ca76_Prosp_GARPUN_700_D_2_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
extern int NumUZP_Ca76_Prosp_GARPUN_700_D_2_ColsTab2 = 6;

extern double parrUZP_Ca76_Prosp_GARPUN_700_D_2_Val[] = {
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 1.000000, 1.000000, 1.000000, 0.950000, 0.870000, 0.970000,
	1.000000, 0.990000, 0.980000, 0.190000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.780000, 0.940000, 0.940000, 0.940000, 0.960000, 0.850000,
	0.730000, 0.800000, 0.790000, 0.650000, 0.570000, 0.180000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.610000, 0.820000, 0.820000, 0.830000, 0.860000, 0.720000, 0.550000,
	0.600000, 0.590000, 0.510000, 0.400000, 0.120000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.410000, 0.630000, 0.630000, 0.630000, 0.680000, 0.700000, 0.760000,
	0.780000, 0.780000, 0.780000, 0.620000, 0.410000, 0.410000, 0.380000,
	0.290000, 0.250000, 0.070000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.210000, 0.360000, 0.360000, 0.360000, 0.400000, 0.420000, 0.480000,
	0.490000, 0.490000, 0.490000, 0.490000, 0.490000, 0.440000, 0.260000,
	0.210000, 0.210000, 0.180000, 0.120000, 0.090000, 0.010000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Prosp_GARPUN_700_D_2(
	parrUZP_Ca76_Prosp_GARPUN_700_D_2_ArgTab1,
	NumUZP_Ca76_Prosp_GARPUN_700_D_2, parrUZP_Ca76_Prosp_GARPUN_700_D_2_ArgTab2,
	NumUZP_Ca76_Prosp_GARPUN_700_D_2_ColsTab2,
	parrUZP_Ca76_Prosp_GARPUN_700_D_2_Val);

// 3.2.2. 76 ПЕРСПЕКТИВНЫЙ && GARPUN V=700 && D=4 km
// недолет
double parrUZP_Ca76_Prosp_GARPUN_700_D_4_ArgTab1[] = {
	-11.800000, -11.300000, -10.800000, -10.300000, -9.800000, -9.300000,
	-8.800000, -8.300000, -7.800000, -7.300000, -6.800000, -6.300000, -5.800000,
	-5.300000, -4.800000, -4.300000, -3.800000, -3.300000, -2.800000, -2.300000,
	-1.800000, -1.300000, -0.800000, -0.300000, 0.200000, 0.700000, 1.200000,
	1.700000, 2.200000, 2.700000, 3.200000
};
int NumUZP_Ca76_Prosp_GARPUN_700_D_4 = 31;

// промах
double parrUZP_Ca76_Prosp_GARPUN_700_D_4_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Prosp_GARPUN_700_D_4_ColsTab2 = 6;

double parrUZP_Ca76_Prosp_GARPUN_700_D_4_Val[] = {

	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000,
	1.000000, 1.000000, 0.890000, 0.810000, 0.900000, 0.990000, 0.970000,
	0.940000, 0.140000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.770000, 0.930000, 0.930000,
	0.940000, 0.960000, 0.850000, 0.720000, 0.800000, 0.790000, 0.650000,
	0.560000, 0.170000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.480000, 0.700000, 0.700000, 0.710000, 0.750000,
	0.780000, 0.830000, 0.810000, 0.590000, 0.480000, 0.480000, 0.430000,
	0.330000, 0.290000, 0.030000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.310000, 0.490000, 0.490000, 0.500000, 0.540000, 0.570000,
	0.630000, 0.650000, 0.650000, 0.650000, 0.500000, 0.310000, 0.310000,
	0.300000, 0.230000, 0.190000, 0.050000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.210000,
	0.350000, 0.350000, 0.350000, 0.390000, 0.410000, 0.470000, 0.480000,
	0.480000, 0.480000, 0.480000, 0.480000, 0.450000, 0.280000, 0.210000,
	0.180000, 0.130000, 0.100000, 0.010000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Prosp_GARPUN_700_D_4(
	parrUZP_Ca76_Prosp_GARPUN_700_D_4_ArgTab1,
	NumUZP_Ca76_Prosp_GARPUN_700_D_4, parrUZP_Ca76_Prosp_GARPUN_700_D_4_ArgTab2,
	NumUZP_Ca76_Prosp_GARPUN_700_D_4_ColsTab2,
	parrUZP_Ca76_Prosp_GARPUN_700_D_4_Val);
// 2.2.3. 76 ПЕРСПЕКТИВНЫЙ  GARPUN V=700 D=6 km
// недолет
double parrUZP_Ca76_Prosp_GARPUN_700_D_6_ArgTab1[] = {
	-10.320000, -9.820000, -9.320000, -8.820000, -8.320000, -7.820000,
	-7.320000, -6.820000, -6.320000, -5.820000, -5.320000, -4.820000, -4.320000,
	-3.820000, -3.320000, -2.820000, -2.320000, -1.820000, -1.320000, -0.820000,
	-0.320000, 0.180000, 0.680000, 1.180000, 1.680000, 2.180000, 2.680000,
	3.180000, 3.680000
};
int NumUZP_Ca76_Prosp_GARPUN_700_D_6 = 29;

// промах
double parrUZP_Ca76_Prosp_GARPUN_700_D_6_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Prosp_GARPUN_700_D_6_ColsTab2 = 6;

double parrUZP_Ca76_Prosp_GARPUN_700_D_6_Val[] = {
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000, 1.000000,
	0.930000, 0.810000, 0.920000, 0.980000, 0.960000, 0.900000, 0.100000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.760000, 0.930000, 0.930000, 0.950000, 0.860000, 0.720000, 0.770000,
	0.760000, 0.660000, 0.560000, 0.220000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.470000, 0.690000, 0.690000,
	0.700000, 0.750000, 0.770000, 0.820000, 0.840000, 0.610000, 0.610000,
	0.480000, 0.480000, 0.430000, 0.340000, 0.300000, 0.040000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.300000, 0.490000, 0.490000, 0.490000, 0.550000, 0.560000,
	0.630000, 0.640000, 0.640000, 0.640000, 0.500000, 0.310000, 0.310000,
	0.300000, 0.250000, 0.190000, 0.080000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.200000, 0.340000,
	0.340000, 0.350000, 0.390000, 0.410000, 0.460000, 0.480000, 0.480000,
	0.480000, 0.480000, 0.480000, 0.480000, 0.290000, 0.210000, 0.210000,
	0.180000, 0.130000, 0.120000, 0.010000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000

};

TTable_2D Table_2D_KZP_Ca76_Prosp_GARPUN_700_D_6(
	parrUZP_Ca76_Prosp_GARPUN_700_D_6_ArgTab1,
	NumUZP_Ca76_Prosp_GARPUN_700_D_6, parrUZP_Ca76_Prosp_GARPUN_700_D_6_ArgTab2,
	NumUZP_Ca76_Prosp_GARPUN_700_D_6_ColsTab2,
	parrUZP_Ca76_Prosp_GARPUN_700_D_6_Val);

///

// ДАЛЬНОСТИ
double parrKZP_Ca76_Prosp_GARPUN_700_ArgTab3[] = {
	2000., 4000., 6000.
};

TTable_3D Table_3D_KZP_Ca76_Prosp_GARPUN_700(
	parrKZP_Ca76_Prosp_GARPUN_700_ArgTab3,
	Table_2D_KZP_Ca76_Prosp_GARPUN_700_D_2,
	Table_2D_KZP_Ca76_Prosp_GARPUN_700_D_4,
	Table_2D_KZP_Ca76_Prosp_GARPUN_700_D_6);

///

/////////////////////////////////////////////////////
//////// 76 ПЕОСПЕКТИВНЫЙ &&    GARPUN_1000 /////////////////////////////////////////////
/////////////////////////////////////////////////////
/// 2.3.1.  ДАЛЬНОСТЬ 2
// недолет
double parrUZP_Ca76_Prosp_GARPUN_1000_D_2_ArgTab1[] = {
	-24.390000, -23.890000, -23.390000, -22.890000, -22.390000, -21.890000,
	-21.390000, -20.890000, -20.390000, -19.890000, -19.390000, -18.890000,
	-18.390000, -17.890000, -17.390000, -16.890000, -16.390000, -15.890000,
	-15.390000, -14.890000, -14.390000, -13.890000, -13.390000, -12.890000,
	-12.390000, -11.890000, -11.390000, -10.890000, -10.390000, -9.890000,
	-9.390000, -8.890000, -8.390000, -7.890000, -7.390000, -6.890000, -6.390000,
	-5.890000, -5.390000, -4.890000, -4.390000, -3.890000, -3.390000, -2.890000,
	-2.390000, -1.890000, -1.390000, -0.890000, -0.390000, 0.110000
};
int NumUZP_Ca76_Prosp_GARPUN_1000_D_2 = 50;

// промах
double parrUZP_Ca76_Prosp_GARPUN_1000_D_2_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Prosp_GARPUN_1000_D_2_ColsTab2 = 6;

double parrUZP_Ca76_Prosp_GARPUN_1000_D_2_Val[] = {
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 1.000000, 1.000000,
	1.000000, 0.870000, 0.830000, 0.920000, 0.970000, 0.970000, 0.930000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.820000, 0.950000, 0.950000, 0.950000,
	0.970000, 0.820000, 0.740000, 0.780000, 0.760000, 0.640000, 0.580000,
	0.180000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.530000, 0.740000, 0.740000, 0.740000, 0.780000,
	0.800000, 0.850000, 0.760000, 0.550000, 0.550000, 0.420000, 0.320000,
	0.210000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.350000, 0.530000, 0.530000, 0.530000, 0.580000, 0.600000, 0.660000,
	0.680000, 0.680000, 0.680000, 0.450000, 0.320000, 0.320000, 0.290000,
	0.220000, 0.190000, 0.050000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.240000, 0.380000,
	0.380000, 0.390000, 0.430000, 0.450000, 0.500000, 0.520000, 0.520000,
	0.520000, 0.520000, 0.520000, 0.340000, 0.220000, 0.220000, 0.210000,
	0.170000, 0.130000, 0.050000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Prosp_GARPUN_1000_D_2(
	parrUZP_Ca76_Prosp_GARPUN_1000_D_2_ArgTab1,
	NumUZP_Ca76_Prosp_GARPUN_1000_D_2,
	parrUZP_Ca76_Prosp_GARPUN_1000_D_2_ArgTab2,
	NumUZP_Ca76_Prosp_GARPUN_1000_D_2_ColsTab2,
	parrUZP_Ca76_Prosp_GARPUN_1000_D_2_Val);
// 2.3.2. 76 ПЕОСПЕКЬТИВНЫЙ GARPUN V=1000 D=4 km
// недолет
double parrUZP_Ca76_Prosp_GARPUN_1000_D_4_ArgTab1[] = {
	-14.020000, -13.520000, -13.020000, -12.520000, -12.020000, -11.520000,
	-11.020000, -10.520000, -10.020000, -9.520000, -9.020000, -8.520000, -8.020000,
	-7.520000, -7.020000, -6.520000, -6.020000, -5.520000, -5.020000,
	-4.520000, -4.020000, -3.520000, -3.020000, -2.520000, -2.020000, -1.520000, -1.020000,
	-0.520000, -0.020000, 0.480000, 0.980000, 1.480000, 1.980000, 2.480000
};
int NumUZP_Ca76_Prosp_GARPUN_1000_D_4 = 34;

// промах
double parrUZP_Ca76_Prosp_GARPUN_1000_D_4_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Prosp_GARPUN_1000_D_4_ColsTab2 = 6;

double parrUZP_Ca76_Prosp_GARPUN_1000_D_4_Val[] = {

	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 1.000000, 1.000000, 1.000000, 0.860000, 0.820000,
	0.930000, 0.940000, 0.970000, 0.930000, 0.140000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.790000, 0.940000, 0.940000, 0.950000,
	0.960000, 0.830000, 0.730000, 0.780000, 0.750000, 0.650000, 0.570000,
	0.180000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.500000, 0.720000, 0.720000, 0.730000,
	0.770000, 0.790000, 0.840000, 0.860000, 0.570000, 0.490000, 0.490000,
	0.430000, 0.310000, 0.210000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.320000, 0.510000, 0.510000,
	0.510000, 0.560000, 0.580000, 0.650000, 0.660000, 0.660000, 0.660000,
	0.500000, 0.310000, 0.310000, 0.310000, 0.240000, 0.190000, 0.050000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.220000, 0.370000, 0.370000,
	0.370000, 0.410000, 0.430000, 0.490000, 0.500000, 0.500000, 0.500000,
	0.500000, 0.500000, 0.400000, 0.270000, 0.210000, 0.210000, 0.170000,
	0.130000, 0.080000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000
};

TTable_2D Table_2D_KZP_Ca76_Prosp_GARPUN_1000_D_4(
	parrUZP_Ca76_Prosp_GARPUN_1000_D_4_ArgTab1,
	NumUZP_Ca76_Prosp_GARPUN_1000_D_4,
	parrUZP_Ca76_Prosp_GARPUN_1000_D_4_ArgTab2,
	NumUZP_Ca76_Prosp_GARPUN_1000_D_4_ColsTab2,
	parrUZP_Ca76_Prosp_GARPUN_1000_D_4_Val);

// 2.3.3. 76 ПЕРСПЕКТИВНЫЙ  GARPUN V=1000 D=6 km
// недолет
double parrUZP_Ca76_Prosp_GARPUN_1000_D_6_ArgTab1[] = {
	-12.530000, -12.030000, -11.530000, -11.030000, -10.530000, -10.030000,
	-9.530000, -9.030000, -8.530000, -8.030000, -7.530000, -7.030000, -6.530000,
	-6.030000, -5.530000, -5.030000, -4.530000, -4.030000, -3.530000, -3.030000,
	-2.530000, -2.030000, -1.530000, -1.030000, -0.530000, -0.030000, 0.470000,
	0.970000, 1.470000, 1.970000, 2.470000, 2.970000, 3.470000, 3.970000,
	4.470000, 4.970000
};
int NumUZP_Ca76_Prosp_GARPUN_1000_D_6 = 36;

// промах
double parrUZP_Ca76_Prosp_GARPUN_1000_D_6_ArgTab2[] = {
	2., 4., 6., 8., 10., 10.1
};
int NumUZP_Ca76_Prosp_GARPUN_1000_D_6_ColsTab2 = 6;

double parrUZP_Ca76_Prosp_GARPUN_1000_D_6_Val[] = {
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	1.000000, 1.000000, 1.000000, 0.890000, 0.820000, 0.930000, 0.990000,
	0.970000, 0.940000, 0.230000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.780000, 0.940000, 0.940000, 0.940000,
	0.960000, 0.850000, 0.730000, 0.780000, 0.760000, 0.670000, 0.570000,
	0.180000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.490000,
	0.710000, 0.710000, 0.720000, 0.760000, 0.780000, 0.840000, 0.800000,
	0.550000, 0.490000, 0.490000, 0.420000, 0.310000, 0.250000, 0.030000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.310000, 0.500000, 0.500000, 0.510000, 0.550000,
	0.570000, 0.640000, 0.650000, 0.650000, 0.650000, 0.500000, 0.310000,
	0.310000, 0.300000, 0.240000, 0.190000, 0.050000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.210000, 0.350000,
	0.350000, 0.360000, 0.390000, 0.420000, 0.470000, 0.490000, 0.490000,
	0.490000, 0.490000, 0.490000, 0.400000, 0.210000, 0.210000, 0.200000,
	0.160000, 0.120000, 0.050000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000,
	0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000
};

TTable_2D Table_2D_KZP_Ca76_Prosp_GARPUN_1000_D_6(
	parrUZP_Ca76_Prosp_GARPUN_1000_D_6_ArgTab1,
	NumUZP_Ca76_Prosp_GARPUN_1000_D_6,
	parrUZP_Ca76_Prosp_GARPUN_1000_D_6_ArgTab2,
	NumUZP_Ca76_Prosp_GARPUN_1000_D_6_ColsTab2,
	parrUZP_Ca76_Prosp_GARPUN_1000_D_6_Val);

///
// ДАЛЬНОСТИ
double parrKZP_Ca76_Prosp_GARPUN_1000_ArgTab3[] = {
	2000., 4000., 6000.
};

TTable_3D Table_3D_KZP_Ca76_Prosp_GARPUN_1000(
	parrKZP_Ca76_Prosp_GARPUN_1000_ArgTab3,
	Table_2D_KZP_Ca76_Prosp_GARPUN_1000_D_2,
	Table_2D_KZP_Ca76_Prosp_GARPUN_1000_D_4,
	Table_2D_KZP_Ca76_Prosp_GARPUN_1000_D_6);

// -------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------
// -------------------------------------------------------------------------------------------

// БЕРЕГОВЫЕ//

// Приведенная площадь (УЗП) по 130 калибр береговая цель
extern const double VAl_YZP_ForOpenManPower_Calibro130 = 1341.;
extern const double VAl_YZP_ForOpenManPower_Calibro100 = 557.;

// условный закон поражения, 130 мм ,  ВУ ДВМ60  гипотетический
double X_yzp_Calibro130_Garpun_DVM60_TypeB[8] = {
	0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 7.
};
double Y_yzp_Calibro130_Garpun_DVM60_TypeB[8] = {
	1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.1, 0.
};
TURPolyLine plnUZP_Calibro130_Garpun_DVM60(X_yzp_Calibro130_Garpun_DVM60_TypeB,
	Y_yzp_Calibro130_Garpun_DVM60_TypeB, 8);
///

// условный закон поражения, 100 мм ,  ВУ ДВМ60     гипотетический
double X_yzp_Calibro100_Garpun_DVM60_TypeB[8] = {
	0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 5.
};
double Y_yzp_Calibro100_Garpun_DVM60_TypeB[8] = {
	1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.1, 0.
};
TURPolyLine plnUZP_Calibro100_Garpun_DVM60(X_yzp_Calibro100_Garpun_DVM60_TypeB,
	Y_yzp_Calibro100_Garpun_DVM60_TypeB, 8);
///

// константы для вычисления УЗП Скалыги по самолету  для калибра 130
const double VAlR_Calibro130_Plane = 12.;
const double VAllProbMean_Calibro130_Plane = 0.21;
///
// константы для вычисления УЗП Скалыги по самолету  для калибра 100
const double VAlR_Calibro100_Plane = 12.;
const double VAllProbMean_Calibro100_Plane = 0.16;

// Приведенные площади для МФИВУ
/*
extern const	double arrSPrived[] =
{
//H=     0       3     6     9

89.0,  98.5,  91.8,  92.6  			// ОЖС-Л, L= 10 km
, 96.3, 103.6,  99.6, 106.4   			// OЖС-Л, L= 16 km
,172.7, 178.5, 195.8, 195.8            	// ОЖС-Л, L= 23 km

,137.6, 138.2, 117.8, 104.1  			// ОЖС-C, L= 10 km
,156.8, 150.7, 130.6, 118.3   			// OЖС-C, L= 16 km
,269.1, 298.2, 278.0, 241.1            	// ОЖС-C, L= 23 km

//H=     0       3     6     9

, 72.7,  81.9,  69.6,  65.6  			// ОЖС-Бр-Л, L= 10 km
, 77.7,  85.3,  74.3,  74.8   			// OЖС-Бр-Л, L= 16 km
,133.2, 138.1, 142.3, 131.7            	// ОЖС-Бр-Л, L= 23 km

,109.9, 112.5,  90.8,  74.7  			// ОЖС-Бр-C, L= 10 km
,123.9, 121.5,  99.5,  83.5   			// OЖС-Бр-C, L= 16 km
,216.5, 233.0, 208.4, 169.0            	// ОЖС-Бр-C, L= 23 km

//H=     0       3     6     9

,92.9,  117.1,  66.2,  90.6  			// УЖС-Ок, L= 10 km
, 92.9,  117.4,  78.8, 108.5   			// УЖС-Ок, L= 16 km
, 92.9,  120.8, 100.2, 116.7            // УЖС-Ок, L= 23 km

,102.4,  151.7, 101.3,  94.3  			// УЖС-Тр, L= 10 km
,100.0,  155.4, 112.1, 107.3   			// УЖС-Тр, L= 16 km
, 99.7,  194.9, 186.6, 150.7            // УЖС-Тр, L= 23 km

//H=     0       3     6     9

,24.2,  25.2,  30.8,  31.8  			// УЖС-БТР, L= 10 km
, 22.1,  30.2,  35.9,  36.2   			// УЖС-БТР, L= 16 km
, 31.1,  77.4,  77.6,  62.5             // УЖС-БТР, L= 23 km

, 63.4,  49.0,  56.3,  57.1  			// УЖС-АМ,  L= 10 km
, 67.5,  56.2,  62.6,  62.6   			// УЖС-АМ,  L= 16 km
, 81.3, 127.8, 124.8, 112.5             // УЖС-АМ,  L= 23 km

//H=     0       3     6     9

} ;
 */
extern const double arrSPrived[] = {
	// H=     0       3     6     9

	537, 572, 559, 577 // ОЖС-Л, L= 10 km
	, 592, 610, 612, 649 // OЖС-Л, L= 16 km
	, 1189, 1089, 1191, 1246 // ОЖС-Л, L= 23 km

	, 889, 877, 793, 735 // ОЖС-C, L= 10 km
	, 1037, 997, 908, 863 // OЖС-C, L= 16 km
	, 2069, 2023, 1913, 1813 // ОЖС-C, L= 23 km

	// H=     0       3     6     9

	, 414, 450, 410, 406 // ОЖС-Бр-Л, L= 10 km
	, 450, 472, 441, 453 // OЖС-Бр-Л, L= 16 km
	, 859, 803, 854, 845 // ОЖС-Бр-Л, L= 23 km

	, 669, 670, 583, 515 // ОЖС-Бр-C, L= 10 km
	, 777, 753, 659, 599 // OЖС-Бр-C, L= 16 km
	, 1544, 1487, 1387, 1256 // ОЖС-Бр-C, L= 23 km

	// H=     0       3     6     9

	, 97, 123, 75, 116 // УЖС-Ок, L= 10 km
	, 97, 125, 91, 142 // УЖС-Ок, L= 16 km
	, 97, 128, 119, 155 // УЖС-Ок, L= 23 km

	, 109, 170, 145, 170 // УЖС-Тр, L= 10 km
	, 109, 182, 163, 191 // УЖС-Тр, L= 16 km
	, 107, 238, 293, 298 // УЖС-Тр, L= 23 km

	// H=     0       3     6     9

	, 343, 324, 320, 319 // УЖС-БТР, L= 10 km
	, 368, 364, 353, 358 // УЖС-БТР, L= 16 km
	, 598, 758, 707, 626 // УЖС-БТР, L= 23 km

	, 400, 323, 360, 368 // УЖС-АМ,  L= 10 km
	, 442, 371, 404, 411 // УЖС-АМ,  L= 16 km
	, 750, 817, 833, 821 // УЖС-АМ,  L= 23 km

	// H=     0       3     6     9

	, 44, 44, 44, 44 // ВОП, L= 10 km
	, 18, 18, 18, 18 // ВОП, L= 16 km
	, 10, 10, 10, 10 // ВОП, L= 23 km

};
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////// SEA TARGS////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

// 1. УЗП  для эсминца калибр 130 (к-во прямых попаданий) по Скалыге  (ВУ D4MRM)
const double VAlQuantNesessaryHits_Destr_CALIBRO_SHTAT_130 = 7.1;

// 2. УЗП  для катера калибр 130 (к-во прямых попаданий) по Скалыге  (ВУ D4MRM)
const double VAlQuantNesessaryHits_Cutter_CALIBRO_SHTAT_130 = 1.4;
// 3. УЗП  для эсминца калибр 100 (к-во прямых попаданий) по Скалыге (ВУ D4MRM)
const double VAlQuantNesessaryHits_Destr_Calibro_100 = 11.5;

// 4. УЗП  для катера калибр 100 (к-во прямых попаданий) по Скалыге  (ВУ D4MRM)
const double VAlQuantNesessaryHits_Cutter_Calibro_100 = 2.;

// 5. ТАблица УЗП для эсминца для МФИВУ оптимистический вариант промахов
// const double VAlQuantNesessaryHits_Cutter_Calibro_100 = 2.;

extern double arrDestrUZP[] = {
	0.176, 0.328, 0.455, 0.550, 0.630, 0.685, 0.732, 0.776, 0.809, 0.832,
	0.852, 0.870, 0.882, 0.893, 0.902, 0.911, 0.918, 0.925, 0.930, 0.935, 0.940, 0.944,
	0.947, 0.950, 0.953, 0.955, 0.957, 0.960, 0.961, 0.963, 0.966, 0.968,
	0.969, 0.972, 0.973, 0.974, 0.975, 0.977, 0.978, 0.979, 0.980, 0.980, 0.981, 0.982,
	0.983, 0.984, 0.985, 0.986, 0.987, 0.987, 0.988, 0.988, 0.990, 0.990,
	0.991, 0.991, 0.992, 0.992, 0.993, 0.993, 0.994, 0.994, 0.994, 0.994, 0.995, 0.995,
	0.995, 0.996, 0.996, 0.996, 0.996, 0.103, 0.203, 0.300, 0.387, 0.459,
	0.528, 0.588, 0.640, 0.683, 0.720, 0.751, 0.782, 0.804, 0.826, 0.844, 0.859, 0.872,
	0.882, 0.891, 0.898, 0.905, 0.913, 0.919, 0.924, 0.929, 0.934, 0.939,
	0.943, 0.947, 0.950, 0.954, 0.957, 0.960, 0.963, 0.966, 0.968, 0.970, 0.972, 0.973,
	0.976, 0.977, 0.979, 0.980, 0.981, 0.983, 0.983, 0.985, 0.985, 0.986,
	0.987, 0.988, 0.988, 0.989, 0.989, 0.990, 0.991, 0.991, 0.992, 0.992, 0.993, 0.994,
	0.994, 0.994, 0.995, 0.995, 0.995, 0.995, 0.996, 0.996, 0.996, 0.996,
	0.070, 0.138, 0.206, 0.271, 0.329, 0.389, 0.444, 0.497, 0.546, 0.588, 0.629, 0.669,
	0.703, 0.733, 0.761, 0.788, 0.809, 0.829, 0.846, 0.861, 0.875, 0.889,
	0.901, 0.911, 0.918, 0.928, 0.936, 0.942, 0.948, 0.953, 0.959, 0.963, 0.967, 0.971,
	0.974, 0.977, 0.979, 0.981, 0.983, 0.985, 0.987, 0.988, 0.989, 0.990,
	0.991, 0.992, 0.993, 0.993, 0.994, 0.995, 0.995, 0.996, 0.996, 0.997, 0.997, 0.997,
	0.997, 0.998, 0.998, 0.998, 0.998, 0.999, 0.999, 0.999, 0.999, 0.999,
	0.999, 0.999, 0.999, 0.999, 0.999, 0.055, 0.113, 0.168, 0.224, 0.281, 0.335, 0.386,
	0.433, 0.475, 0.517, 0.559, 0.594, 0.630, 0.660, 0.688, 0.711, 0.733,
	0.751, 0.771, 0.789, 0.805, 0.818, 0.830, 0.843, 0.853, 0.864, 0.875, 0.884, 0.891,
	0.899, 0.904, 0.911, 0.918, 0.924, 0.929, 0.934, 0.937, 0.940, 0.943,
	0.947, 0.949, 0.953, 0.957, 0.960, 0.962, 0.963, 0.965, 0.967, 0.969, 0.971, 0.973,
	0.974, 0.976, 0.977, 0.979, 0.980, 0.983, 0.984, 0.985, 0.986, 0.987,
	0.987, 0.988, 0.989, 0.989, 0.990, 0.991, 0.992, 0.992, 0.993, 0.993, 0.057, 0.114,
	0.17, 0.226, 0.28, 0.331, 0.381, 0.434, 0.479, 0.525, 0.571, 0.61, 0.647,
	0.677, 0.708, 0.737, 0.763, 0.786, 0.805, 0.824, 0.84, 0.854, 0.871, 0.884,
	0.895, 0.906, 0.916, 0.923, 0.93, 0.937, 0.943, 0.949, 0.954, 0.959, 0.964,
	0.968, 0.971, 0.975, 0.978, 0.98, 0.982, 0.985, 0.986, 0.987, 0.988, 0.99,
	0.991, 0.992, 0.992, 0.993, 0.994, 0.994, 0.995, 0.995, 0.996, 0.996,
	0.997, 0.997, 0.997, 0.997, 0.997, 0.998, 0.998, 0.998, 0.998, 0.999, 0.999, 0.999,
	0.999, 0.999, 0.999
};

const int NumColsTab2_DestrUZP = 5;
double arrArgTab2_DestrUZP[] = {
	7., 10., 14., 16., 18.
};
extern const int NumColsTab1_DestrUZP = 71;
double arrArgTab1_DestrUZP[] = {
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
	41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
	60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71
};
TTable_2D TableUZP_Destr(arrArgTab1_DestrUZP, NumColsTab1_DestrUZP,
	arrArgTab2_DestrUZP, NumColsTab2_DestrUZP, arrDestrUZP);
///

// 5. ТАблица УЗП для эсминца для МФИВУ оптимистический вариант промахов
// const double VAlQuantNesessaryHits_Cutter_Calibro_100 = 2.;

extern double arrCutterUZP[] = {
	0.103, 0.196, 0.296, 0.364, 0.439, 0.496, 0.556, 0.606, 0.652, 0.699,
	0.723, 0.751, 0.779, 0.801, 0.828, 0.851, 0.866, 0.886, 0.895, 0.916, 0.923, 0.933,
	0.940, 0.947, 0.951, 0.956, 0.961, 0.966, 0.971, 0.978, 0.982, 0.983,
	0.983, 0.986, 0.986, 0.986, 0.989, 0.990, 0.992, 0.992, 0.993, 0.997, 0.997, 0.997,
	0.998, 0.097, 0.205, 0.275, 0.354, 0.412, 0.476, 0.546, 0.603, 0.653,
	0.693, 0.723, 0.763, 0.795, 0.817, 0.837, 0.861, 0.876, 0.889, 0.900, 0.917, 0.925,
	0.935, 0.940, 0.951, 0.956, 0.960, 0.966, 0.969, 0.971, 0.974, 0.978,
	0.980, 0.981, 0.982, 0.984, 0.985, 0.985, 0.986, 0.989, 0.989, 0.990, 0.990, 0.991,
	0.992, 0.994, 0.119, 0.238, 0.354, 0.440, 0.511, 0.559, 0.621, 0.664,
	0.717, 0.756, 0.790, 0.816, 0.837, 0.862, 0.879, 0.900, 0.915, 0.927, 0.934, 0.942,
	0.952, 0.957, 0.962, 0.968, 0.971, 0.975, 0.977, 0.979, 0.984, 0.987,
	0.988, 0.990, 0.991, 0.992, 0.993, 0.994, 0.995, 0.995, 0.995, 0.995, 0.995, 0.997,
	0.997, 0.997, 0.997, 0.119, 0.216, 0.302, 0.373, 0.449, 0.522, 0.576,
	0.632, 0.679, 0.714, 0.748, 0.780, 0.807, 0.834, 0.852, 0.866, 0.884, 0.898, 0.910,
	0.917, 0.926, 0.932, 0.940, 0.945, 0.950, 0.952, 0.959, 0.961, 0.967,
	0.970, 0.975, 0.981, 0.984, 0.984, 0.985, 0.989, 0.990, 0.990, 0.991, 0.991, 0.993,
	0.994, 0.995, 0.995, 0.995, 0.105, 0.2, 0.294, 0.368, 0.443, 0.51, 0.582,
	0.637, 0.686, 0.719, 0.767, 0.788, 0.816, 0.839, 0.858, 0.877, 0.889,
	0.899, 0.914, 0.925, 0.928, 0.935, 0.942, 0.948, 0.953, 0.956, 0.958, 0.964, 0.972,
	0.977, 0.98, 0.982, 0.984, 0.986, 0.988, 0.991, 0.993, 0.993, 0.993, 0.994,
	0.995, 0.996, 0.996, 0.997, 0.997
};

const int NumColsTab2_CutterUZP = 5;
double arrArgTab2_CutterUZP[] = {
	7., 10., 14., 16., 18.
};
extern const int NumColsTab1_CutterUZP = 45;
double arrArgTab1_CutterUZP[] = {
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
	41, 42, 43, 44, 45
};
TTable_2D TableUZP_Cutter(arrArgTab1_CutterUZP, NumColsTab1_CutterUZP,
	arrArgTab2_CutterUZP, NumColsTab2_CutterUZP, arrCutterUZP);

///
TNeighbourhoodAppPoint::TNeighbourhoodAppPoint() {

	memset(marrMiss, 0, 6 * sizeof(double));
	memset(marrCorMatrxMiss, 0, 36 * sizeof(double));

	mTarget = TTarget();
	// снаряд
	mShellBody = TShellBody();
	mDistAppPoint = 0.;
	mSigmaCannonDelayT = 0.;
	mTFly = 0.;
	// Искусственный промах
	mMissSimulated = 0.;

	// Искусственный Nedolet
	mPereletSimulated = 0.;

}

// ---------------------------------------------------------------------------

// конструктор копирования
TNeighbourhoodAppPoint::TNeighbourhoodAppPoint(const TNeighbourhoodAppPoint &R)
{
	memcpy(marrMiss, R.marrMiss, 6 * sizeof(double));
	memcpy(marrCorMatrxMiss, R.marrCorMatrxMiss, 36 * sizeof(double));
	mTarget = R.mTarget;
	mShellBody = R.mShellBody;
	mDistAppPoint = R.mDistAppPoint;
	mSigmaCannonDelayT = R.mSigmaCannonDelayT;
	mTFly = R.mTFly;
	mMissSimulated = R.mMissSimulated;
	mPereletSimulated = R.mPereletSimulated;
}
// ---------------------------------------------------------------------------

// оператор присваивания
TNeighbourhoodAppPoint TNeighbourhoodAppPoint:: operator =
	(TNeighbourhoodAppPoint R) {
	memcpy(marrMiss, R.marrMiss, 6 * sizeof(double));
	memcpy(marrCorMatrxMiss, R.marrCorMatrxMiss, 36 * sizeof(double));
	mTarget = R.mTarget;
	mShellBody = R.mShellBody;
	mDistAppPoint = R.mDistAppPoint;
	mSigmaCannonDelayT = R.mSigmaCannonDelayT;
	mTFly = R.mTFly;
	mMissSimulated = R.mMissSimulated;
	mPereletSimulated = R.mPereletSimulated;
	return *this;
}
// ---------------------------------------------------------------------------

// парам конструктор1
TNeighbourhoodAppPoint::TNeighbourhoodAppPoint
	(double *arrMiss, double *arrCorMatrxMiss, const TTarget Target, const TShellBody ShellBody,
	const double VAlDistAppPoint, const double VAlSigmaCannonDelayT) {
	mTarget = Target;
	mShellBody = ShellBody;
	memcpy(marrMiss, arrMiss, 6 * sizeof(double));
	memcpy(marrCorMatrxMiss, arrCorMatrxMiss, 36 * sizeof(double));
	mDistAppPoint = VAlDistAppPoint;
	mSigmaCannonDelayT = VAlSigmaCannonDelayT;
	mTFly = 0.;
	mMissSimulated = 0.;
	mPereletSimulated = 0.;

}

// ---------------------------------------------------------------------------
// парам конструктор2
TNeighbourhoodAppPoint::TNeighbourhoodAppPoint
	(double *arrMiss, double *arrCorMatrxMiss, const TTarget Target, const TShellBody ShellBody,
	const double VAlDistAppPoint, const double VAlSigmaCannonDelayT,
	const double VAlTFly) {
	mTarget = Target;
	mShellBody = ShellBody;
	memcpy(marrMiss, arrMiss, 6 * sizeof(double));
	memcpy(marrCorMatrxMiss, arrCorMatrxMiss, 36 * sizeof(double));
	mDistAppPoint = VAlDistAppPoint;
	mSigmaCannonDelayT = VAlSigmaCannonDelayT;
	mTFly = VAlTFly;
	mMissSimulated = 0.;
	mPereletSimulated = 0.;

}

// ---------------------------------------------------------------------------
// парам конструктор3
TNeighbourhoodAppPoint::TNeighbourhoodAppPoint
	(double *arrMiss, double *arrCorMatrxMiss, const TTarget Target, const TShellBody ShellBody,
	const double VAlDistAppPoint, const double VAlSigmaCannonDelayT,
	const double VAlTFly, const double VAlMissSimulated, const double VAlPereletSimulated) {
	mTarget = Target;
	mShellBody = ShellBody;
	memcpy(marrMiss, arrMiss, 6 * sizeof(double));
	memcpy(marrCorMatrxMiss, arrCorMatrxMiss, 36 * sizeof(double));
	mDistAppPoint = VAlDistAppPoint;
	mSigmaCannonDelayT = VAlSigmaCannonDelayT;
	mTFly = VAlTFly;
	mMissSimulated = VAlMissSimulated;
	mPereletSimulated = VAlPereletSimulated;

}

// ---------------------------------------------------------------------------

// вычисление вероятности пораж самол методом стат испытаний   по Скалыге
// INPUT:
// VAlR - дальность осреднениря
// VAlProbMean - средняя вероятность

// OUTPUT:
// *pvalDestruct  - вероятность поражения
// *pvalDispMiss - дисперсия промаха
void TNeighbourhoodAppPoint::calcProbSkaligaPlaneLaw
	(const double VAlR, const double VAlProbMean, double *pvalDestruct, double *pvalDispMiss) {
	// формирование корреляц матриц по разбросу положения и скорости
	double arrPosK[9] = {
		0.
	}, arrVelocityK[9] = {
		0.
	};
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			arrPosK[3 * i + j] = marrCorMatrxMiss[6 * i + j];
			arrVelocityK[3 * i + j] = marrCorMatrxMiss[6 * (i + 3) + j + 3];
		}
	}
	///
	double arrVPos[9] = {
		0.
	}, arrLambPos[9] = {
		0.
	}, arrVVelo[9] = {
		0.
	}, arrLambVelo[9] = {
		0.
	};
	CalcProperVectors_And_Numbers_R3(arrPosK, arrVPos, arrLambPos);
	CalcProperVectors_And_Numbers_R3(arrVelocityK, arrVVelo, arrLambVelo);
	///

	*pvalDestruct = 0.;
	*pvalDispMiss = 0.;
	int iNC = 1000;
	for (int i = 0; i < iNC; i++) {
		double arrKsi[3] = {
			0.
		}, arrPsi[3] = {
			0
		}, arrPos[3] = {
			0.
		}, arrVelo[3] = {
			0.
		}, arrTemp[3] = {
			0.
		};
		arrKsi[0] = getGauss(0., 1.) * sqrt(arrLambPos[0]); ;
		arrKsi[1] = getGauss(0., 1.) * sqrt(arrLambPos[4]);
		arrKsi[2] = getGauss(0., 1.) * sqrt(arrLambPos[8]);
		MtrxMultMatrx(arrVPos, 3, 3, arrKsi, 1, arrTemp);
		MtrxSumMatrx(marrMiss, arrTemp, 3, 1, arrPos);

		arrPsi[0] = getGauss(0., 1.) * arrLambVelo[0];
		arrPsi[1] = getGauss(0., 1.) * arrLambVelo[4];
		arrPsi[2] = getGauss(0., 1.) * arrLambVelo[8];
		MtrxMultMatrx(arrVVelo, 3, 3, arrPsi, 1, arrTemp);
		MtrxSumMatrx(&marrMiss[3], arrTemp, 3, 1, arrVelo);

		double temp = ScalProduct(arrPos, arrVelo, 3) / Norm3(arrVelo);
		double valMissSq = Norm3(arrPos) * Norm3(arrPos) - temp * temp;
		*pvalDispMiss += valMissSq;
		double valPCur = fncScaligaPlaneLaw(VAlR, VAlProbMean, sqrt(valMissSq));
		*pvalDestruct += valPCur;

	}
	*pvalDestruct = (*pvalDestruct) / iNC;
	*pvalDispMiss = *pvalDispMiss / iNC;
}

// ---------------------------------------------------------------------------
// вычисление вероятности пораж самол в соответствии с программой скалыги
// INPUT:
// VAlR1 - дальность осреднениря
// VAlProbMean - средняя вероятность
// VAlMiss - промах
double TNeighbourhoodAppPoint::fncScaligaPlaneLaw
	(const double VAlR1, const double VAlProbMean, const double VAlMiss) {
	double eps, x, Fx, x1, x2, Fx1, So;
	eps = 0.001;
	const double VAlR = VAlR1 * 1.1;
	x = 18.0;
	Fx = (VAlR * VAlR * VAlProbMean) / (1.0 - exp(-VAlR * VAlR / x)) - x;
	for (int i = 1; (fabs(Fx) > eps); i++) {
		x1 = Fx + x;
		Fx1 = (VAlR * VAlR * VAlProbMean) / (1.0 - exp(-VAlR * VAlR / x1)) - x1;
		x2 = Fx1 + x1;
		x = (x * x2 - x1 * x1) / (x2 - 2 * x1 + x);
		Fx = (VAlR * VAlR * VAlProbMean) / (1.0 - exp(-VAlR * VAlR / x)) - x;
	}
	So = sqrt(0.5 * x);
	if (VAlMiss >= VAlR)
		return 0.;
	else
		return exp(-VAlMiss * VAlMiss / (2. * So * So));
}

// ---------------------------------------------------------------------------

// вычисление вероятности пораж самол методом стат испытаний   по Скалыге
// OUTPUT:
// *pvalDestruct  - вероятность поражения
// *pvalDispMiss - дисперсия промаха
void TNeighbourhoodAppPoint::calcProbSkaligaGarpunLaw
	(double *pvalDestruct, double *pvalDispMiss) {
	// выбор условного закона поражения в зависимости от типа цели и снаряда   и ВУ
	TURPolyLine plnUZP;
	if ((mTarget.menumTargetType == GARPUN_V300) &&
		(mShellBody.mEnumShellType == CALIBRO_SHTAT_130)) {
		plnUZP = plnUZP_Calibro130_AR32_Garpun300;
	}

	if ((mTarget.menumTargetType == GARPUN_V300) &&
		(mShellBody.mEnumShellType == CALIBRO_100)) {
		plnUZP = plnUZP_Calibro100_AR32_Garpun300;
	}
	if ((mTarget.menumTargetType == GARPUN_V700) &&
		(mShellBody.mEnumShellType == CALIBRO_SHTAT_130)) {
		plnUZP = plnUZP_Calibro130_AR32_Garpun700;
	}

	/*
	if ((mTarget.menumTargetType == GARPUN_V300) && (mShellBody.mEnumShellType == CALIBRO_76_SHTAT)
	&& (mShellBody.mDetonator.mEnumDetonatorType == AR51_LM ) )
	{
	plnUZP =  plnUZP_76CalShtat_AR31_Garpun300;
	///////	 }
	if ((mTarget.menumTargetType == GARPUN_V700) && (mShellBody.mEnumShellType == CALIBRO_76_SHTAT)
	&& (mShellBody.mDetonator.mEnumDetonatorType == AR51_LM ) )
	{
	plnUZP =  plnUZP_76CalShtat_AR31_Garpun700;
	}

	if ((mTarget.menumTargetType == GARPUN_V300) && (mShellBody.mEnumShellType == CALIBRO_76_BARRIER)
	&& (mShellBody.mDetonator.mEnumDetonatorType == AR51_LM ))
	{
	plnUZP =  plnUZP_76CalBarrier_AR31_Garpun300;
	}


	if ((mTarget.menumTargetType == GARPUN_V700) && (mShellBody.mEnumShellType == CALIBRO_76_BARRIER)
	&& (mShellBody.mDetonator.mEnumDetonatorType == AR51_LM ) )
	{
	plnUZP =  plnUZP_76CalBarrier_AR31_Garpun700;
	}
	 */

	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// формирование корреляц матриц по разбросу положения и скорости
	double arrPosK[9] = {
		0.
	}, arrVelocityK[9] = {
		0.
	};
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			arrPosK[3 * i + j] = marrCorMatrxMiss[6 * i + j];
			arrVelocityK[3 * i + j] = marrCorMatrxMiss[6 * (i + 3) + j + 3];
		}
	}
	///
	double arrVPos[9] = {
		0.
	}, arrMtrxLambPos[9] = {
		0.
	}, arrVVelo[9] = {
		0.
	}, arrMtrxLambVelo[9] = {
		0.
	};
	CalcProperVectors_And_Numbers_R3(arrPosK, arrVPos, arrMtrxLambPos);
	CalcProperVectors_And_Numbers_R3(arrVelocityK, arrVVelo, arrMtrxLambVelo);
	///

	*pvalDestruct = 0.;
	*pvalDispMiss = 0.;
	int iNC = 5000;
	for (int i = 0; i < iNC; i++) {
		double arrKsi[3] = {
			0.
		}, arrPsi[3] = {
			0
		}, arrPos[3] = {
			0.
		}, arrVelo[3] = {
			0.
		}, arrTemp[3] = {
			0.
		};
		arrKsi[0] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[0]); ;
		arrKsi[1] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[4]);
		arrKsi[2] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[8]);
		MtrxMultMatrx(arrVPos, 3, 3, arrKsi, 1, arrTemp);
		MtrxSumMatrx(marrMiss, arrTemp, 3, 1, arrPos);

		arrPsi[0] = getGauss(0., 1.) * arrMtrxLambVelo[0];
		arrPsi[1] = getGauss(0., 1.) * arrMtrxLambVelo[4];
		arrPsi[2] = getGauss(0., 1.) * arrMtrxLambVelo[8];
		MtrxMultMatrx(arrVVelo, 3, 3, arrPsi, 1, arrTemp);
		MtrxSumMatrx(&marrMiss[3], arrTemp, 3, 1, arrVelo);

		double temp = ScalProduct(arrPos, arrVelo, 3) / Norm3(arrVelo);
		double valMissSq = Norm3(arrPos) * Norm3(arrPos) - temp * temp;
		*pvalDispMiss += valMissSq;
		double valPCur = plnUZP.LinearValueApprox(sqrt(valMissSq));
		*pvalDestruct += valPCur;

	}
	*pvalDestruct = (*pvalDestruct) / iNC;
	*pvalDispMiss = *pvalDispMiss / iNC;
} // ---------------------------------------------------------------------------

// вычисление вероятности пораж самол методом стат испытаний
// OUTPUT:
// *pvalDestruct  - вероятность поражения
// *pvalDispMiss - дисперсия промаха
void TNeighbourhoodAppPoint::calcProb_76Calibro_AR51_LM_Garpun
	(TTable_3D Table_3D_KZP, double *pvalDestruct, double *pvalDispMiss) {

	// формирование корреляц матриц по разбросу положения
	double arrPosK[9] = {
		0.
	};
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			arrPosK[3 * i + j] = marrCorMatrxMiss[6 * i + j];
		}
	}
	///
	double arrVPos[9] = {
		0.
	}, arrMtrxLambPos[9] = {
		0.
	}, arrVVelo[9] = {
		0.
	};
	CalcProperVectors_And_Numbers_R3(arrPosK, arrVPos, arrMtrxLambPos);

	///

	*pvalDestruct = 0.;
	*pvalDispMiss = 0.;

	int iNC = 5000;
	for (int i = 0; i < iNC; i++) {
		double arrKsi[3] = {
			0.
		}, arrPos[3] = {
			0.
		}, arrMissNesmeshenKGSK[3] = {
			0.
		};
		arrKsi[0] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[0]); ;
		arrKsi[1] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[4]);
		arrKsi[2] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[8]);
		MtrxMultMatrx(arrVPos, 3, 3, arrKsi, 1, arrMissNesmeshenKGSK);
		MtrxSumMatrx(marrMiss, arrMissNesmeshenKGSK, 3, 1, arrPos);

		double temp = ScalProduct(arrPos, &marrMiss[3], 3) / Norm3
			(&marrMiss[3]);
		double valMissSq = Norm3(arrPos) * Norm3(arrPos) - temp * temp;
		double valMiss = sqrt_(valMissSq);

		double valSensRad = mShellBody.mDetonator.marrDetonatorParams[0];

		if (valMiss > valSensRad) {
			continue;
		}
		double valNedolet = -sqrt(valSensRad * valSensRad - valMissSq);
		*pvalDispMiss += valMissSq;
		double valPCur = Table_3D_KZP.calcValue
			(mDistAppPoint, valMiss, valNedolet);
		*pvalDestruct += valPCur;

	}
	*pvalDestruct = (*pvalDestruct) / iNC;
	*pvalDispMiss = *pvalDispMiss / iNC;

}

// -------------------------------------------------------
void TNeighbourhoodAppPoint::calcProb_76Calibro_DetonBarrier_Garpun
	(TTable_3D Table_3D_KZP, double *pvalDestruct, double *pvalDispMiss) {
	// 1. Вычисление искусственной точки прицеливагния в КГСК
	double arrMissZavishennij[3] = {
		0.
	}, arrPerelet[3] = {
		0.
	}, arrMissSimulatedKGSK[3] = {
		0.
	};
	memcpy(arrMissZavishennij, marrMiss, 3 * sizeof(double));
	arrMissZavishennij[2] += mMissSimulated;

	double valPereletTime = mPereletSimulated / Norm3(&marrMiss[3]);
	MatrxMultScalar(&marrMiss[3], 1, 3, valPereletTime, arrPerelet);

	MtrxSumMatrx(arrMissZavishennij, arrPerelet, 1, 3, arrMissSimulatedKGSK);
	///

	// ошибки дисткретизации ВУ
	double arrCorrMtrxDiscret[9] = {
		0.
	};
	calcCorrMtrxDiscretisation_And_CannonDelayT(arrCorrMtrxDiscret);
	//
	/*
	// формирование корреляц матриц по разбросу положения
	double arrPosK[9] = {0.};
	for (int i = 0; i < 3; i++)
	{
	for (int j  = 0; j < 3; j++)
	{
	arrPosK      [ 3 * i + j] = marrCorMatrxMiss[ 6 * i + j];

	}
	}

	MtrxSumMatrx(arrCorrMtrxDiscret, arrPosK,3, 3, arrPosK) ;
	 */
	// 2. формирование корреляц матрицы по разбросу положения
	double arrPosK[9] = {
		0.
	};
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			arrPosK[3 * i + j] = marrCorMatrxMiss[6 * i + j];
		}
	}
	///
	MtrxSumMatrx(arrCorrMtrxDiscret, arrPosK, 3, 3, arrPosK);
	// 3. диагонализация корреляц матрицы
	double arrVPos[9] = {
		0.
	}, arrMtrxLambPos[9] = {
		0.
	}, arrVVelo[9] = {
		0.
	};
	CalcProperVectors_And_Numbers_R3(arrPosK, arrVPos, arrMtrxLambPos);

	///
	// Метод стат испытаний
	*pvalDestruct = 0.;
	*pvalDispMiss = 0.;
	int iNC = 1000;
	for (int i = 0; i < iNC; i++) {
		double arrKsi[3] = {
			0.
		}, arrPos[3] = {
			0.
		}, arrTemp[3] = {
			0.
		};
		arrKsi[0] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[0]); ;
		arrKsi[1] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[4]);
		arrKsi[2] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[8]);
		MtrxMultMatrx(arrVPos, 3, 3, arrKsi, 1, arrTemp);
		MtrxSumMatrx(arrMissSimulatedKGSK, arrTemp, 3, 1, arrPos);

		// arrPos[3] - это промах по высоте
		// надо проверить что высота точуи срабатывания больше нуля
		// если меньше, то вероятность равна нулю (срабатывание под водой)
		if ((mTarget.mTraject.marrVectSostGSK[2] + arrPos[2]) < 0.) {
			continue;
		}
		///

		double valPerelet = ScalProduct(arrPos, &marrMiss[3], 3) / Norm3
			(&marrMiss[3]);
		double valMissSq = Norm3(arrPos) * Norm3(arrPos)
			- valPerelet * valPerelet;
		if (valMissSq < 0.) {
			valMissSq = 0.;
		}

		double valMiss = sqrt_(valMissSq);
		*pvalDispMiss += valMissSq;

		double valFragmentationP = Table_3D_KZP.calcValue
			(mDistAppPoint, valMiss, valPerelet);
		// double valFragmentationP =0.;
		double valExplosiveP = calcExplosiveProb(arrPos);
		// double valExplosiveP = 0.;

		double valPCur = 1. - (1. - valFragmentationP) * (1. - valExplosiveP);
		*pvalDestruct += valPCur;

	}
	*pvalDestruct = (*pvalDestruct) / iNC;
	*pvalDispMiss = *pvalDispMiss / iNC;

}

// -------------------------------------------------------

// -----------------------------------------------------------------------------------
// вычисление  вероятности поражения для УЗП заж\данного в виде полилинии
// зависящего от промаха
// INPUT:
// plnUZP - УЗП
// arrPosK[9] - коррел матрица разброса вектора промаха по положению
// arrMiss[6] - вектор промаха
// OUTPUT:
// *pvalDestruct - вероятность поражения
// *pvalDispMiss - СКЗ промаха
void TNeighbourhoodAppPoint::calcDestractProb_PlnUZP
	(TURPolyLine plnUZP, double *arrPosK, double *arrMiss, double *pvalDestruct, double *pvalDispMiss,
	double *pvalDispNedolet) {

	double arrVPos[9] = {
		0.
	}, arrMtrxLambPos[9] = {
		0.
	}; // ,arrVVelo[9] = {0.} , arrMtrxLambVelo[9] = {0.};
	CalcProperVectors_And_Numbers_R3(arrPosK, arrVPos, arrMtrxLambPos);

	///
	// смещенная точка прицеливания с недолетом
	double arrAimPoint0[3] = {
		0.
	};

	///
	*pvalDestruct = 0.;
	*pvalDispMiss = 0.;
	*pvalDispNedolet = 0.;

	// установка предлов интегрирования по 3-м осям эллипсоида рассеяния
	int iNc = 100;
	if (arrMtrxLambPos[0] < 0.) {
		arrMtrxLambPos[0] = 0.00001;
	}
	if (arrMtrxLambPos[4] < 0.) {
		arrMtrxLambPos[4] = 0.00001;
	}
	if (arrMtrxLambPos[8] < 0.) {
		arrMtrxLambPos[8] = 0.00001;
	}
	double valLimX = sqrt(arrMtrxLambPos[0]) * 3.;
	double valLimY = sqrt(arrMtrxLambPos[4]) * 3.;
	double valLimZ = sqrt(arrMtrxLambPos[8]) * 3.;
	double valStepX = 2. * valLimX / ((double)iNc);
	double valStepY = 2. * valLimY / ((double)iNc);
	double valStepZ = 2. * valLimZ / ((double)iNc);

	double valSum = 0.;
	for (int i = 0; i < iNc; i++) {
		for (int n = 0; n < iNc; n++) {
			for (int k = 0; k < iNc; k++) {
				double arrPos0[3] = {
					0.
				}, arrPos1[3] = {
					0.
				}, arrPos[3] = {
					0.
				};

				arrPos1[0] = -valLimX + (double(i)) * valStepX;
				arrPos1[1] = -valLimY + (double(n)) * valStepY;
				arrPos1[2] = -valLimZ + (double(k)) * valStepZ;

				arrPos0[0] = arrPos1[0] + arrAimPoint0[0];
				arrPos0[1] = arrPos1[1] + arrAimPoint0[1];
				arrPos0[2] = arrPos1[2] + arrAimPoint0[2];

				MtrxMultMatrx(arrVPos, 3, 3, arrPos0, 1, arrPos);

				double valNedolet = ScalProduct(arrPos, &arrMiss[3], 3) / Norm3
					(&arrMiss[3]);
				double valMissSq = Norm3(arrPos) * Norm3(arrPos)
					- valNedolet * valNedolet;
				if (valMissSq < 0.) {
					valMissSq = 0.00001;
				}

				double valPCur = plnUZP.LinearValueApprox(sqrt(valMissSq));

				if (valPCur < 0.) {
					valPCur = 0.;
				}
				double temp = valStepX * valStepY * valStepZ * exp
					(-(arrPos1[0] * arrPos1[0] / arrMtrxLambPos[0] / 2. + arrPos1[1] * arrPos1[1]
						/ arrMtrxLambPos[4] / 2. + arrPos1[2] * arrPos1[2] / arrMtrxLambPos[8] / 2.));
				valSum += valPCur * temp;
				*pvalDispMiss += valMissSq * temp;
				*pvalDispNedolet += valNedolet * valNedolet * temp;
			}
		}
	}

	double temp1 = (2. * M_PI * sqrt(2. * M_PI)) * sqrt
		(arrMtrxLambPos[0] * arrMtrxLambPos[4] * arrMtrxLambPos[8]);
	valSum = valSum / temp1;

	*pvalDestruct = valSum;
	*pvalDispMiss = (*pvalDispMiss) / temp1;

	*pvalDispNedolet = *pvalDispNedolet / temp1;

	// double arrCorMtrxCartinSK[4] = {0.}, valDispNedolet = -1.;
	// calcCorrMatrx_CartinPlane(arrCorMtrxCartinSK, &valDispNedolet);
	int iii = 0;
}

// ----------------------------------------------------------------------------

// ---------------------------------------------------------------------------
void TNeighbourhoodAppPoint::calcProbDirectHitting
	(double *pvalDestruct, double *pvalDispMiss) {
	// формирование корреляц матриц по разбросу положения и скорости
	double arrPosK[9] = {
		0.
	}, arrVelocityK[9] = {
		0.
	};
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			arrPosK[3 * i + j] = marrCorMatrxMiss[6 * i + j];
			arrVelocityK[3 * i + j] = marrCorMatrxMiss[6 * (i + 3) + j + 3];
		}
	}
	///

	// arrFVelo,  arrFPos - матрицы собственных векторов
	double arrFPos[9] = {
		0.
	}, arrMtrxLambPos[9] = {
		0.
	}, arrFVelo[9] = {
		0.
	}, arrMtrxLambVelo[9] = {
		0.
	};
	CalcProperVectors_And_Numbers_R3(arrPosK, arrFPos, arrMtrxLambPos);
	CalcProperVectors_And_Numbers_R3(arrVelocityK, arrFVelo, arrMtrxLambVelo);
	///

	// надо будет перевести  координаты и вектор скорости снаряда из КГСК в скоростную СК
	// сформируем матрицу перехода из КГСК в ССК
	double arrMtrxPer_from_KGSK_To_SSK[9] = {
		0.
	};
	calcMatrxPer_from_DecartPrSK_To_SSK(&(mTarget.mTraject.marrVectSostGSK[3]),
		arrMtrxPer_from_KGSK_To_SSK);
	///

	// Вычисление вероятности прямого попадания
	int iNC = 1000;
	int numSuceed = 0;

	// формирование массива указателейц на работающие плоские полигоны
	int iarrNumWorkingPlanePolygons[NumMaxQuantPlanePolygons];
	int iNumWorkingPlanePoligons = 0;
	createPointerArrayForWorkingPlanePoligons(NumMaxQuantPlanePolygons,
		iarrNumWorkingPlanePolygons, &iNumWorkingPlanePoligons);

	*pvalDispMiss = 0.;
	for (int i = 0; i < iNC; i++) {
		// рзигрывание вектора просмаха и относительной скорости в КГСК
		double arrPos_KGSK[3] = {
			0.
		}, arrVelo_KGSK[3] = {
			0.
		};
		getGaussVector_dim3(marrMiss, arrFPos, arrMtrxLambPos, arrPos_KGSK);
		// вектор промаха
		memcpy(arrVelo_KGSK, &marrMiss[3], 3 * sizeof(double));
		// getGaussVector_dim3(&marrMiss[3], arrFVelo , arrMtrxLambVelo, arrVelo_KGSK); // вектор относительной скорости
		///

		// вычисление квадрата промаха  valMissSq
		double temp = ScalProduct(arrPos_KGSK, arrVelo_KGSK, 3) / Norm3
			(arrVelo_KGSK);
		double valMissSq = Norm3(arrPos_KGSK) * Norm3(arrPos_KGSK)
			- temp * temp;
		///

		// суммиование чтобы получить дисперсию
		*pvalDispMiss += valMissSq;
		///

		// пересчет векторов промаха и скорости в скоростную СК
		double arrPos_SSK[3] = {
			0.
		}, arrVelo_SSK[3] = {
			0.
		};
		MtrxMultMatrx(arrMtrxPer_from_KGSK_To_SSK, 3, 3, arrPos_KGSK, 1,
			arrPos_SSK);
		MtrxMultMatrx(arrMtrxPer_from_KGSK_To_SSK, 3, 3, arrVelo_KGSK, 1,
			arrVelo_SSK);
		///

		if (NormVect2(&arrVelo_SSK[1]) < 0.00000000001) {
			// траектория параллельна плоскости
			continue;
		}

		// коррекция точуки прицеливания в цент уязвимой области цели

		///////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////
		if (isDirectHit(iarrNumWorkingPlanePolygons, iNumWorkingPlanePoligons,
				arrPos_SSK, arrVelo_SSK)) {
			numSuceed++;
		}
	}
	*pvalDestruct = ((double)numSuceed) / ((double)iNC);
	*pvalDispMiss = (*pvalDispMiss) / ((double)iNC);
	///
	return;
}
// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
double TNeighbourhoodAppPoint::calcProbDirectHitting__(double *pvalDispMiss) {
	// 2.3 формирование корреляц  матрицы 2х2  в картинной плоскости
	double arrCorMtrxCartinSK[4] = {
		0.
	};
	calcCorrMatrx_CartinPlane(&(marrMiss[3]), marrCorMatrxMiss,
		arrCorMtrxCartinSK);
	// 2.4 вычисление определителя матрицы arrCorMtrxCartinSK
	const double VAlDet = arrCorMtrxCartinSK[0] * arrCorMtrxCartinSK[3]
		- arrCorMtrxCartinSK[1] * arrCorMtrxCartinSK[1];
	///

	// 2.4 формирование обратной матрицы
	double arrCorMtrxCartinSK_Inv[4] = {
		0.
	};
	InverseMtrx2(arrCorMtrxCartinSK, arrCorMtrxCartinSK_Inv);
	///

	// 3. формирование массива указателей на работающие плоские полигоны
	int iarrNumWorkingPlanePolygons[NumMaxQuantPlanePolygons];
	int iNumWorkingPlanePoligons = 0;

	TURPolygon plg = project_Polygons_Upon_CartinPlane
		(iarrNumWorkingPlanePolygons, &iNumWorkingPlanePoligons);
	TURPolygon *pPlgarrProjections = new TURPolygon[iNumWorkingPlanePoligons];
	for (int i = 0; i < iNumWorkingPlanePoligons; i++) {
		pPlgarrProjections[i] = plg.extractSimplePolygon(i);
	}
	// 5. Вычисление интеграла вероятности
	plg.calcBoundBox();
	double val_h = 0.01; // шаг сетки интегрирования
	int iX = (plg.Box[2] - plg.Box[0]) / val_h + 1;
	int iY = (plg.Box[3] - plg.Box[1]) / val_h + 1;
	double valProbRez = 0.;
	for (int i = 0; i < iY; i++) {
		TURPointXY pnt(0., 0.);
		for (int j = 0; j < iX; j++) {
			pnt = TURPointXY(plg.Box[0] - val_h / 2. + ((double)j) * val_h,
				plg.Box[1] - val_h / 2. + ((double)i) * val_h);

			// выяснение принадлежит точка хотя бы одному полигону или нет
			bool brez = false;
			for (int k = 0; k < iNumWorkingPlanePoligons; k++) {

				if (pPlgarrProjections[k].PntInPolygon(pnt) > 0) {
					brez = true;
					break;
				}
			}

			if (!brez) {
				continue;
			}
			// вычисление плотности вероятности в точке pnt
			double arrx[2] = {
				0.
			};
			arrx[0] = pnt.X;
			arrx[1] = pnt.Y;

			valProbRez += exp(-calcYT_D_Y(arrx, arrCorMtrxCartinSK_Inv, 2)
				/ 2.) * val_h * val_h;
		}
	}
	valProbRez = valProbRez / (2. * M_PI * sqrt(VAlDet));
	delete[]pPlgarrProjections;
	// 6. вычисление дисперсии промаха
	*pvalDispMiss = arrCorMtrxCartinSK[0] + arrCorMtrxCartinSK[3];
	return valProbRez;

}

// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
// OUTPUT:
// arrCorMtrxCartinSK[4] - коррел матрица вектора промаха в картинной плоскости
// *pPlgProjection - составной полигон, являющийся проекций полигонов, описывающих геометрию цели, на картинную плоскость
// *pvalDispMiss - СКЗ промаха
// Возвращает вероятнлость прямого попадания
double TNeighbourhoodAppPoint::__calcProbDirectHitting__
	(double *pvalDispMiss, double *arrCorMtrxCartinSK, TURPolygon *pPlgProjection) {
	// 2.3 формирование корреляц  матрицы 2х2  в картинной плоскости
	calcCorrMatrx_CartinPlane(&(marrMiss[3]), marrCorMatrxMiss,
		arrCorMtrxCartinSK);
	// 2.4 вычисление определителя матрицы arrCorMtrxCartinSK
	const double VAlDet = arrCorMtrxCartinSK[0] * arrCorMtrxCartinSK[3]
		- arrCorMtrxCartinSK[1] * arrCorMtrxCartinSK[1];
	///

	// 2.4 формирование обратной матрицы
	double arrCorMtrxCartinSK_Inv[4] = {
		0.
	};
	InverseMtrx2(arrCorMtrxCartinSK, arrCorMtrxCartinSK_Inv);
	///

	// 3. формирование массива указателей на работающие плоские полигоны
	int iarrNumWorkingPlanePolygons[NumMaxQuantPlanePolygons];
	int iNumWorkingPlanePoligons = 0;

	TURPolygon plg = project_Polygons_Upon_CartinPlane   // ЗДЕСЬ ОШИБКА!!!!
		(iarrNumWorkingPlanePolygons, &iNumWorkingPlanePoligons);
	TURPolygon *pPlgarrProjections = new TURPolygon[iNumWorkingPlanePoligons];
	for (int i = 0; i < iNumWorkingPlanePoligons; i++) {
		pPlgarrProjections[i] = plg.extractSimplePolygon(i);
	}
	// 5. Вычисление интеграла вероятности
	plg.calcBoundBox();
	double val_h = 0.05; // шаг сетки интегрирования
	int iX = (plg.Box[2] - plg.Box[0]) / val_h + 1;
	int iY = (plg.Box[3] - plg.Box[1]) / val_h + 1;
	double valProbRez = 0.;
	for (int i = 0; i < iY; i++) {
		TURPointXY pnt(0., 0.);
		for (int j = 0; j < iX; j++) {
			pnt = TURPointXY(plg.Box[0] - val_h / 2. + ((double)j) * val_h,
				plg.Box[1] - val_h / 2. + ((double)i) * val_h);

			// выяснение принадлежит точка хотя бы одному полигону или нет
			bool brez = false;
			for (int k = 0; k < iNumWorkingPlanePoligons; k++) {

				if (pPlgarrProjections[k].PntInPolygon(pnt) > 0) {
					brez = true;
					break;
				}
			}

			if (!brez) {
				continue;
			}
			// вычисление плотности вероятности в точке pnt
			double arrx[2] = {
				0.
			};
			arrx[0] = pnt.X;
			arrx[1] = pnt.Y;

			valProbRez += exp(-calcYT_D_Y(arrx, arrCorMtrxCartinSK_Inv, 2)
				/ 2.) * val_h * val_h;
		}
	}
	valProbRez = valProbRez / (2. * M_PI * sqrt(VAlDet));
	*pPlgProjection = TURPolygon(pPlgarrProjections, iNumWorkingPlanePoligons);
	delete[]pPlgarrProjections;
	// 6. вычисление дисперсии промаха
	*pvalDispMiss = arrCorMtrxCartinSK[0] + arrCorMtrxCartinSK[3];
	return valProbRez;

}

// ---------------------------------------------------------------------------

double TNeighbourhoodAppPoint::max__(const double a, const double b) {
	return(a > b) ? a : b;
}

// ---------------------------------------------------------------------------
void TNeighbourhoodAppPoint::calcProbDirectHitting_SeaTarg
	(double *pvalDestruct, double *pvalDispMiss) {
	// формирование корреляц матриц по разбросу положения и скорости
	double arrPosK[4] = {
		0.
	};
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 2; j++) {
			arrPosK[2 * i + j] = marrCorMatrxMiss[6 * i + j];
		}
	}
	///

	// arrFVelo,  arrFPos - матрицы собственных векторов
	double arrFPos[4] = {
		0.
	}, arrMtrxLambPos[4] = {
		0.
	};
	CalcProperVectors2(arrPosK, arrFPos, arrMtrxLambPos);

	///

	// надо будет перевести  координаты и вектор скорости снаряда из КГСК в скоростную СК
	// сформируем матрицу перехода из КГСК в ССК
	double arrMtrxPer_from_GSK_To_SSK[9] = {
		0.
	};
	calcMatrxPer_from_DecartPrSK_To_SSK(&(mTarget.mTraject.marrVectSostGSK[3]),
		arrMtrxPer_from_GSK_To_SSK);
	///

	// Вычисление вероятности прямого попадания
	int iNC = 1000;
	int numSuceed = 0;

	// формирование массива указателейц на работающие плоские полигоны
	int iarrNumWorkingPlanePolygons[NumMaxQuantPlanePolygons];
	int iNumWorkingPlanePoligons = 0;
	createPointerArrayForWorkingPlanePoligons(NumMaxQuantPlanePolygons,
		iarrNumWorkingPlanePolygons, &iNumWorkingPlanePoligons);

	*pvalDispMiss = 0.;
	for (int i = 0; i < iNC; i++) {
		// рзигрывание вектора просмаха и относительной скорости в ГСК
		double arrPos_GSK[3] = {
			0.
		}, arrVelo_GSK[3] = {
			0.
		};
		getGaussVector(2, marrMiss, arrFPos, arrMtrxLambPos, arrPos_GSK);
		// getGaussVector_dim3(marrMiss, arrFPos, arrMtrxLambPos, arrPos_GSK); // вектор промаха
		memcpy(arrVelo_GSK, &marrMiss[3], 3 * sizeof(double));
		// getGaussVector_dim3(&marrMiss[3], arrFVelo , arrMtrxLambVelo, arrVelo_KGSK); // вектор относительной скорости
		///

		// вычисление квадрата промаха  valMissSq
		double temp = ScalProduct(arrPos_GSK, arrVelo_GSK, 3) / Norm3
			(arrVelo_GSK);
		double valMissSq = Norm3(arrPos_GSK) * Norm3(arrPos_GSK) - temp * temp;
		///

		// суммиование чтобы получить дисперсию
		*pvalDispMiss += valMissSq;
		///

		// пересчет векторов промаха и скорости в скоростную СК
		double arrPos_SSK[3] = {
			0.
		}, arrVelo_SSK[3] = {
			0.
		};
		MtrxMultMatrx(arrMtrxPer_from_GSK_To_SSK, 3, 3, arrPos_GSK, 1,
			arrPos_SSK);
		MtrxMultMatrx(arrMtrxPer_from_GSK_To_SSK, 3, 3, arrVelo_GSK, 1,
			arrVelo_SSK);
		///

		if (NormVect2(&arrVelo_SSK[1]) < 0.00000000001) {
			// траектория параллельна плоскости
			continue;
		}

		///////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////
		///////////////////////////////////////////////////////////////
		if (isDirectHit(iarrNumWorkingPlanePolygons, iNumWorkingPlanePoligons,
				arrPos_SSK, arrVelo_SSK)) {
			numSuceed++;
		}
	}
	*pvalDestruct = ((double)numSuceed) / ((double)iNC);
	*pvalDispMiss = (*pvalDispMiss) / ((double)iNC);
	///
	return;
}

void TNeighbourhoodAppPoint::createPointerArrayForWorkingPlanePoligons
	(const int iNum, int *iarrNumWorkingPlanePolygons, int *iNumWorkingPlanePoligons) {
	if ((mShellBody.mEnumShellType == CALIBRO_30) &&
		((mTarget.menumTargetType == GARPUN_V300) || (mTarget.menumTargetType == GARPUN_V700) ||
			(mTarget.menumTargetType == GARPUN_V1000))) {
		if (mDistAppPoint > 7500.) {
			*iNumWorkingPlanePoligons = 9;
			for (int i = 0; i < 9; i++) {
				iarrNumWorkingPlanePolygons[i] = i;
			}
			return;
		}
		///

		if ((mDistAppPoint <= 7500.) && (mDistAppPoint > 3500.)) {
			*iNumWorkingPlanePoligons = 8;
			for (int i = 0; i < 4; i++) {
				iarrNumWorkingPlanePolygons[i] = i;
			}

			iarrNumWorkingPlanePolygons[4] = 5;
			iarrNumWorkingPlanePolygons[5] = 6;
			iarrNumWorkingPlanePolygons[6] = 7;
			iarrNumWorkingPlanePolygons[7] = 8;
			return;
		}

		if ((mDistAppPoint <= 3500.) && (mDistAppPoint > 2500.)) {
			*iNumWorkingPlanePoligons = 5;
			for (int i = 0; i < 4; i++) {
				iarrNumWorkingPlanePolygons[i] = i;
			}

			iarrNumWorkingPlanePolygons[4] = 5;
			return;
		}

		if ((mDistAppPoint <= 2500.) && (mDistAppPoint > 600.)) {
			*iNumWorkingPlanePoligons = 2;
			for (int i = 0; i < 2; i++) {
				iarrNumWorkingPlanePolygons[i] = i;
			}
			return;
		}
	}

	if ((mShellBody.mEnumShellType != CALIBRO_30) &&
		((mTarget.menumTargetType == GARPUN_V300) || (mTarget.menumTargetType == GARPUN_V700) ||
			(mTarget.menumTargetType == GARPUN_V1000))) {
		// *iNumWorkingPlanePoligons = 2;
		// iarrNumWorkingPlanePolygons[0] = 12;
		// iarrNumWorkingPlanePolygons[1] = 13;
		*iNumWorkingPlanePoligons = 14;
		for (int i = 0; i < (*iNumWorkingPlanePoligons); i++) {
			iarrNumWorkingPlanePolygons[i] = i;
		}

		return;

		return;
		if (mDistAppPoint > 7500.) {
			*iNumWorkingPlanePoligons = 10;
			for (int i = 0; i < 10; i++) {
				iarrNumWorkingPlanePolygons[i] = i;
			}

			return;
		}
		///

		if ((mDistAppPoint <= 7500.) && (mDistAppPoint > 3500.)) {
			*iNumWorkingPlanePoligons = 9;
			for (int i = 0; i < 4; i++) {
				iarrNumWorkingPlanePolygons[i] = i;
			}

			iarrNumWorkingPlanePolygons[4] = 5;
			iarrNumWorkingPlanePolygons[5] = 6;
			iarrNumWorkingPlanePolygons[6] = 7;
			iarrNumWorkingPlanePolygons[7] = 8;
			iarrNumWorkingPlanePolygons[8] = 9;
			return;
		}

		if ((mDistAppPoint <= 3500.) && (mDistAppPoint > 2500.)) {
			*iNumWorkingPlanePoligons = 6;
			for (int i = 0; i < 4; i++) {
				iarrNumWorkingPlanePolygons[i] = i;
			}

			iarrNumWorkingPlanePolygons[4] = 5;
			iarrNumWorkingPlanePolygons[5] = 9;
			return;
		}

		if ((mDistAppPoint <= 2500.) && (mDistAppPoint > 600.)) {
			*iNumWorkingPlanePoligons = 3;
			for (int i = 0; i < 2; i++) {
				iarrNumWorkingPlanePolygons[i] = i;
			}
			iarrNumWorkingPlanePolygons[2] = 9;
			return;
		}
	}

	// для всех остальных целей
	*iNumWorkingPlanePoligons = mTarget.mLenArrPlanePolygon;
	for (int i = 0; i < mTarget.mLenArrPlanePolygon; i++) {
		iarrNumWorkingPlanePolygons[i] = i;
	}
	return;
}

// ---------------------------------------------------------------------------------------------------------------
// вычисление факта прямого попадания в один из полигонов, описывающих
// геометрию цели
// arrPos, arrVelo - векторы промаха и относительной скорости
// iarrNumWorkingPlanePolygons[iNumWorkingPlanePoligons] - массив номеров рабочих полигонов
//
bool TNeighbourhoodAppPoint::isDirectHit(int *iarrNumWorkingPlanePolygons,
	int iNumWorkingPlanePoligons, double *arrPos, double *arrVelo) {
	for (int i = 0; i < iNumWorkingPlanePoligons; i++) {
		if (mTarget.mpArrPlanePolygon[iarrNumWorkingPlanePolygons[i]]
			.isLineIntersectPlanePolygon(arrPos, arrVelo)) {
			return true;
		}

	}
	return false;
}

// -------------------------------------------------------------------------

// parrAimingPoints_X [mQuantShells]-  массив различных точек прицеливания по оси X
// piarrRepeatQuants_X [mQuantShells] - массив повторений точек прицеливания по оси X
// *pQuantAimingPoints_X- к- во различных точек прицеливания по оси X
// parrAimingPoints_Y [mQuantShells]-  массив различных точек прицеливания по оси Y
// piarrRepeatQuants_Y [mQuantShells] - массив повторений точек прицеливания по оси Y
// *pQuantAimingPoints_Y - к- во различных точек прицеливания по сои Y

void TNeighbourhoodAppPoint::calcDestructionProb_For_CoastTargs
	(const int QAantIspit, const int QUantShells, const double VAlKillingRange,
	double *pvalProb, enumTypeOfControlAlgorithm EnumTypeOfControlAlgorithm,
	TURPointXY *ppntArrAimingPoints, int *piarrRepeatAimingPoints, int* piQuantAimingPoints)

{
	// 1. Формирование матрицы эллипса рассеяния точки падения в плоскости OXY ГСК
	double arrElK[4] = {
		0.
	};
	arrElK[0] = marrCorMatrxMiss[0];
	arrElK[1] = marrCorMatrxMiss[1];
	arrElK[2] = arrElK[1];
	arrElK[3] = marrCorMatrxMiss[7];
	///

	// 3. Формирование растра цели   по полигону
	double cs = 0.5; // размер ячейки
	// вычисление угла поворота (ориентации) цели в ГСК
	// считается от оси X положительное напргоавление против часовой стрелки
	double valRotateAng = atan2(mTarget.mTraject.marrVectSostGSK_Begin[4],
		mTarget.mTraject.marrVectSostGSK_Begin[3]);
	///
	// поворот полигона цели на угол  valRotateAng
	const TURPointXY pntSdvig(0., 0.);
	const double valRastigenie = 1.;
	TURPolygon plgTargGSK = mTarget.mpArrPlanePolygon[0].mPolygon.LinTransform
		(valRotateAng, pntSdvig, valRastigenie);
	// plgTargGSK.WriteSetSHPFiles(L"E:\\Ametist\\22-02-2018\\New\\plgTargGSK.shp", &plgTargGSK,1);
	// plgTargGSK.WriteSetSHPFiles(L"E:\\Ametist\\22-02-2018\\New\\plgTargSkSK.shp", &(mTarget.mpArrPlanePolygon[0].mPolygon),1);
	///

	TYrRastr rastrTargGSK_Game(mTarget.mpArrPlanePolygon[0].mPolygon, 17., 1.);
	// для игровой задачи
	// plgTarg0.WriteSetSHPFiles(L"E:\\PROJECTS_C++\\TARAN\\New\\plgTarg0.shp", &plgTarg0,1);

	// arrF - матрица собственных векторов
	// для отладки УБРАТЬ!!!!!
	// arrElK[3] = 129* 129. +93.2 * 93.2;
	// arrElK[1] = 0.;
	// arrElK[2] = 0.;
	// arrElK[0] = 24.6 * 24.6 + 46.3 * 46.3;
	/// СВЕРХУ УБРАТЬ!!!!!
	double arrF[4] = {
		0.
	}, arrMtrxLamb[4] = {
		0.
	};
	CalcProperVectors2(arrElK, arrF, arrMtrxLamb);
	///

	// матрица перехода из OXY ГСК в СкСК цели
	double arrMtrxPer[4] = {
		0.
	};
	arrMtrxPer[0] = cos(valRotateAng);
	arrMtrxPer[3] = arrMtrxPer[0];
	arrMtrxPer[1] = sin(valRotateAng);
	arrMtrxPer[2] = -arrMtrxPer[1];
	///

	// перевод корреляц матрицы рассеяния в СкСК
	double arrElK_SkSK[4] = {
		0.
	}, arrT0[4] = {
		0.
	};
	MtrxMultMatrx(arrMtrxPer, 2, 2, arrElK, 2, arrT0);
	MtrxMultMatrxTransp(arrT0, 2, 2, arrMtrxPer, 2, arrElK_SkSK);

	// вычислене массива  векторов, корректирующих точки прицеливания
	// const int In = 101;   //  In  - к-во узловых точек прицеливания
	// const int Im = 101;  	// Im  - к-во контрольных точек цели на оси X (к-во точек на сетке)

	// для отладки УБРАТЬ!!!!!
	// arrElK_SkSK[3] = 129* 129. +93.2 * 93.2;
	// arrElK_SkSK[1] = 0.;
	// arrElK_SkSK[2] = 0.;
	// arrElK_SkSK[0] = 24.6 * 24.6 + 46.3 * 46.3;
	/// СВЕРХУ УБРАТЬ!!!!!

	if (EnumTypeOfControlAlgorithm == OPTIMAL) {
		// calcAimingPoints_For_OpenManPower(arrElK_SkSK, VAlKillingRange, QUantShells,  In,  Im
		// ,parrAimingPoints_X, piarrRepeatQuants_X, piQuantAimingPoints_X
		// , parrAimingPoints_Y, piarrRepeatQuants_Y, piQuantAimingPoints_Y, ppntArrCorrecting) ;
	}

	if (EnumTypeOfControlAlgorithm == STANDART) {
		TCoastTargNeighbourhood::calcAimingPoints_For_OpenManPower_MUS
			(arrElK, VAlKillingRange, QUantShells, mTarget.mpArrPlanePolygon[0].mPolygon,
			mDistAppPoint, ppntArrAimingPoints, piarrRepeatAimingPoints,
			piQuantAimingPoints);
	}

	// ppntArrCorrecting[0].WriteSetSHPFiles(L"E:\\Ametist\\22-02-2018\\NEW\\ppntArrCorrecting_SkSK.shp", ppntArrCorrecting,QUantShells);
	// закон коррекции - массив точек прицеливания для каждого выстрела
	// перевод   точек прицеливания из СкСК в ГСК
	for (int i = 0; i < (*piQuantAimingPoints); i++) {
		ppntArrAimingPoints[i] = ppntArrAimingPoints[i].LinTransform
			(valRotateAng, pntSdvig, valRastigenie);
	}
	// ppntArrCorrecting[0].WriteSetSHPFiles(L"E:\\Ametist\\22-02-2018\\NEW\\ppntArrCorrecting_GSK.shp", ppntArrCorrecting,QUantShells);
	// fncMilitaryPlannerForCoastTarg( parrAimingPoints_X, piarrRepeatQuants_X, *pQuantAimingPoints_X
	// , parrAimingPoints_Y, piarrRepeatQuants_Y, *pQuantAimingPoints_Y, ppntArrCorrecting) ;
	///
	TYrRastr rastrTargGSK(plgTargGSK, cs, 0.);
	plgTargGSK.calcBoundBox();
	double valProbSum = 0;
	int iQuantValuePiksels = rastrTargGSK.calcQuantValuablePiksels();
	// rastrTargGSK.WriteMeAsFltFile(L"E:\\Ametist\\22-02-2018\\New\\rastrTargGSK.flt");
	for (int i = 0; i < QAantIspit; i++) {
		TYrRastr rastrTargCur = rastrTargGSK;

		// rastrTarg.WriteMeAsFltFile(L"E:\\PROJECTS_C++\\TARAN\\New\\rastrTarg.flt"); //!!!!!
		// ppntArrCorrecting[0].WriteSetSHPFiles(L"E:\\PROJECTS_C++\\TARAN\\New\\ppntArrCorrecting.shp", ppntArrCorrecting,QUantShells);
		// plgTarg0.WriteSetSHPFiles(L"E:\\PROJECTS_C++\\TARAN\\New\\plgTarg01.shp", &plgTarg0,1); //!!!!!

		for (int j = 0; j < (*piQuantAimingPoints); j++) {
			double arrCorrecting[2] = {
				0.
			};
			arrCorrecting[0] = ppntArrAimingPoints[j].X;
			arrCorrecting[1] = ppntArrAimingPoints[j].Y;

			for (int k = 0; k < piarrRepeatAimingPoints[j]; k++) {
				// рзигрывание вектора просмаха и относительной скорости в КГСК
				double arrPos_GSK[2] = {
					0.
				};

				getGaussVector(2, arrCorrecting, arrF, arrMtrxLamb, arrPos_GSK);
				if ((arrPos_GSK[0] > (plgTargGSK.Box[2] + VAlKillingRange)) ||
					(arrPos_GSK[0] < (plgTargGSK.Box[0] - VAlKillingRange)) ||
					(arrPos_GSK[1] > (plgTargGSK.Box[3] + VAlKillingRange)) || (arrPos_GSK[1] <
						(plgTargGSK.Box[1] - VAlKillingRange))) {
					continue;
				}
				TURPointXY pntFall(arrPos_GSK[0], arrPos_GSK[1]);
				// точка падения
				// pntFall.WriteSetSHPFiles(L"E:\\Ametist\\22-02-2018\\NEW\\pntFallCur.shp", &pntFall,1);
				// pntFall.WriteSetSHPFiles(L"E:\\Ametist\\22-02-2018\\NEW\\pntAimCur.shp", &ppntArrCorrecting[j],1);

				// функция меняющая значения растра

				rastrTargCur.applyKillingRange(pntFall, VAlKillingRange);
				// rastrTargCur.WriteMeAsFltFile(L"E:\\Ametist\\22-02-2018\\New\\rastrTargCur.flt"); //!!!!!
				int iii = 0;
			}

		}
		double valSum = 0.;

		for (int n = 0; n < rastrTargGSK.ncols * rastrTargGSK.nrows; n++) {
			if (rastrTargCur.pflt_rastr[n] > 0.001) {
				valSum += 1.;
			}
		}
		double valPTemp = valSum / ((double)iQuantValuePiksels);
		valProbSum += valPTemp;

		// rastrTargCur.WriteMeAsFltFile(L"E:\\Ametist\\22-02-2018\\COAST_1D\\plgTarg0.flt"); //!!!!!
	}
	*pvalProb = valProbSum / ((double)QAantIspit);
}

// -----------------------------------------------------------------------------------
// вычисление массива точек прицеливания  для каждого вастрела
// INPUT:
// arrElK[4] - корреляционная матрица разбросов точки падения
// VAlKillingRange  - радиус поражения
// QUantShells  - к-во выстрелов
// OUTPUT:
// parrAimingPoints [QUantShells]-  массив различных точек прицеливания по оси X
// piarrRepeatQuants [QUantShells] - массив повторений точек прицеливания по оси X
// *pQuantAimingPoints - к- во различных точек прицеливания по оси X
// parrAimingPoints [QUantShells]-  массив различных точек прицеливания по оси Y
// piarrRepeatQuants [QUantShells] - массив повторений точек прицеливания по оси Y
// *pQuantAimingPoints - к- во различных точек прицеливания по сои Y
// In  - к-во узловых точек прицеливания
// Im  - к-во контрольных точек цели на оси X (к-во точек на сетке)
void TNeighbourhoodAppPoint::calcAimingPoints_For_OpenManPower
	(double *arrElK, const double VAlKillingRange, const int QUantShells, const int In,
	const int Im, double *parrAimingPoints_X, int *piarrRepeatQuants_X,
	int *piQuantAimingPoints_X, double *parrAimingPoints_Y, int *piarrRepeatQuants_Y,
	int *piQuantAimingPoints_Y, TURPointXY * ppntArrCorrecting)

{

	if (!((mTarget.menumTargetType == OPEN_MANPOWER_LIE) ||
			(mTarget.menumTargetType == OPEN_MANPOWER_STAND) ||
			(mTarget.menumTargetType == BULLET_PROOF_LIE) || (mTarget.menumTargetType == BULLET_PROOF_STAND))) {
		return;
	}

	memset(parrAimingPoints_X, 0, QUantShells*sizeof(double));
	memset(piarrRepeatQuants_X, 0, QUantShells*sizeof(int));

	memset(parrAimingPoints_Y, 0, QUantShells*sizeof(double));
	memset(piarrRepeatQuants_Y, 0, QUantShells*sizeof(int));
	///
	mTarget.mpArrPlanePolygon[0].mPolygon.calcBoundBox();
	// вычисление массива узловых точек по оси X
	double valL = mTarget.mpArrPlanePolygon[0].mPolygon.Box[2]
		- mTarget.mpArrPlanePolygon[0].mPolygon.Box[0];
	double valSig = sqrt(arrElK[0]);

	calcArray_Of_AimPoints(valL, valSig, VAlKillingRange, QUantShells, In, Im,
		parrAimingPoints_X, piarrRepeatQuants_X, piQuantAimingPoints_X);

	// вычисление массива узловых точек по оси Y
	valL = mTarget.mpArrPlanePolygon[0].mPolygon.Box[3]
		- mTarget.mpArrPlanePolygon[0].mPolygon.Box[1];
	valSig = sqrt(arrElK[3]);

	calcArray_Of_AimPoints(valL, valSig, VAlKillingRange, QUantShells, In, Im,
		parrAimingPoints_Y, piarrRepeatQuants_Y, piQuantAimingPoints_Y);
	fncMilitaryPlannerForCoastTarg(parrAimingPoints_X, piarrRepeatQuants_X,
		*piQuantAimingPoints_X, parrAimingPoints_Y, piarrRepeatQuants_Y,
		*piQuantAimingPoints_Y, ppntArrCorrecting);

}

// ----------------------------------------------------------------------------------------------
// -----------------------------------------------------------------------------------
// вычисление массива точек прицеливания  для каждого вастрела
// INPUT:
// arrElK[4] - корреляционная матрица разбросов точки падения
// VAlKillingRange  - радиус поражения
// QUantShells  - к-во выстрелов
// OUTPUT:
// parrAimingPoints [QUantShells]-  массив различных точек прицеливания по оси X
// piarrRepeatQuants [QUantShells] - массив повторений точек прицеливания по оси X
// *pQuantAimingPoints - к- во различных точек прицеливания по оси X
// parrAimingPoints [QUantShells]-  массив различных точек прицеливания по оси Y
// piarrRepeatQuants [QUantShells] - массив повторений точек прицеливания по оси Y
// *pQuantAimingPoints - к- во различных точек прицеливания по сои Y
// In  - к-во узловых точек прицеливания
// Im  - к-во контрольных точек цели на оси X (к-во точек на сетке)
void TNeighbourhoodAppPoint::calcAimingPoints_For_OpenManPower_2D
	(double *arrElK, const double VAlKillingRange, const int QUantShells,
	TURPolygon plgTarg, TURPointXY *ppntArrAimingPoints, int *piarrRepeatAimingPoints,
	int *piQuantAimingPoints) {

	// if ( !( (mTarget.menumTargetType ==  OPEN_MANPOWER_LIE)
	// ||(mTarget.menumTargetType ==  OPEN_MANPOWER_STAND)
	// ||(mTarget.menumTargetType ==  BULLET_PROOF_LIE)
	// ||(mTarget.menumTargetType ==  BULLET_PROOF_STAND)
	// )
	// )
	// {
	// return;
	// }
	TYrRastr rastrTargGSK_Game(plgTarg, 17., 1.); // для игровой задачи
	int INum = rastrTargGSK_Game.calcQuantValuablePiksels();

	// формирование матрицы игры
	double *parr_C = new double[INum * INum];
	const double VAlStepIntegr = VAlKillingRange / 10.;
	int icol = 0, irow = 0;
	for (int i = 0; i < rastrTargGSK_Game.ncols * (rastrTargGSK_Game).nrows;
		i++) {
		if (rastrTargGSK_Game.getValue(i) < 0.5) {
			continue;
		}
		TURPointXY pnt0 = rastrTargGSK_Game.getCellCentre(i);
		icol = 0;
		for (int j = 0; j < rastrTargGSK_Game.ncols * (rastrTargGSK_Game)
			.nrows; j++) {
			TURPointXY pnt1 = rastrTargGSK_Game.getCellCentre(j);
			if (rastrTargGSK_Game.getValue(j) < 0.5) {
				continue;
			}
			TURPointXY pntDif(pnt1.X - pnt0.X, pnt1.Y - pnt0.Y);
			double valp = TProbabilityTheory::calcIntegralNormalDensity_2D
				(pntDif.X, pntDif.Y, arrElK, VAlKillingRange, VAlStepIntegr);

			parr_C[irow * INum + icol] = -log(1. - valp);
			icol++;
		}
		irow++;
	}

	///

	double fval = -1.;
	double *parr_freq = new double[INum];
	memset(parr_freq, 0, sizeof(double) * INum);
	TGameTheory::solvMartrxGame(parr_C, INum, INum, parr_freq, NULL, fval);

	int *piarr_q = new int[INum]; // к-во повторений точки прицелив с номером i
	double *parr_z = new double[INum];
	int iSum = 0;
	for (int i = 0; i < INum; i++) {
		piarr_q[i] = QUantShells * parr_freq[i];
		iSum += piarr_q[i];
		parr_z[i] = ((double)QUantShells) * parr_freq[i] - piarr_q[i];
	}
	///

	int iJ = QUantShells - iSum;
	for (int i = 0; i < iJ; i++) {
		int j = -1;
		MaxDoubleArray(parr_z, INum, &j);
		piarr_q[j]++;
		parr_z[j] = -1.;
	}
	///

	int icur = 0;
	// TURPointXY *pPntArrTemp = new TURPointXY[QUantShells];
	// int *piarrRepeatQuants = new int [QUantShells];
	for (int i = 0; i < INum; i++) {
		if (piarr_q[i] > 0) {
			piarrRepeatAimingPoints[icur] = piarr_q[i];
			int iOrderNum = rastrTargGSK_Game.getOrderNum(i);
			ppntArrAimingPoints[icur] = rastrTargGSK_Game.getCellCentre
				(iOrderNum); ;
			icur++;

		}
	}
	*piQuantAimingPoints = icur;
	// *pQuantAimingPoints = icur;
	// ддля проверки
	int isum = 0;
	for (int i = 0; i < icur; i++) {
		isum += piarrRepeatAimingPoints[i];
	}

	///
	// int itemp = 0;
	// for (int i = 0; i < icur; i++)
	// {
	// for (int j = 0; j < piarrRepeatQuants[i]; j++)
	// {
	// ppntArrCorrecting[itemp] = 	pPntArrTemp [i];
	// itemp++;
	// }
	// }

	// delete []pPntArrTemp;
	// delete piarrRepeatQuants;
	delete[]parr_z;
	delete[]piarr_q;

	delete[]parr_freq;
	delete[]parr_C;
	// delete parrx;
	// delete parry;

}
// ----------------------------------------------------------------------------------------------

// ----------------------------------------------------------------------------------------------
// ВЫчисление массива оптимальных точек прицеливания по одной оси
// Задана цель в виде отрезка оси OX общей длиной L
// НА отрезке выбрана сетка Im точек равноотстоящих друг от друга
// На отрезке выбрана равномерная сетка из In равноотстоящих друг от друга точек прицеливания
// INPUT:
// VAlL - длина отрезка цели
// VAlSig - СКЗ точки падения
// VAlKillingRange - радиус поражения
// QUantShells  - к-во выстрелов
// In  - к-во узловых точек прицеливания
// Im  - к-во контрольных точек цели на оси X
// OUTPUT:
// parrAimingPoints -  массив различных точек прицеливания
// piarrRepeatQuants - массив повторений точек прицеливания
// *pQuantAimingPoints - к- во различных точек прицеливания
void TNeighbourhoodAppPoint::calcArray_Of_AimPoints
	(const double VAlL, const double VAlSig, const double VAlKillingRange, const int QUantShells,
	const int In, const int Im, double *parrAimingPoints, int *piarrRepeatQuants,
	int *pQuantAimingPoints) {
	// точкуи цели на оси Х
	double *parrx = new double[Im];
	memset(parrx, 0, Im*sizeof(double));
	for (int i = 0; i < Im; i++) {
		parrx[i] = -VAlL / 2. + ((double)i) * VAlL / ((double)Im - 1.);
	}

	// прицельные точки
	double *parry = new double[In];
	memset(parry, 0, In*sizeof(double));
	for (int i = 0; i < In; i++) {
		parry[i] = -VAlL / 2. + ((double)i) * VAlL / ((double)In - 1.);
	}
	///

	// формирование матрицы игры
	double *parr_C = new double[In * Im];
	const double VAlStepIntegr = VAlKillingRange / 10.;
	for (int i = 0; i < In; i++) {
		for (int j = 0; j < Im; j++) {
			double valp = TProbabilityTheory::calcIntegralNormalDensity
				(parry[i], VAlSig, parrx[j] - VAlKillingRange, parrx[j] + VAlKillingRange,
				VAlStepIntegr);

			parr_C[i * Im + j] = -log(1. - valp);
		}
	}
	///

	double fval = -1.;
	double *parr_freq = new double[In];
	memset(parr_freq, 0, sizeof(double) * In);
	TGameTheory::solvMartrxGame(parr_C, In, Im, parr_freq, NULL, fval);

	int *piarr_q = new int[In]; // к-во повторений точки прицелив с номером i
	double *parr_z = new double[In];
	int iSum = 0;
	for (int i = 0; i < In; i++) {
		piarr_q[i] = QUantShells * parr_freq[i];
		iSum += piarr_q[i];
		parr_z[i] = ((double)QUantShells) * parr_freq[i] - piarr_q[i];
	}
	///

	int iJ = QUantShells - iSum;
	for (int i = 0; i < iJ; i++) {
		int j = -1;
		MaxDoubleArray(parr_z, In, &j);
		piarr_q[j]++;
		parr_z[j] = -1.;
	}
	///
	/* int itemp = 0;
	for (int i = 0; i < In; i++)
	{
	for (int j = 0; j < piarr_q[i]; j++)
	{
	parr_a [itemp] =  parry[i];
	itemp++;
	}
	} */
	*pQuantAimingPoints = 0;
	int icur = 0;
	for (int i = 0; i < In; i++) {
		if (piarr_q[i] > 0) {
			piarrRepeatQuants[icur] = piarr_q[i];
			parrAimingPoints[icur] = parry[i];
			icur++;

		}
	}
	*pQuantAimingPoints = icur;

	delete[]parr_z;
	delete[]piarr_q;
	delete[]parr_freq;
	delete[]parr_C;
	delete[]parrx;
	delete[]parry;
}

// ----------------------------------------------------------------------------------------------
// ВЫчисление массива оптимальных   (по  миимаксному  критерию)  точек прицеливания по одной оси для групповой точечной цели
// расположенной на одной прямой OX
// Задана цель в виде набора точек на оси  OX

// На отрезке выбрана равномерная сетка из In равноотстоящих друг от друга точек прицеливания
// INPUT:

// VAlSig - СКЗ точки падения
// VAlKillingRange - радиус поражения
// QUantShells  - к-во выстрелов
// In  - к-во узловых точек прицеливания
// parrx[LEnarrX] - точки цели
// OUTPUT:
// parrAimingPoints -  массив различных точек прицеливания
// piarrRepeatQuants - массив повторений точек прицеливания
// *pQuantAimingPoints - к- во различных точек прицеливания
void TNeighbourhoodAppPoint::calcArray_Of_AimPoints_ForGroupLinedPointTargs
	(double *arrElK, const double VAlKillingRange, const int QUantShells,
	const int In, double *parrx, const int LEnarrX, double *parrAimingPoints,
	int *piarrRepeatQuants, int *pQuantAimingPoints)

{
	int iNumArgMin = -1;
	double valMinX = MinDoubleArray(parrx, LEnarrX, &iNumArgMin);

	double valMalX = MaxDoubleArray(parrx, LEnarrX, &iNumArgMin);
	const double VAlL = valMalX - valMinX;
	// прицельные точки
	double *parry = new double[In];
	memset(parry, 0, In*sizeof(double));
	for (int i = 0; i < In; i++) {
		parry[i] = valMinX + ((double)i) * VAlL / ((double)In - 1.);
	}
	///

	// формирование матрицы игры
	double *parr_C = new double[In * LEnarrX];
	const double VAlStepIntegr = VAlKillingRange / 10.;
	for (int i = 0; i < In; i++) {
		for (int j = 0; j < LEnarrX; j++) {
			// double valp = TProbabilityTheory::calcIntegralNormalDensity(parry[i], VAlSig, parrx[j] - VAlKillingRange
			// , parrx[j] + VAlKillingRange, VAlStepIntegr);
			double valp = TProbabilityTheory::calcIntegralNormalDensity_2D
				(parrx[j] - parry[i], 0., arrElK, VAlKillingRange, VAlStepIntegr);
			parr_C[i * LEnarrX + j] = -log(1. - valp);
		}
	}
	///

	double fval = -1.;
	double *parr_freq = new double[In];
	memset(parr_freq, 0, sizeof(double) * In);
	TGameTheory::solvMartrxGame(parr_C, In, LEnarrX, parr_freq, NULL, fval);

	int *piarr_q = new int[In]; // к-во повторений точки прицелив с номером i
	double *parr_z = new double[In];
	int iSum = 0;
	for (int i = 0; i < In; i++) {
		piarr_q[i] = QUantShells * parr_freq[i];
		iSum += piarr_q[i];
		parr_z[i] = ((double)QUantShells) * parr_freq[i] - piarr_q[i];
	}
	///

	int iJ = QUantShells - iSum;
	for (int i = 0; i < iJ; i++) {
		int j = -1;
		MaxDoubleArray(parr_z, In, &j);
		piarr_q[j]++;
		parr_z[j] = -1.;
	}
	///
	/* int itemp = 0;
	for (int i = 0; i < In; i++)
	{
	for (int j = 0; j < piarr_q[i]; j++)
	{
	parr_a [itemp] =  parry[i];
	itemp++;
	}
	} */
	*pQuantAimingPoints = 0;
	int icur = 0;
	for (int i = 0; i < In; i++) {
		if (piarr_q[i] > 0) {
			piarrRepeatQuants[icur] = piarr_q[i];
			parrAimingPoints[icur] = parry[i];
			icur++;

		}
	}
	*pQuantAimingPoints = icur;

	delete[]parr_z;
	delete[]piarr_q;
	delete[]parr_freq;
	delete[]parr_C;
	delete[]parrx;
	delete[]parry;
}

// -----------------------------------------------------------------------------------
// вычисление  результирующей вероятности поражения морской цели
// INPUT:
// TARgetType
// SHEllType
// DETonatorType
// QUantShells
// VAlProb0
// OUTPUT:
// вероятность поражения
double TNeighbourhoodAppPoint::calcRezultProbForSeaTarg
	(const int QUantShells, const double VAlProb0)
 {

	double valProb = 0.;
	double valQuantNesessaryHits = 0.;
	if (mShellBody.mEnumShellType == CALIBRO_100)
	{
	  switch(mTarget.menumTargetType)
	  {
			case DESTROYER:
				valQuantNesessaryHits = VAlQuantNesessaryHits_Destr_Calibro_100;
				break;

			case MOTORBOAT:
				valQuantNesessaryHits =
					VAlQuantNesessaryHits_Cutter_Calibro_100;
				break;

			default:
			break;
	   }

	   valProb = calcRezultProbSeaTargSkaliga(QUantShells, VAlProb0,
							valQuantNesessaryHits);
		return valProb;
	}


	TTable_2D TableUZP;
	if (mShellBody.mEnumShellType == CALIBRO_SHTAT_130)
	{

	  switch (mShellBody.mDetonator.mEnumDetonatorType)
	  {
	  case D4MRM:
			switch(mTarget.menumTargetType)
			{
			case DESTROYER:
			valQuantNesessaryHits = VAlQuantNesessaryHits_Destr_CALIBRO_SHTAT_130;
			break;

			case MOTORBOAT:
			valQuantNesessaryHits =
				VAlQuantNesessaryHits_Cutter_CALIBRO_SHTAT_130 ;
			break;

			default:
			break;
			}

			valProb = calcRezultProbSeaTargSkaliga(QUantShells, VAlProb0,
						valQuantNesessaryHits);
			return valProb;
	  break;

	  case MFIVU:
		TableUZP = createTblUZP_130CAL_MFIVU_SEATARG();
		valProb = calcRezultProbSeaTarg_MFIVU
			(QUantShells, VAlProb0, TableUZP);
		return valProb;
	  break;
	  default:
	  break   ;
	  }

	}

	if (mShellBody.mEnumShellType == CALIBRO_TARAN_130)
	{

	  switch (mShellBody.mDetonator.mEnumDetonatorType)
	  {
	  case D4MRM:

			switch (mTarget.menumTargetType)
			{
			case DESTROYER:
			valQuantNesessaryHits = VAlQuantNesessaryHits_Destr_CALIBRO_SHTAT_130;
			break;

			case MOTORBOAT:
			valQuantNesessaryHits =
				VAlQuantNesessaryHits_Cutter_CALIBRO_SHTAT_130 ;
			break;

			default:
			break;
			}

			valProb = calcRezultProbSeaTargSkaliga(QUantShells, VAlProb0,
						valQuantNesessaryHits);
			return valProb;
	  break;

	  case MFIVU:
		TableUZP = createTblUZP_130CAL_MFIVU_SEATARG();
		valProb = calcRezultProbSeaTarg_MFIVU
			(QUantShells, VAlProb0, TableUZP);
		return valProb;

	  break;
	  default:
	  break   ;
	  }

	}

}

double TNeighbourhoodAppPoint::calcRezultProbSeaTarg_MFIVU
	(const int QUantShells, const double VAlProb0, TTable_2D TableUZP) {

	double valPSum = 0.;
	for (int i = 0; i < QUantShells; i++) {

		double valPCur = TProbabilityTheory::calcBinomSuccessProbability
			(VAlProb0, QUantShells, i + 1);
	   /*	if (i > TableUZP.mNumCols)
		{
			valPSum += valPCur;
		}
		else
		{
			valPSum += valPCur * TableUZP.calcValue
				(mDistAppPoint, ((double)(i + 1.)));
		} */
		double  valUZP = TableUZP.calcValue	(mDistAppPoint, ((double)(i + 1.)));
		valPSum += valPCur * valUZP;

	}
	return valPSum;
}

double TNeighbourhoodAppPoint::calcRezultProbSeaTargSkaliga
	(const int QUantShells, const double VAlProb0, const double VAlQuantNesessaryHits) {
	double valPSum = TProbabilityTheory::calcBinomSuccessProbability
		(VAlProb0, QUantShells, 0);
	double valPRez = 0.;
	const int Num = VAlQuantNesessaryHits;
	double valTemp = 1. - 1. / VAlQuantNesessaryHits;
	for (int i = 0; i < Num; i++) {
		// вероятность того, что из   QUantShells испытаний будет (i+1) успешное
		double valPCur = TProbabilityTheory::calcBinomSuccessProbability
			(VAlProb0, QUantShells, i + 1);
		valPSum += valPCur;
		valPRez += valPCur * (1. - pow(valTemp, ((double)(i + 1))));

	}
	valPRez += (1. - valPSum);
	return valPRez;
}

// ---------------------------------------------------------------------------
// новый общий интерфейс функции вычисления  31.01.2018
void TNeighbourhoodAppPoint::calcDestructionProb_For_AirTargs
	(double *pvalDestruct, double *pvalDispMiss, double *arrCorMtrxCartinSK,
	double *pvalDispNedolet, TURPolygon *pPlgProjection) {
	*pvalDispNedolet = 0.;
	if (((mShellBody.mEnumShellType == CALIBRO_SHTAT_130) ||
			(mShellBody.mEnumShellType == CALIBRO_TARAN_130)) &&
		(mShellBody.mDetonator.mEnumDetonatorType == MFIVU)) {
		TTable_3D TableUZP;
		if (!createTblUzp_For_130Cal_and_MFIVU(TableUZP)) {
			*pvalDestruct = 0.;
		}

		calcProb_TableUZP_MFIVU(TableUZP, pvalDestruct, pvalDispMiss);

	}

	if ((mTarget.menumTargetType == JET_F16) &&
		(mShellBody.mEnumShellType == CALIBRO_SHTAT_130) && (mShellBody.mDetonator.mEnumDetonatorType == AR32A))
		 {
		double valR = 12., valProbMean = 0.21; ;

		calcProbSkaligaPlaneLaw_New(valR, valProbMean, pvalDestruct,
			pvalDispMiss);
		return;
		}

	if ((mTarget.menumTargetType == JET_F16) &&
		(mShellBody.mEnumShellType == CALIBRO_100) && (mShellBody.mDetonator.mEnumDetonatorType == AR32A))
		 {
		double valR = 12., valProbMean = 0.16; ;

		calcProbSkaligaPlaneLaw_New(valR, valProbMean, pvalDestruct,
			pvalDispMiss);
		return;
	}

	if (((mTarget.menumTargetType == GARPUN_V300) ||
			(mTarget.menumTargetType == GARPUN_V700) || (mTarget.menumTargetType == GARPUN_V1000)) &&
		((mShellBody.mEnumShellType == CALIBRO_SHTAT_130) ||
			(mShellBody.mEnumShellType == CALIBRO_100)) && (mShellBody.mDetonator.mEnumDetonatorType == AR32A))
	 {
		calcProbSkaligaGarpunLaw(pvalDestruct, pvalDispMiss);
		return;
	 }

	if (((mTarget.menumTargetType == GARPUN_V300) ||
			(mTarget.menumTargetType == GARPUN_V700) || (mTarget.menumTargetType == GARPUN_V1000)) &&
		((mShellBody.mEnumShellType == CALIBRO_76_SHTAT) || (mShellBody.mEnumShellType ==
				CALIBRO_76_BARRIER)) &&
		((mShellBody.mDetonator.mEnumDetonatorType == AR51_LM) || (mShellBody.mDetonator.mEnumDetonatorType ==
				BARRIER)))
		 {
		TTable_3D Table_3D_KZP;
		switch(mShellBody.mEnumShellType)
		 {

		case CALIBRO_76_SHTAT:
			switch(mTarget.menumTargetType)
			 {
			case GARPUN_V300:
				Table_3D_KZP = Table_3D_KZP_Ca76_Shtat_GARPUN_300;
				break;

			case GARPUN_V700:
				Table_3D_KZP = Table_3D_KZP_Ca76_Shtat_GARPUN_700;
				break;

			case GARPUN_V1000:
				Table_3D_KZP = Table_3D_KZP_Ca76_Shtat_GARPUN_1000;
				break;
			default:
				break;
			};
			break;

			break;

		case CALIBRO_76_BARRIER:
			switch(mTarget.menumTargetType) {
			case GARPUN_V300:
				Table_3D_KZP = Table_3D_KZP_Ca76_Prosp_GARPUN_300;
				break;

			case GARPUN_V700:
				Table_3D_KZP = Table_3D_KZP_Ca76_Prosp_GARPUN_700;
				break;

			case GARPUN_V1000:
				Table_3D_KZP = Table_3D_KZP_Ca76_Prosp_GARPUN_1000;
				break;

			default:
				break;
			}

			break;

		default:
			break;

		}

		switch(mShellBody.mDetonator.mEnumDetonatorType)
		{
		case AR51_LM:
			calcProb_76Calibro_AR51_LM_Garpun(Table_3D_KZP, pvalDestruct,
				pvalDispMiss);
			break;

		case BARRIER:
			calcProb_76Calibro_DetonBarrier_Garpun(Table_3D_KZP, pvalDestruct,
				pvalDispMiss);
			break;

		default:
			break;
		}

		return;
	}

	/* if (((mShellBody.mEnumShellType == CALIBRO_76_SHTAT) ||(mShellBody.mEnumShellType == CALIBRO_76_BARRIER) )
	&& (mShellBody.mDetonator.mEnumDetonatorType == BARRIER)
	&&((mTarget.menumTargetType == GARPUN_V300)|| (mTarget.menumTargetType == GARPUN_V700)|| (mTarget.menumTargetType == GARPUN_V1000)))
	{
	TTable_1D tbl1D_Arr[10];
	TTable_2D Table2D_KZP_76Cal_DETONATOR_BARIER;
	double valNedolet0 = 0.;   // это искусственное смещение точки прицеливания
	if ((mTarget.menumTargetType == GARPUN_V300) &&(mShellBody.mEnumShellType == CALIBRO_76_BARRIER)) // GARPUN300 + ПЕРСПЕКИВНЫЙ СНАР
	{
	tbl1D_Arr[0] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah0;
	tbl1D_Arr[1] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah2;
	tbl1D_Arr[2] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah3;
	tbl1D_Arr[3] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah4;
	tbl1D_Arr[4] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah6;
	tbl1D_Arr[5] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah8;
	tbl1D_Arr[6] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah10;
	tbl1D_Arr[7] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah12;
	tbl1D_Arr[8] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah14;
	tbl1D_Arr[9] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah14_01;

	double arrArg[10] = {0.,2.,3.,4.,6.,8.,10.,12.,14., 14.01
	};
	Table2D_KZP_76Cal_DETONATOR_BARIER =  TTable_2D( arrArg, tbl1D_Arr, 10);
	valNedolet0 = 0.;//1.;

	}

	if ((mTarget.menumTargetType == GARPUN_V300) &&(mShellBody.mEnumShellType == CALIBRO_76_SHTAT)) // GARPUN300 + ШТАТНЫЙ СНАР
	{
	tbl1D_Arr[0] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah0;
	tbl1D_Arr[1] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah2;
	tbl1D_Arr[2] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah3;
	tbl1D_Arr[3] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah4;
	tbl1D_Arr[4] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah6;
	tbl1D_Arr[5] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah8;
	tbl1D_Arr[6] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah10;
	tbl1D_Arr[7] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah12;
	tbl1D_Arr[8] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah14;
	tbl1D_Arr[9] = TblKZP_Garpun300_76CalBarrier_VUBarrier_Promah14_01;

	for (int i = 3; i < 9; i++)
	{
	for (int j = 0; j < tbl1D_Arr[i].mNumCols; j++)
	{
	tbl1D_Arr[i].mparrVal[j] = tbl1D_Arr[i].mparrVal[j] /2.;
	}
	}

	double arrArg[10] = {0.,2.,3.,4.,6.,8.,10.,12.,14., 14.01
	};
	Table2D_KZP_76Cal_DETONATOR_BARIER =  TTable_2D( arrArg, tbl1D_Arr, 10);
	valNedolet0 = 0.;//2.;


	}


	if ((mTarget.menumTargetType == GARPUN_V700) &&(mShellBody.mEnumShellType == CALIBRO_76_BARRIER)) // GARPUN700 + ПЕРСПЕКИВНЫЙ СНАР
	{
	tbl1D_Arr[0] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah0;
	tbl1D_Arr[1] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah2;
	tbl1D_Arr[2] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah3;
	tbl1D_Arr[3] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah4;
	tbl1D_Arr[4] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah6;
	tbl1D_Arr[5] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah8;
	tbl1D_Arr[6] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah10;
	tbl1D_Arr[7] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah12;
	tbl1D_Arr[8] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah14;
	tbl1D_Arr[9] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah14_01;
	double arrArg[10] = {0.,2.,3.,4.,6.,8.,10.,12.,14., 14.01
	};
	Table2D_KZP_76Cal_DETONATOR_BARIER =  TTable_2D( arrArg, tbl1D_Arr, 10);
	valNedolet0 = 0.;//3.;

	}

	if ((mTarget.menumTargetType == GARPUN_V700) &&(mShellBody.mEnumShellType == CALIBRO_76_SHTAT)) // GARPUN700 + ШТАТНЫЙ СНАР
	{
	tbl1D_Arr[0] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah0;
	tbl1D_Arr[1] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah2;
	tbl1D_Arr[2] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah3;
	tbl1D_Arr[3] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah4;
	tbl1D_Arr[4] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah6;
	tbl1D_Arr[5] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah8;
	tbl1D_Arr[6] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah10;
	tbl1D_Arr[7] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah12;
	tbl1D_Arr[8] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah14;
	tbl1D_Arr[9] = TblKZP_Garpun700_76CalBarrier_VUBarrier_Promah14_01;
	for (int i = 3; i < 9; i++)
	{
	for (int j = 0; j < tbl1D_Arr[i].mNumCols; j++)
	{
	tbl1D_Arr[i].mparrVal[j] = tbl1D_Arr[i].mparrVal[j] /2.;
	}
	}

	double arrArg[10] = {0.,2.,3.,4.,6.,8.,10.,12.,14., 14.01
	};
	Table2D_KZP_76Cal_DETONATOR_BARIER =  TTable_2D( arrArg, tbl1D_Arr, 10);
	valNedolet0 = 0.;//3.;


	}

	//	_calcProb_TableUZP_BarrierDeton_(Table2D_KZP_76Cal_DETONATOR_BARIER, valNedolet0
	// ,pvalDestruct, pvalDispMiss, pvalDispNedolet);
	_calcProb_TableUZP_BarrierDeton_(Table2D_KZP_76Cal_DETONATOR_BARIER, valNedolet0
	,pvalDestruct, pvalDispMiss, pvalDispNedolet);

	return;
	}
	 */

	if (mShellBody.mDetonator.mEnumDetonatorType == DVM) {
		TURPolyLine plnUZP;
		switch(mTarget.menumTargetType) {
		case GARPUN_V300:
		case GARPUN_V700:
		case GARPUN_V1000:
			if (mShellBody.mEnumShellType == CALIBRO_SHTAT_130) {
				plnUZP = plnUZP_Calibro130_Garpun_DVM60;
			}
			else {
				if (mShellBody.mEnumShellType == CALIBRO_100) {
					plnUZP = plnUZP_Calibro100_Garpun_DVM60;
				}
			}
			break;

		case JET_F16:
			if (mShellBody.mEnumShellType == CALIBRO_SHTAT_130) {
				plnUZP = TURPolyLine::createUZP_Skaliga_AirPlane
					(VAlR_Calibro130_Plane, VAllProbMean_Calibro130_Plane, 50);
			}
			else {
				if (mShellBody.mEnumShellType == CALIBRO_100) {
					plnUZP = TURPolyLine::createUZP_Skaliga_AirPlane
						(VAlR_Calibro100_Plane, VAllProbMean_Calibro100_Plane, 50);
				}
			}
			break;

		default:
			break;
		}

		calcProb_DVM(plnUZP, pvalDestruct, pvalDispMiss);
		return;
	}

	if (mShellBody.mDetonator.mEnumDetonatorType == CONTACT) {
		*pvalDestruct = __calcProbDirectHitting__(pvalDispMiss,
			arrCorMtrxCartinSK, pPlgProjection);
		return;
	}

	return;
}

// ---------------------------------------------------------------------------
/*
// вычисление корреляционной матрицы ошибок рассеяния в картинной плоскости
// картинная плоскость это плоскость   oYZ в скоростной сиситеме координат привязанной к вектору относительной скорости
// Эта плоскость перпендикулярна вектору относительной скорости снаряд и цели
// ось OY сиситемы координат картинной плоскости параллельна горизонтальной плоскости и препендикулярна вектору относительной скорости
// ось OZ дополнияет до правой тройки
//  OUTPUT:
// arrCorrMatrx_CartinPlane[4]
void TNeighbourhoodAppPoint::calcCorrMatrx_CartinPlane(double *arrCorMtrxCartinSK)
{
// 1. формирование матрицы перехода из ГСК в СК картинной плоскости (Скоростную сиситему координат привязанную
// к вектору относительной скорости - или промаха)
double arrMtrxPer_from_GSK_To_CartinSK[9] = {0.};
calcMatrxPer_from_DecartPrSK_To_SSK( &(marrMiss[3]) , arrMtrxPer_from_GSK_To_CartinSK);
///

// 2. Переквод корреляц матрицы вектора промаха из ГСК в СК картинной плоскости

// 2.1 формирование корреляц матрицы по разбросу положения в ГСК
double arrPosK[9] = {0.};
for (int i = 0; i < 3; i++)
{
for (int j  = 0; j < 3; j++)
{
arrPosK      [ 3 * i + j] = marrCorMatrxMiss[ 6 * i + j];
}
}
///

// 2.2 перевод в СК картинной плоскости
double arrCorMtrxCartinSK_dim3[9] = {0.}, arrTEmp[9] = {0.};
MtrxMultMatrx(arrMtrxPer_from_GSK_To_CartinSK,3, 3, arrPosK,3, arrTEmp) ;
MtrxMultMatrxTransp(arrTEmp ,3, 3, arrMtrxPer_from_GSK_To_CartinSK,3, arrCorMtrxCartinSK_dim3) ;
///

// 2.3 формирование корреляц  матрицы 2х2  в картинной плоскости
arrCorMtrxCartinSK[0] = arrCorMtrxCartinSK_dim3[4];
arrCorMtrxCartinSK[1] = arrCorMtrxCartinSK_dim3[5];
arrCorMtrxCartinSK[2] = arrCorMtrxCartinSK[1];
arrCorMtrxCartinSK[3] = arrCorMtrxCartinSK_dim3[8];
///
}
//-----------------------------------------------------------------------------------------
 */
// вычисление корреляционной матрицы ошибок рассеяния в картинной плоскости
// картинная плоскость это плоскость   oYZ в скоростной сиситеме координат привязанной к вектору относительной скорости
// Эта плоскость перпендикулярна вектору относительной скорости снаряд и цели
// ось OY сиситемы координат картинной плоскости параллельна горизонтальной плоскости и препендикулярна вектору относительной скорости
// ось OZ дополнияет до правой тройки
// OUTPUT:
// arrCorrMatrx_CartinPlane[4]
void TNeighbourhoodAppPoint::calcCorrMatrx_CartinPlane
	(double *arrVOtnos, double *arrCorMatrx_GSK_Inp, double *arrCorMtrxCartinSK) {
	// 1. формирование матрицы перехода из ГСК в СК картинной плоскости (Скоростную сиситему координат привязанную
	// к вектору относительной скорости - или промаха)
	double arrMtrxPer_from_GSK_To_CartinSK[9] = {
		0.
	};
	calcMatrxPer_from_DecartPrSK_To_SSK(arrVOtnos,
		arrMtrxPer_from_GSK_To_CartinSK);
	///

	// 2. Переквод корреляц матрицы вектора промаха из ГСК в СК картинной плоскости

	// 2.1 формирование корреляц матрицы по разбросу положения в ГСК
	double arrPosK[9] = {
		0.
	};
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			arrPosK[3 * i + j] = arrCorMatrx_GSK_Inp[6 * i + j];
		}
	}
	///

	// 2.2 перевод в СК картинной плоскости
	double arrCorMtrxCartinSK_dim3[9] = {
		0.
	}, arrTEmp[9] = {
		0.
	};
	MtrxMultMatrx(arrMtrxPer_from_GSK_To_CartinSK, 3, 3, arrPosK, 3, arrTEmp);
	MtrxMultMatrxTransp(arrTEmp, 3, 3, arrMtrxPer_from_GSK_To_CartinSK, 3,
		arrCorMtrxCartinSK_dim3);
	///

	// 2.3 формирование корреляц  матрицы 2х2  в картинной плоскости
	arrCorMtrxCartinSK[0] = arrCorMtrxCartinSK_dim3[4];
	arrCorMtrxCartinSK[1] = arrCorMtrxCartinSK_dim3[5];
	arrCorMtrxCartinSK[2] = arrCorMtrxCartinSK[1];
	arrCorMtrxCartinSK[3] = arrCorMtrxCartinSK_dim3[8];
	///
}
// -----------------------------------------------------------------------------------------
/*
//---------------------------------------------------------------------------
// ПЕРЕГРУЖЕННАЯ !!!
// вычисление корреляционной матрицы ошибок рассеяния в картинной плоскости и ДИСПЕРСИИ НЕДОЛЕТА
// картинная плоскость это плоскость   oYZ в скоростной сиситеме координат привязанной к вектору относительной скорости
// Эта плоскость перпендикулярна вектору относительной скорости снаряд и цели
// ось OY сиситемы координат картинной плоскости параллельна горизонтальной плоскости и препендикулярна вектору относительной скорости
// ось OZ дополнияет до правой тройки
// INPUT:
// arrVOtnos[3] - вектор относительной скорости
//  OUTPUT:
// arrCorrMatrx_CartinPlane[4]
void TNeighbourhoodAppPoint::calcCorrMatrx_CartinPlane(double *arrCorMtrxCartinSK, double *pvalDispNedolet)
{
// 1. формирование матрицы перехода из ГСК в СК картинной плоскости (Скоростную сиситему координат привязанную
// к вектору относительной скорости - или промаха)
double arrMtrxPer_from_GSK_To_CartinSK[9] = {0.};
calcMatrxPer_from_DecartPrSK_To_SSK( &(marrMiss[3]) , arrMtrxPer_from_GSK_To_CartinSK);
///

// 2. Переквод корреляц матрицы вектора промаха из ГСК в СК картинной плоскости

// 2.1 формирование корреляц матрицы по разбросу положения в ГСК
double arrPosK[9] = {0.};
for (int i = 0; i < 3; i++)
{
for (int j  = 0; j < 3; j++)
{
arrPosK      [ 3 * i + j] = marrCorMatrxMiss[ 6 * i + j];
}
}
///

// 2.2 перевод в СК картинной плоскости
double arrCorMtrxCartinSK_dim3[9] = {0.}, arrTEmp[9] = {0.};
MtrxMultMatrx(arrMtrxPer_from_GSK_To_CartinSK,3, 3, arrPosK,3, arrTEmp) ;
MtrxMultMatrxTransp(arrTEmp ,3, 3, arrMtrxPer_from_GSK_To_CartinSK,3, arrCorMtrxCartinSK_dim3) ;
///

// 2.3 формирование корреляц  матрицы 2х2  в картинной плоскости
arrCorMtrxCartinSK[0] = arrCorMtrxCartinSK_dim3[4];
arrCorMtrxCartinSK[1] = arrCorMtrxCartinSK_dim3[5];
arrCorMtrxCartinSK[2] = arrCorMtrxCartinSK[1];
arrCorMtrxCartinSK[3] = arrCorMtrxCartinSK_dim3[8];
///

// 2.4 вычисление дисперсии недолета
 *pvalDispNedolet =  arrCorMtrxCartinSK_dim3[0];
}
 */

// ---------------------------------------------------------------------------
// ПЕРЕГРУЖЕННАЯ !!!
// вычисление корреляционной матрицы ошибок рассеяния в картинной плоскости и ДИСПЕРСИИ НЕДОЛЕТА
// картинная плоскость это плоскость   oYZ в скоростной сиситеме координат привязанной к вектору относительной скорости
// Эта плоскость перпендикулярна вектору относительной скорости снаряд и цели
// ось OY сиситемы координат картинной плоскости параллельна горизонтальной плоскости и препендикулярна вектору относительной скорости
// ось OZ дополнияет до правой тройки
// INPUT:
// arrVOtnos[3] - вектор относительной скорости
// arrCorMatrx_GSK_Inp[36] - корреляционная матрица
// OUTPUT:
// arrCorMtrxCartinSK[4]  - кооррел матрица в картинной плоскрсти
// *pvalDispNedolet - дисперсия недолета
// arrCorMtrxXY [4]  - кооррел матрица в вертикальной  плоскрсти СК относительной скорости

void TNeighbourhoodAppPoint::calcCorrMatrx_CartinPlane
	(double *arrVOtnos, double *arrCorMatrx_GSK_Inp, double *arrCorMtrxCartinSK,
	double *pvalDispNedolet, double *arrCorMtrxXY, double *arrCorMtrxXZ) {
	// 1. формирование матрицы перехода из ГСК в СК картинной плоскости (Скоростную сиситему координат привязанную
	// к вектору относительной скорости - или промаха)
	double arrMtrxPer_from_GSK_To_CartinSK[9] = {
		0.
	};
	// calcMatrxPer_from_DecartPrSK_To_SSK( &(marrMiss[3]) , arrMtrxPer_from_GSK_To_CartinSK);
	calcMatrxPer_from_DecartPrSK_To_SSK(arrVOtnos,
		arrMtrxPer_from_GSK_To_CartinSK);
	///

	// 2. Переквод корреляц матрицы вектора промаха из ГСК в СК картинной плоскости

	// 2.1 формирование корреляц матрицы по разбросу положения в ГСК
	double arrPosK[9] = {
		0.
	};
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			arrPosK[3 * i + j] = arrCorMatrx_GSK_Inp[6 * i + j];
		}
	}
	///

	// 2.2 перевод в СК картинной плоскости
	double arrCorMtrxCartinSK_dim3[9] = {
		0.
	}, arrTEmp[9] = {
		0.
	};
	MtrxMultMatrx(arrMtrxPer_from_GSK_To_CartinSK, 3, 3, arrPosK, 3, arrTEmp);
	MtrxMultMatrxTransp(arrTEmp, 3, 3, arrMtrxPer_from_GSK_To_CartinSK, 3,
		arrCorMtrxCartinSK_dim3);
	///

	// 2.3 формирование корреляц  матрицы 2х2  в картинной плоскости
	arrCorMtrxCartinSK[0] = arrCorMtrxCartinSK_dim3[4];
	arrCorMtrxCartinSK[1] = arrCorMtrxCartinSK_dim3[5];
	arrCorMtrxCartinSK[2] = arrCorMtrxCartinSK[1];
	arrCorMtrxCartinSK[3] = arrCorMtrxCartinSK_dim3[8];
	///

	// 2.4
	arrCorMtrxXY[0] = arrCorMtrxCartinSK_dim3[0];
	arrCorMtrxXY[1] = arrCorMtrxCartinSK_dim3[1];
	arrCorMtrxXY[2] = arrCorMtrxXY[1];
	arrCorMtrxXY[3] = arrCorMtrxCartinSK_dim3[4];
	// 2.5
	arrCorMtrxXZ[0] = arrCorMtrxCartinSK_dim3[0];
	arrCorMtrxXZ[1] = arrCorMtrxCartinSK_dim3[2];
	arrCorMtrxXZ[2] = arrCorMtrxXZ[1];
	arrCorMtrxXZ[3] = arrCorMtrxCartinSK_dim3[8];

	// 2.4 вычисление дисперсии недолета
	*pvalDispNedolet = arrCorMtrxCartinSK_dim3[0];
}

// -----------------------------------------------------------------------------------------
// пректирование полигонов описывающих геометрию цели на картинную плоскость
// OUTPUT:
// iarrNumWorkingPlanePolygons - массив номеров рабдочих полигонов цели
// *piNumWorkingPlanePoligons - длина этого массива
TURPolygon TNeighbourhoodAppPoint::project_Polygons_Upon_CartinPlane
	(int *iarrNumWorkingPlanePolygons, int *piNumWorkingPlanePoligons) {
	// 1. формирование массива указателей на работающие плоские полигоны

	createPointerArrayForWorkingPlanePoligons(NumMaxQuantPlanePolygons,
		iarrNumWorkingPlanePolygons, piNumWorkingPlanePoligons);
	///

	// 4. проектирование плоских полигонов на картинную плоскость
	// массив проекций плоских полигонов
	TURPolygon *pPlgarrProjections = new TURPolygon[*piNumWorkingPlanePoligons];

	for (int i = 0; i < (*piNumWorkingPlanePoligons); i++)
	{
	 pPlgarrProjections[i] = mTarget.mpArrPlanePolygon[iarrNumWorkingPlanePolygons[i]]
	 .createProjectionOfPolygon_To_CartinPlane(&(mTarget.mTraject.marrVectSostGSK[3]), &(marrMiss[3]));
	}
	TURPolygon plg(pPlgarrProjections, *piNumWorkingPlanePoligons);
	plg.calcBoundBox();
	delete[]pPlgarrProjections;
	return plg;
}
// ---------------------------------------------------------------------------

// вычисление вероятности пораж самол    по Скалыге
// INPUT:
// VAlR - дальность осреднениря
// VAlProbMean - средняя вероятность

// OUTPUT:
// *pvalDestruct  - вероятность поражения
// *pvalDispMiss - дисперсия промаха
void TNeighbourhoodAppPoint::calcProbSkaligaPlaneLaw_New
	(const double VAlR, const double VAlProbMean, double *pvalDestruct, double *pvalDispMiss) {
	/*
	// формирование корреляц матриц по разбросу положения и скорости
	double arrPosK[9] = {0.}, arrVelocityK[9] ={0.};
	for (int i = 0; i < 3; i++)
	{
	for (int j  = 0; j < 3; j++)
	{
	arrPosK      [ 3 * i + j] = marrCorMatrxMiss[ 6 * i + j];
	arrVelocityK [ 3 * i + j] = marrCorMatrxMiss[ 6 * (i + 3) + j + 3];
	}
	}
	///
	double arrVPos[9] = {0.} , arrLambPos[3] = {0.},arrVVelo[9] = {0.} , arrLambVelo[3] = {0.};
	CalcProperVectors_And_Numbers_R3(arrPosK, arrVPos , arrLambPos)  ;
	CalcProperVectors_And_Numbers_R3(arrVelocityK, arrVVelo , arrLambVelo)  ;
	///

	 *pvalDestruct = 0.;
	 *pvalDispMiss = 0.;
	int iNC = 1000;
	for (int i =0; i < iNC; i++)
	{
	double arrKsi[3] = {0.}, arrPsi[3] ={0}, arrPos[3] = {0.}, arrVelo[3] ={0.},  arrTemp[3]  ={0.};
	arrKsi[0] = getGauss(0., 1. )* sqrt(arrLambPos[0]);;
	arrKsi[1] = getGauss(0., 1. )* sqrt(arrLambPos[1]);
	arrKsi[2] = getGauss(0., 1. )* sqrt(arrLambPos[2]);
	MtrxMultMatrx(arrVPos,3, 3, arrKsi,1, arrTemp) ;
	MtrxSumMatrx(marrMiss, arrTemp,3, 1, arrPos) ;

	arrPsi[0] = getGauss(0., 1. ) * arrLambVelo[0] ;
	arrPsi[1] = getGauss(0., 1. ) * arrLambVelo[1] ;
	arrPsi[2] = getGauss(0., 1. ) * arrLambVelo[2] ;
	MtrxMultMatrx(arrVVelo,3, 3, arrPsi,1, arrTemp) ;
	MtrxSumMatrx(&marrMiss[3], arrTemp,3, 1, arrVelo) ;

	double temp = ScalProduct(arrPos , arrVelo, 3)/ Norm3(arrVelo) ;
	double valMissSq = Norm3(arrPos)* Norm3(arrPos) - temp * temp ;
	 *pvalDispMiss += valMissSq;
	double valPCur = fncScaligaPlaneLaw(VAlR,  VAlProbMean,  sqrt(valMissSq));
	 *pvalDestruct +=  valPCur;

	}
	 *pvalDestruct = (*pvalDestruct) / iNC;
	 *pvalDispMiss = *pvalDispMiss   / iNC; */
	double arrCorMtrxCartinSK[4] = {
		0.
	}; // корреляц матрица рассеяния в картинной плоскости
	calcCorrMatrx_CartinPlane(&(marrMiss[3]), marrCorMatrxMiss,
		arrCorMtrxCartinSK);
	// 2.4 вычисление определителя матрицы arrCorMtrxCartinSK
	const double VAlDet = arrCorMtrxCartinSK[0] * arrCorMtrxCartinSK[3]
		- arrCorMtrxCartinSK[1] * arrCorMtrxCartinSK[1];
	// 2.4 формирование обратной матрицы
	double arrCorMtrxCartinSK_Inv[4] = {
		0.
	};
	InverseMtrx2(arrCorMtrxCartinSK, arrCorMtrxCartinSK_Inv);
	///
	double val_AMax = 50.;
	double val_h = 0.1; // шаг сетки интегрирования
	int iX = 2. * val_AMax / val_h;
	int iY = iX;
	double valProbRez = 0.;
	double arrx[2] = {
		0.
	};
	for (int i = 0; i < iY; i++) {

		for (int j = 0; j < iX; j++) {
			arrx[0] = -val_AMax + ((double)j) * val_h;
			arrx[1] = -val_AMax + ((double)i) * val_h;
			double valD = NormVect2(arrx);
			valProbRez += exp(-calcYT_D_Y(arrx, arrCorMtrxCartinSK_Inv, 2)
				/ 2.) * val_h * val_h * fncScaligaPlaneLaw(VAlR, VAlProbMean, valD); ;
		}
	}
	valProbRez = valProbRez / (2. * M_PI * sqrt(VAlDet));

	// 6. вычисление дисперсии промаха
	*pvalDispMiss = arrCorMtrxCartinSK[0] + arrCorMtrxCartinSK[3];
	*pvalDestruct = valProbRez;
	return;
}
// ---------------------------------------------------------------------------
// parrAimingPoints_X [mQuantShells]-  массив различных точек прицеливания по оси X
// piarrRepeatQuants_X [mQuantShells] - массив повторений точек прицеливания по оси X
// *pQuantAimingPoints_X- к- во различных точек прицеливания по оси X
// parrAimingPoints_Y [mQuantShells]-  массив различ ных точек прицеливания по оси Y
// piarrRepeatQuants_Y [mQuantShells] - массив повторений точек прицеливания по оси Y
// *pQuantAimingPoints_Y - к- во различных точек прицеливания по сои Y

void TNeighbourhoodAppPoint::fncMilitaryPlannerForCoastTarg
	(double *parrAimingPoints_X, int *piarrRepeatQuants_X0, const int QUantAimingPoints_X,
	double *parrAimingPoints_Y, int *piarrRepeatQuants_Y0,
	const int QUantAimingPoints_Y, TURPointXY *ppntArrCorrecting) {
	int *piarrRepeatQuants_X = new int[QUantAimingPoints_X];
	memcpy(piarrRepeatQuants_X, piarrRepeatQuants_X0, QUantAimingPoints_X*sizeof
		(int));
	int *piarrRepeatQuants_Y = new int[QUantAimingPoints_Y];
	memcpy(piarrRepeatQuants_Y, piarrRepeatQuants_Y0, QUantAimingPoints_Y*sizeof
		(int));
	// вычисление к-ва выстрелов
	int iQuantShells = 0;
	for (int i = 0; i < QUantAimingPoints_X; i++) {
		iQuantShells += piarrRepeatQuants_X[i];
	}
	///
	int icur = 0;
	const int NUmCol = QUantAimingPoints_X * QUantAimingPoints_Y;

	bool bbreak = false;
	for (int i = 0; i < 1000; i++) {
		for (int j = 0; j < NUmCol; j++) {
			int ix = j % QUantAimingPoints_X;
			int iy = j / QUantAimingPoints_X;
			if ((piarrRepeatQuants_X[ix] > 0) && (piarrRepeatQuants_Y[iy] > 0))
			{
				ppntArrCorrecting[icur].X = parrAimingPoints_X[ix];
				ppntArrCorrecting[icur].Y = parrAimingPoints_Y[iy];
				piarrRepeatQuants_X[ix]--;
				piarrRepeatQuants_Y[iy]--;
				icur++;
				if (icur == iQuantShells) {
					bbreak = true;
					break;
				}
			}

		}
		if (bbreak) {
			break;
		}
	}

	delete[]piarrRepeatQuants_X;
	delete[]piarrRepeatQuants_Y;
	return;
}

// -------------------------------------------------------------------------
// Отыскание оптимальных по минимаксному критерию точек прицеливания
// цели   представляющей группу равнозначных точек расположенных на ОДНОЙ ПРЯМОЙ
// INPUT:
// parrMtrxCorr[4] -коррелц матрица ошибок  рассеяния  точки  падения в сиситеме координат цели (ось X совпадает с прямой, на которой пасположены точки)
// VAlKillingRange  - радиус поражения
// QUantShells  - к-во испытаний
// In - к-во узлов сетки по точкам прицеливания
// parrTargX [LEnarrX] -  массив точек цели на оси X сиситемы координат цели
// OUTPUT:
// parrAimingPoints [mQuantShells]-  массив различных точек прицеливания по оси X в системе координат цели
// piarrRepeatQuants [mQuantShells] - массив повторений точек прицеливания по оси X
// *pQuantAimingPoints- к- во различных точек прицеливания по оси X
// ppntArrAimingPoints_SKT[mQuantShells]-  массив различных точек прицеливания в сиситеме координат цели
// для массивов parrAimingPoints,  piarrRepeatQuants и  ppntArrAimingPoints должна быть зарезервирована максимальная  память
// mQuantShells, но по результатам работы алгоритма, значащими элементами этих массивов
// будут являться первые *pQuantAimingPoints элементов
// *pvalProb - вероятность поражения
void TNeighbourhoodAppPoint::calcDestructionProb_For_GroupLinedPointCoastTargs
	(const int QAantIspit, double *parrMtrxCorr, const double VAlKillingRange,
	const int QUantShells, const int In, double *parrTargX, const int LEnarrX,
	double *parrAimingPoints, int *piarrRepeatQuants, int *pQuantAimingPoints,
	TURPointXY *ppntArrAimingPoints_SKT, double *pvalProb) {
	calcArray_Of_AimPoints_ForGroupLinedPointTargs
		(parrMtrxCorr, VAlKillingRange, QUantShells, In, parrTargX, LEnarrX, parrAimingPoints,
		piarrRepeatQuants, pQuantAimingPoints);
	int *piarrSuccess = new int[LEnarrX];
	double valSum = 0.;
	// for (int i = 0; i < QUantShells; i++)
	// {
	// ppntArrCorrecting[i] = ppntArrCorrecting[i].LinTransform(valRotateAng,pntSdvig, valRastigenie ) ;
	// }
	// ppntArrCorrecting[0].WriteSetSHPFiles(L"E:\\Ametist\\22-02-2018\\NEW\\ppntArrCorrecting_GSK.shp", ppntArrCorrecting,QUantShells);

	///

	double arrF[4] = {
		0.
	}, arrMtrxLamb[4] = {
		0.
	};
	CalcProperVectors2(parrMtrxCorr, arrF, arrMtrxLamb);
	///
	double valProbSum = 0.;
	for (int i = 0; i < (*pQuantAimingPoints); i++) {
		ppntArrAimingPoints_SKT[i].X = parrAimingPoints[i];
		ppntArrAimingPoints_SKT[i].Y = 0.;
	}
	///

	for (int i = 0; i < QAantIspit; i++) {
		memset(piarrSuccess, 0, LEnarrX*sizeof(int));

		// rastrTarg.WriteMeAsFltFile(L"E:\\PROJECTS_C++\\TARAN\\New\\rastrTarg.flt"); //!!!!!
		// ppntArrCorrecting[0].WriteSetSHPFiles(L"E:\\PROJECTS_C++\\TARAN\\New\\ppntArrCorrecting.shp", ppntArrCorrecting,QUantShells);
		// plgTarg0.WriteSetSHPFiles(L"E:\\PROJECTS_C++\\TARAN\\New\\plgTarg01.shp", &plgTarg0,1); //!!!!!

		for (int j = 0; j < (*pQuantAimingPoints); j++) {

			// рзигрывание вектора просмаха и относительной скорости в КГСК
			double arrPos_GSK[2] = {
				0.
			};
			double arrCorrecting[2] = {
				0.
			};
			arrCorrecting[0] = parrAimingPoints[j];
			arrCorrecting[1] = 0.;
			for (int m = 0; m < piarrRepeatQuants[j]; m++) {

				getGaussVector(2, arrCorrecting, arrF, arrMtrxLamb, arrPos_GSK);

				TURPointXY pntFall(arrPos_GSK[0], arrPos_GSK[1]);
				// точка падения
				// pntFall.WriteSetSHPFiles(L"E:\\Ametist\\22-02-2018\\NEW\\pntFallCur.shp", &pntFall,1);
				// pntFall.WriteSetSHPFiles(L"E:\\Ametist\\22-02-2018\\NEW\\pntAimCur.shp", &ppntArrCorrecting[j],1);

				for (int n = 0; n < LEnarrX; n++) {
					double dist = sqrt((arrPos_GSK[0] - parrTargX[n]) *
						(arrPos_GSK[0] - parrTargX[n]) + arrPos_GSK[1] * arrPos_GSK[1]);
					if (dist <= VAlKillingRange) {
						piarrSuccess[n] = 1;
					}
				}

				int iii = 0;
			}
		}
		double valSum = 0.;

		for (int nn = 0; nn < LEnarrX; nn++) {
			if (piarrSuccess[nn] > 0.001) {
				valSum += 1.;
			}
		}
		double valPTemp = valSum / ((double)LEnarrX);
		valProbSum += valPTemp;

		// rastrTargCur.WriteMeAsFltFile(L"E:\\Ametist\\22-02-2018\\COAST_1D\\plgTarg0.flt"); //!!!!!
	}
	*pvalProb = valProbSum / ((double)QAantIspit);

	delete[]piarrSuccess;
}

// -------------------------------------------------------------------------
// Отыскание оптимальных по минимаксному критерию точек прицеливания
// цели   представляющей группу равнозначных точек НЕ расположенных на ОДНОЙ ПРЯМОЙ
// INPUT:
// arrElK[4] - коррелц матрица ошибок  рассеяния  точки  падения  в сиситеме координат ГСК
// VAlKillingRange  - радиус поражения
// QUantShells  - к-во испытаний
// PLgTarg - полигон цели, являющийся выпуклой оболочкой множества точек цели
// VAlCellSize -  величина ячейки растра цели
// OUTPUT:
// piarrRepeatQuants_X [mQuantShells] - массив повторений точек прицеливания по оси X
// ppntArrAimingPoints[mQuantShells]-  массив различных точек прицеливания
// для массивов piarrRepeatQuants_X и  ppntArrAimingPoints должна быть зарезервирована максимальная  память
// mQuantShells, но по результатам работы алгоритма, значащими элементами этих массивов
// будут являться первые *pQuantAimingPoints элементов
// *pQuantAimingPoints_X- к- во различных точек прицеливания
// *pvalProb - вероятность поражения
void TNeighbourhoodAppPoint::
	calcDestructionProb_For_GroupNotLinedPointCoastTargs
	(const int QAantIspit, double *arrElK, const double VAlKillingRange, const int QUantShells,
	TURPolygon plgTarg, const double VAlCellSize,
	TURPointXY *ppntArrAimingPoints, int *pQuantAimingPoints, int *piarrRepeatQuants,
	double *pvalProb) {
	calcArray_Of_AimPoints_ForGroupNotLinedPointTargs
		(arrElK, VAlKillingRange, QUantShells, plgTarg, VAlCellSize, ppntArrAimingPoints, pQuantAimingPoints,
		piarrRepeatQuants);
	TYrRastr rastrTargGSK(plgTarg, VAlCellSize, 0.);
	plgTarg.calcBoundBox();
	int *piarrSuccess = new int[plgTarg.NumPoints - 1];
	double valSum = 0.;

	double arrF[4] = {
		0.
	}, arrMtrxLamb[4] = {
		0.
	};
	CalcProperVectors2(arrElK, arrF, arrMtrxLamb);
	///
	double valProbSum = 0.;

	for (int i = 0; i < QAantIspit; i++) {
		memset(piarrSuccess, 0, (plgTarg.NumPoints - 1)*sizeof(int));

		// rastrTarg.WriteMeAsFltFile(L"E:\\PROJECTS_C++\\TARAN\\New\\rastrTarg.flt"); //!!!!!
		// ppntArrCorrecting[0].WriteSetSHPFiles(L"E:\\PROJECTS_C++\\TARAN\\New\\ppntArrCorrecting.shp", ppntArrCorrecting,QUantShells);
		// plgTarg0.WriteSetSHPFiles(L"E:\\PROJECTS_C++\\TARAN\\New\\plgTarg01.shp", &plgTarg0,1); //!!!!!

		for (int j = 0; j < (*pQuantAimingPoints); j++) {

			// рзигрывание вектора просмаха  КГСК
			double arrPos_GSK[2] = {
				0.
			};
			double arrCorrecting[2] = {
				0.
			};
			arrCorrecting[0] = ppntArrAimingPoints[j].X;
			arrCorrecting[1] = ppntArrAimingPoints[j].Y;
			for (int m = 0; m < piarrRepeatQuants[j]; m++) {

				getGaussVector(2, arrCorrecting, arrF, arrMtrxLamb, arrPos_GSK);

				TURPointXY pntFall(arrPos_GSK[0], arrPos_GSK[1]);
				// точка падения
				// pntFall.WriteSetSHPFiles(L"E:\\Ametist\\22-02-2018\\NEW\\pntFallCur.shp", &pntFall,1);
				// pntFall.WriteSetSHPFiles(L"E:\\Ametist\\22-02-2018\\NEW\\pntAimCur.shp", &ppntArrCorrecting[j],1);

				for (int n = 0; n < (plgTarg.NumPoints - 1); n++) {
					double valdist = TURPointXY::dist
						(pntFall, plgTarg.Points[n]);
					if (valdist <= VAlKillingRange) {
						piarrSuccess[n] = 1;
					}
				}

				int iii = 0;
			}
		}
		double valSum = 0.;

		for (int nn = 0; nn < (plgTarg.NumPoints - 1); nn++) {
			if (piarrSuccess[nn] > 0.001) {
				valSum += 1.;
			}
		}
		double valPTemp = valSum / ((double)(plgTarg.NumPoints - 1));
		valProbSum += valPTemp;

		// rastrTargCur.WriteMeAsFltFile(L"E:\\Ametist\\22-02-2018\\COAST_1D\\plgTarg0.flt"); //!!!!!
	}
	*pvalProb = valProbSum / ((double)QAantIspit);
	delete[]piarrSuccess;

}

// ----------------------------------------------------------------------------------------------

// ВЫчисление массива оптимальных точек прицеливания по одной оси для групповой точечной цели
// расположенной на одной прямой OX
// Задана цель в виде набора точек на оси  OX

// На отрезке выбрана равномерная сетка из In равноотстоящих друг от друга точек прицеливания
// INPUT:

// VAlSig - СКЗ точки падения
// VAlKillingRange - радиус поражения
// QUantShells  - к-во выстрелов
// In  - к-во узловых точек прицеливания
// parrx[LEnarrX] - точки цели
// OUTPUT:
// parrAimingPoints -  массив различных точек прицеливания
// piarrRepeatQuants - массив повторений точек прицеливания
// *pQuantAimingPoints - к- во различных точек прицеливания
void TNeighbourhoodAppPoint::calcArray_Of_AimPoints_ForGroupNotLinedPointTargs
	(double *arrElK, const double VAlKillingRange, const int QUantShells,
	TURPolygon plgTarg, const double VAlCellSize, TURPointXY *ppntArrAimingPoints,
	int *pQuantAimingPoints, int *piarrRepeatQuants)

{
	TYrRastr rastrTarg(plgTarg, VAlCellSize, 1.);
	plgTarg.calcBoundBox();
	// rastrTargGSK.WriteMeAsFltFile(L"E:\\Ametist\\22-02-2018\\New\\rastrTargGSK.flt");

	int INum = rastrTarg.calcQuantValuablePiksels();

	// формирование матрицы игры
	double *parr_C = new double[INum * (plgTarg.NumPoints - 1)];
	const double VAlStepIntegr = VAlKillingRange / 10.;
	int icol = 0, irow = 0;
	for (int i = 0; i < rastrTarg.ncols * rastrTarg.nrows; i++) {
		if (rastrTarg.getValue(i) < 0.5) {
			continue;
		}
		TURPointXY pnt0 = rastrTarg.getCellCentre(i);
		icol = 0;
		for (int j = 0; j < (plgTarg.NumPoints - 1); j++) {
			TURPointXY pnt1 = plgTarg.Points[j];

			TURPointXY pntDif(pnt1.X - pnt0.X, pnt1.Y - pnt0.Y);
			double valp = TProbabilityTheory::calcIntegralNormalDensity_2D
				(pntDif.X, pntDif.Y, arrElK, VAlKillingRange, VAlStepIntegr);

			parr_C[irow * (plgTarg.NumPoints - 1) + icol] = -log(1. - valp);
			icol++;
		}
		irow++;
	}

	///

	double fval = -1.;
	double *parr_freq = new double[INum];
	memset(parr_freq, 0, sizeof(double) * INum);
	TGameTheory::solvMartrxGame(parr_C, INum, (plgTarg.NumPoints - 1),
		parr_freq, NULL, fval);

	int *piarr_q = new int[INum]; // к-во повторений точки прицелив с номером i
	double *parr_z = new double[INum];
	int iSum = 0;
	for (int i = 0; i < INum; i++) {
		piarr_q[i] = QUantShells * parr_freq[i];
		iSum += piarr_q[i];
		parr_z[i] = ((double)QUantShells) * parr_freq[i] - piarr_q[i];
	}
	///

	int iJ = QUantShells - iSum;
	for (int i = 0; i < iJ; i++) {
		int j = -1;
		MaxDoubleArray(parr_z, INum, &j);
		piarr_q[j]++;
		parr_z[j] = -1.;
	}
	///

	int icur = 0;
	// TURPointXY *pPntArrTemp = new TURPointXY[QUantShells];
	// int *piarrRepeatQuants = new int [QUantShells];
	for (int i = 0; i < INum; i++) {
		if (piarr_q[i] > 0) {
			piarrRepeatQuants[icur] = piarr_q[i];
			int iOrderNum = rastrTarg.getOrderNum(i);
			ppntArrAimingPoints[icur] = rastrTarg.getCellCentre(iOrderNum);
			icur++;

		}
	}
	*pQuantAimingPoints = icur;
	// ддля проверки
	// int isum = 0;
	// for (int i = 0; i < icur; i++)
	// {
	// isum +=   piarrRepeatQuants[i];
	// }

	delete[]parr_z;
	delete[]piarr_q;

	delete[]parr_freq;
	delete[]parr_C;

}

// -----------------------------------------------------------------------------------
void TNeighbourhoodAppPoint::calcProb_DVM
	(TURPolyLine plnUZP, double *pvalDestruct, double *pvalDispMiss) {

	// ошибки дисткретизации ВУ
	double arrCorrMtrxDiscret[9] = {
		0.
	};
	calcCorrMtrxDiscretisation_And_CannonDelayT(arrCorrMtrxDiscret);
	//
	// формирование корреляц матриц по разбросу положения
	double arrPosK[9] = {
		0.
	};
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			arrPosK[3 * i + j] = marrCorMatrxMiss[6 * i + j];

		}
	}

	MtrxSumMatrx(arrCorrMtrxDiscret, arrPosK, 3, 3, arrPosK);
	///
	double arrVPos[9] = {
		0.
	}, arrLambPos[9] = {
		0.
	}, arrVVelo[9] = {
		0.
	}, arrLambVelo[3] = {
		0.
	};
	CalcProperVectors_And_Numbers_R3(arrPosK, arrVPos, arrLambPos);

	///

	*pvalDestruct = 0.;
	*pvalDispMiss = 0.;
	int iNC = 1000;
	for (int i = 0; i < iNC; i++) {
		double arrKsi[3] = {
			0.
		}, arrPsi[3] = {
			0
		}, arrPos[3] = {
			0.
		}, arrVelo[3] = {
			0.
		}, arrTemp[3] = {
			0.
		};
		arrKsi[0] = getGauss(0., 1.) * sqrt(arrLambPos[0]); ;
		arrKsi[1] = getGauss(0., 1.) * sqrt(arrLambPos[4]);
		arrKsi[2] = getGauss(0., 1.) * sqrt(arrLambPos[8]);
		MtrxMultMatrx(arrVPos, 3, 3, arrKsi, 1, arrTemp);
		MtrxSumMatrx(marrMiss, arrTemp, 3, 1, arrPos);

		double valMissSq = Norm3(arrPos) * Norm3(arrPos);
		*pvalDispMiss += valMissSq;
		double valPCur = plnUZP.LinearValueApprox(sqrt(valMissSq));
		*pvalDestruct += valPCur;

	}
	*pvalDestruct = (*pvalDestruct) / iNC;
	*pvalDispMiss = *pvalDispMiss / iNC;
}

// -----------------------------------------------------------------------------------

// -----------------------------------------------------------------------------------
void TNeighbourhoodAppPoint::calcProb_TableUZP_MFIVU
	(TTable_3D TableUZP, double *pvalDestruct, double *pvalDispMiss) {

	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// формирование корреляц матриц по разбросу положения и скорости
	double arrPosK[9] =	{0.
	},
	arrVelocityK[9] = {	0.
	};

	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			arrPosK[3 * i + j] = marrCorMatrxMiss[6 * i + j];
			arrVelocityK[3 * i + j] = marrCorMatrxMiss[6 * (i + 3) + j + 3];
		}
	}
	///
	double arrVPos[9] =	{0.	}, arrMtrxLambPos[9] = {0. }, arrVVelo[9] = {0.	}
	, arrMtrxLambVelo[9] = {0. };
	CalcProperVectors_And_Numbers_R3(arrPosK, arrVPos, arrMtrxLambPos);
	CalcProperVectors_And_Numbers_R3(arrVelocityK, arrVVelo, arrMtrxLambVelo);
	///

	*pvalDestruct = 0.;
	*pvalDispMiss = 0.;
	int iNC = 1000;
	for (int i = 0; i < iNC; i++)

	 {
		double arrKsi[3] = {
			0.
		}, arrPsi[3] = {
			0
		}, arrPos[3] = {
			0.
		}, arrVelo[3] = {
			0.
		}, arrTemp[3] = {
			0.
		};
		arrKsi[0] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[0]); ;
		arrKsi[1] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[4]);
		arrKsi[2] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[8]);
		MtrxMultMatrx(arrVPos, 3, 3, arrKsi, 1, arrTemp);
		MtrxSumMatrx(marrMiss, arrTemp, 3, 1, arrPos);

		arrPsi[0] = getGauss(0., 1.) * arrMtrxLambVelo[0];
		arrPsi[1] = getGauss(0., 1.) * arrMtrxLambVelo[4];
		arrPsi[2] = getGauss(0., 1.) * arrMtrxLambVelo[8];
		MtrxMultMatrx(arrVVelo, 3, 3, arrPsi, 1, arrTemp);
		MtrxSumMatrx(&marrMiss[3], arrTemp, 3, 1, arrVelo);

		double temp = ScalProduct(arrPos, arrVelo, 3) / Norm3(arrVelo);
		double valMissSq = Norm3(arrPos) * Norm3(arrPos) - temp * temp;
		*pvalDispMiss += valMissSq;
		double valPCur = TableUZP.calcValue
			(mTarget.mTraject.marrVectSostGSK_Begin[2], mDistAppPoint, sqrt(valMissSq));
		*pvalDestruct += valPCur;

	}
	*pvalDestruct = (*pvalDestruct) / iNC;
	*pvalDispMiss = *pvalDispMiss / iNC;

}

// -----------------------------------------------------------------------------------

// -----------------------------------------------------------------------------------
void TNeighbourhoodAppPoint::calcProb_TableUZP_BarrierDeton_
	(TTable_2D TableUZP_2D, const double VAlNedolet0, double *pvalDestruct,
	double *pvalDispMiss, double *pvalDispNedolet) {
	// ошибки дисткретизации ВУ
	double arrCorrMtrxDiscret[9] = {
		0.
	};
	calcCorrMtrxDiscretisation_And_CannonDelayT(arrCorrMtrxDiscret);
	//
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// формирование корреляц матриц по разбросу положения и скорости
	double arrPosK[9] = {
		0.
	}; // , arrVelocityK[9] ={0.};
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			arrPosK[3 * i + j] = marrCorMatrxMiss[6 * i + j];
			// arrVelocityK [ 3 * i + j] = marrCorMatrxMiss[ 6 * (i + 3) + j + 3];
		}
	}
	///
	// добавление матрицы дискретизации
	double arrT0[9] = {
		0.
	};
	MtrxSumMatrx(arrCorrMtrxDiscret, arrPosK, 3, 3, arrT0);
	memcpy(arrPosK, arrT0, 9 * sizeof(double));

	///
	double arrVPos[9] = {
		0.
	}, arrMtrxLambPos[9] = {
		0.
	}; // ,arrVVelo[9] = {0.} , arrMtrxLambVelo[9] = {0.};
	CalcProperVectors_And_Numbers_R3(arrPosK, arrVPos, arrMtrxLambPos);
	// CalcProperVectors_And_Numbers_R3(arrVelocityK, arrVVelo , arrMtrxLambVelo)  ;
	///
	// смещенная точка прицеливания с недолетом
	double arrAimPoint[3] = {
		0.
	}, arrVOrt[3] = {
		0.
	};
	memcpy(arrVOrt, &marrMiss[3], 3 * sizeof(double));
	NormalizeVect3(arrVOrt);
	MatrxMultScalar(arrVOrt, 1, 3, VAlNedolet0, arrAimPoint);
	///
	*pvalDestruct = 0.;
	*pvalDispMiss = 0.;
	*pvalDispNedolet = 0.;
	int iNC = 1000;
	for (int i = 0; i < iNC; i++) {
		double arrKsi[3] = {
			0.
		}, arrPsi[3] = {
			0
		}, arrPos[3] = {
			0.
		}, arrVelo[3] = {
			0.
		}, arrTemp[3] = {
			0.
		};
		arrKsi[0] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[0]); ;
		arrKsi[1] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[4]);
		arrKsi[2] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[8]);
		MtrxMultMatrx(arrVPos, 3, 3, arrKsi, 1, arrTemp);
		MtrxSumMatrx(arrAimPoint, arrTemp, 3, 1, arrPos);

		// arrPsi[0] = getGauss(0., 1. ) * sqrt(arrMtrxLambVelo[0]) ;
		// arrPsi[1] = getGauss(0., 1. ) * sqrt(arrMtrxLambVelo[4]) ;
		// arrPsi[2] = getGauss(0., 1. ) * sqrt( arrMtrxLambVelo[8]) ;
		// MtrxMultMatrx(arrVVelo,3, 3, arrPsi,1, arrTemp) ;
		// MtrxSumMatrx(&marrMiss[3], arrTemp,3, 1, arrVelo) ;

		double valNedolet = ScalProduct(arrPos, &marrMiss[3], 3) / Norm3
			(&marrMiss[3]);
		double valMissSq = Norm3(arrPos) * Norm3(arrPos)
			- valNedolet * valNedolet;
		// double valNedolet =  VAlNedolet0 - temp
		*pvalDispNedolet += valNedolet * valNedolet;
		*pvalDispMiss += valMissSq;
		double valPCur = TableUZP_2D.calcValue(sqrt(valMissSq), valNedolet);
		*pvalDestruct += valPCur;

	}
	*pvalDestruct = (*pvalDestruct) / ((double)iNC);
	*pvalDispMiss = *pvalDispMiss / ((double)iNC);
	*pvalDispNedolet = *pvalDispNedolet / ((double)iNC);

	// double arrCorMtrxCartinSK[4] = {0.}, valDispNedolet = -1.;
	// calcCorrMatrx_CartinPlane(arrCorMtrxCartinSK, &valDispNedolet);
	int iii = 0;
}

// ----------------------------------------------------------------------------

// -----------------------------------------------------------------------------------
void TNeighbourhoodAppPoint::_calcProb_TableUZP_BarrierDeton_
	(TTable_2D TableUZP_2D, const double VAlNedolet0, double *pvalDestruct,
	double *pvalDispMiss, double *pvalDispNedolet) {
	// ошибки дисткретизации ВУ
	double arrCorrMtrxDiscret[9] = {
		0.
	};
	calcCorrMtrxDiscretisation_And_CannonDelayT(arrCorrMtrxDiscret);
	//
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// формирование корреляц матриц по разбросу положения и скорости
	double arrPosK[9] = {
		0.
	}; // , arrVelocityK[9] ={0.};
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			arrPosK[3 * i + j] = marrCorMatrxMiss[6 * i + j];
			// arrVelocityK [ 3 * i + j] = marrCorMatrxMiss[ 6 * (i + 3) + j + 3];
		}
	}
	///
	// добавление матрицы дискретизации
	double arrT0[9] = {
		0.
	};
	MtrxSumMatrx(arrCorrMtrxDiscret, arrPosK, 3, 3, arrT0);
	memcpy(arrPosK, arrT0, 9 * sizeof(double));

	///
	double arrVPos[9] = {
		0.
	}, arrMtrxLambPos[9] = {
		0.
	}; // ,arrVVelo[9] = {0.} , arrMtrxLambVelo[9] = {0.};
	CalcProperVectors_And_Numbers_R3(arrPosK, arrVPos, arrMtrxLambPos);
	// CalcProperVectors_And_Numbers_R3(arrVelocityK, arrVVelo , arrMtrxLambVelo)  ;
	///
	// смещенная точка прицеливания с недолетом
	double arrAimPoint[3] = {
		0.
	}, arrVOrt[3] = {
		0.
	};
	memcpy(arrVOrt, &marrMiss[3], 3 * sizeof(double));
	NormalizeVect3(arrVOrt);
	MatrxMultScalar(arrVOrt, 1, 3, VAlNedolet0, arrAimPoint);
	///

	// перевод смещенной точки прицеливания в сиситему координат эллипсроида рассеяния
	double arrAimPoint0[3] = {
		0.
	};
	MtrxTranspMultMatrx(arrVPos, 3, 3, arrAimPoint, 1, arrAimPoint0);
	///
	*pvalDestruct = 0.;
	*pvalDispMiss = 0.;
	*pvalDispNedolet = 0.;

	// установка предлов интегрирования по 3-м осям эллипсоида рассеяния
	int iNc = 100;
	if (arrMtrxLambPos[0] < 0.) {
		arrMtrxLambPos[0] = 0.00001;
	}
	if (arrMtrxLambPos[4] < 0.) {
		arrMtrxLambPos[4] = 0.00001;
	}
	if (arrMtrxLambPos[8] < 0.) {
		arrMtrxLambPos[8] = 0.00001;
	}
	double valLimX = sqrt(arrMtrxLambPos[0]) * 3.;
	double valLimY = sqrt(arrMtrxLambPos[4]) * 3.;
	double valLimZ = sqrt(arrMtrxLambPos[8]) * 3.;
	double valStepX = 2. * valLimX / ((double)iNc);
	double valStepY = 2. * valLimY / ((double)iNc);
	double valStepZ = 2. * valLimZ / ((double)iNc);

	double valSum = 0.;
	for (int i = 0; i < iNc; i++) {
		for (int n = 0; n < iNc; n++) {
			for (int k = 0; k < iNc; k++) {
				double arrPos0[3] = {
					0.
				}, arrPos1[3] = {
					0.
				}, arrPos[3] = {
					0.
				};

				arrPos1[0] = -valLimX + (double(i)) * valStepX;
				arrPos1[1] = -valLimY + (double(n)) * valStepY;
				arrPos1[2] = -valLimZ + (double(k)) * valStepZ;

				arrPos0[0] = arrPos1[0] + arrAimPoint0[0];
				arrPos0[1] = arrPos1[1] + arrAimPoint0[1];
				arrPos0[2] = arrPos1[2] + arrAimPoint0[2];

				MtrxMultMatrx(arrVPos, 3, 3, arrPos0, 1, arrPos);

				double valNedolet = ScalProduct(arrPos, &marrMiss[3], 3) / Norm3
					(&marrMiss[3]);
				double valMissSq = Norm3(arrPos) * Norm3(arrPos)
					- valNedolet * valNedolet;
				if (valMissSq < 0.) {
					valMissSq = 0.00001;
				}

				// *pvalDispNedolet +=  valNedolet * valNedolet;
				// *pvalDispMiss += valMissSq;
				double valPCur = TableUZP_2D.calcValue
					(sqrt(valMissSq), valNedolet);
				if (valPCur < 0.) {
					valPCur = 0.;
				}
				double temp = valStepX * valStepY * valStepZ * exp
					(-(arrPos1[0] * arrPos1[0] / arrMtrxLambPos[0] / 2. + arrPos1[1] * arrPos1[1]
						/ arrMtrxLambPos[4] / 2. + arrPos1[2] * arrPos1[2] / arrMtrxLambPos[8] / 2.));
				valSum += valPCur * temp;
				*pvalDispMiss += valMissSq * temp;
				*pvalDispNedolet += valNedolet * valNedolet * temp;

			}
		}
	}

	double temp1 = (2. * M_PI * sqrt(2. * M_PI)) * sqrt
		(arrMtrxLambPos[0] * arrMtrxLambPos[4] * arrMtrxLambPos[8]);
	valSum = valSum / temp1;
	*pvalDestruct = valSum;
	*pvalDispMiss = (*pvalDispMiss) / temp1;
	*pvalDispNedolet = *pvalDispNedolet / temp1;
}

/////////////////////////////
// ----------------------------------------------------------------------------
// -----------------------------------------------------------------------------------
void TNeighbourhoodAppPoint::calcProb_TableUZP_BarrierDeton
	(TTable_2D TableUZP_2D, const double VAlNedolet0, double *pvalDestruct,
	double *pvalDispMiss, double *pvalDispNedolet) {
	// ошибки дисткретизации ВУ
	double arrCorrMtrxDiscret[9] = {
		0.
	};
	calcCorrMtrxDiscretisation_And_CannonDelayT(arrCorrMtrxDiscret);
	//
	//////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////
	// формирование корреляц матриц по разбросу положения и скорости
	double arrPosK[9] = {
		0.
	}, arrVelocityK[9] = {
		0.
	};
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			arrPosK[3 * i + j] = marrCorMatrxMiss[6 * i + j];
			arrVelocityK[3 * i + j] = marrCorMatrxMiss[6 * (i + 3) + j + 3];
		}
	}
	///
	// добавление матрицы дискретизации
	double arrT0[9] = {
		0.
	};
	MtrxSumMatrx(arrCorrMtrxDiscret, arrPosK, 3, 3, arrT0);
	memcpy(arrPosK, arrT0, 9 * sizeof(double));

	///
	double arrVPos[9] = {
		0.
	}, arrMtrxLambPos[9] = {
		0.
	}, arrVVelo[9] = {
		0.
	}, arrMtrxLambVelo[9] = {
		0.
	};
	CalcProperVectors_And_Numbers_R3(arrPosK, arrVPos, arrMtrxLambPos);
	CalcProperVectors_And_Numbers_R3(arrVelocityK, arrVVelo, arrMtrxLambVelo);
	///

	*pvalDestruct = 0.;
	*pvalDispMiss = 0.;
	*pvalDispNedolet = 0.;
	int iNC = 4000;
	for (int i = 0; i < iNC; i++) {
		double arrKsi[3] = {
			0.
		}, arrPsi[3] = {
			0
		}, arrPos[3] = {
			0.
		}, arrVelo[3] = {
			0.
		}, arrTemp[3] = {
			0.
		};
		arrKsi[0] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[0]); ;
		arrKsi[1] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[4]);
		arrKsi[2] = getGauss(0., 1.) * sqrt(arrMtrxLambPos[8]);
		MtrxMultMatrx(arrVPos, 3, 3, arrKsi, 1, arrTemp);
		MtrxSumMatrx(marrMiss, arrTemp, 3, 1, arrPos);

		arrPsi[0] = getGauss(0., 1.) * sqrt(arrMtrxLambVelo[0]);
		arrPsi[1] = getGauss(0., 1.) * sqrt(arrMtrxLambVelo[4]);
		arrPsi[2] = getGauss(0., 1.) * sqrt(arrMtrxLambVelo[8]);
		MtrxMultMatrx(arrVVelo, 3, 3, arrPsi, 1, arrTemp);
		MtrxSumMatrx(&marrMiss[3], arrTemp, 3, 1, arrVelo);

		double temp = ScalProduct(arrPos, arrVelo, 3) / Norm3(arrVelo);
		double valMissSq = Norm3(arrPos) * Norm3(arrPos) - temp * temp;
		double valNedolet = VAlNedolet0 - temp;
		*pvalDispNedolet += temp * temp;
		*pvalDispMiss += valMissSq;
		double valPCur = TableUZP_2D.calcValue(sqrt(valMissSq), valNedolet);
		*pvalDestruct += valPCur;

	}
	*pvalDestruct = (*pvalDestruct) / iNC;
	*pvalDispMiss = *pvalDispMiss / iNC;
	*pvalDispNedolet = *pvalDispNedolet / iNC;

	// double arrCorMtrxCartinSK[4] = {0.}, valDispNedolet = -1.;
	// calcCorrMatrx_CartinPlane(arrCorMtrxCartinSK, &valDispNedolet);
	int iii = 0;
}

// -----------------

// arrCorrMtrxDiscret [9]
void TNeighbourhoodAppPoint::calcCorrMtrxDiscretisation_And_CannonDelayT
	(double *arrCorrMtrxDiscret) {
	// дисперсия ошибки  времени срабатывания
	double valDispT = TProbabilityTheory::calcDispRavnomern
		(mShellBody.mDetonator.marrDetonatorParams[0]) + mSigmaCannonDelayT * mSigmaCannonDelayT +
		mTFly * mShellBody.mDetonator.marrDetonatorParams[1]
		* mTFly * mShellBody.mDetonator.marrDetonatorParams[1] / 36.;

	double arrt[9] = {
		0.
	};
	MtrxMultMatrx(&marrMiss[3], 3, 1, &marrMiss[3], 3, arrt);
	MatrxMultScalar(arrt, 3, 3, valDispT, arrCorrMtrxDiscret);

}

// -----------------------------------------
double TNeighbourhoodAppPoint::calcOmega(double *arrSeaUZP, const int lenarr) {
	double sum = 0.;
	for (int i = 0; i < lenarr; i++) {
		sum += arrSeaUZP[i];
	}
	return(((double)lenarr) + 1. - sum);
}
// ------------------------------------------------

// вычисление     поражения      фугасным    действием
double TNeighbourhoodAppPoint::calcExplosiveProb(double *arrPosOtnKGSK) {

	// 1. радиус фугасного действия
	double valExplRadius = pow(mShellBody.mExplMass, 1. / 3.) * 0.73;
	///

	// 2. перевод координат очки срабатывания в скоростную сиситему координат цели
	double parrMtrxPer[9] = {
		0
	}, arrPosOtnSSK[3] = {
		0.
	};
	calcMatrxPer_from_DecartPrSK_To_SSK(&(mTarget.mTraject.marrVectSostGSK[3]),
		parrMtrxPer);

	MtrxMultMatrx(parrMtrxPer, 3, 3, arrPosOtnKGSK, 1, arrPosOtnSSK);
	///

	// 3. формирование массива указателей на работающие плоские полигоны  цели
	int iarrNumWorkingPlanePolygons[NumMaxQuantPlanePolygons];
	int iNumWorkingPlanePoligons = 0;

	// createPointerArrayForWorkingPlanePoligons(NumMaxQuantPlanePolygons, iarrNumWorkingPlanePolygons, &iNumWorkingPlanePoligons);
	iNumWorkingPlanePoligons = 13;
	for (int i = 0; i < 12; i++) {
		iarrNumWorkingPlanePolygons[i] = i;
	}
	iarrNumWorkingPlanePolygons[12] = 14;

	///

	// 4. вычисление расстояния от иочки  arrPosOtnSSK до каждого из работающих
	// плоских полигонов
	// если расстояние меньше valExplRadius, то цель поражена
	for (int i = 0; i < iNumWorkingPlanePoligons; i++) {
		double valDistanse = mTarget.mpArrPlanePolygon
			[iarrNumWorkingPlanePolygons[i]].calcDistanse(arrPosOtnSSK);
		if (valDistanse < valExplRadius) {
			return 1;
		}
	}

	return 0.;
}

// ---------------------
double TNeighbourhoodAppPoint::sqrt_(const double a) {
	return(a < 0.) ? 0. : sqrt(a);
}
//--------------------------------------------------------------------
bool TNeighbourhoodAppPoint::createTblUzp_For_130Cal_and_MFIVU
	(TTable_3D &TableUZP)
 {
	if (mShellBody.mEnumShellType == CALIBRO_SHTAT_130)
	 {

		if (mTarget.menumTargetType == JET_F16)
		{
			// промах
			double parrUZP_Ca130Shtat_MFIVU_F16_ArgTab1[] = {
				0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 10.1
			};
			int NumUZP_Ca130Shtat_MFIVU_F16_ColsTab1 = 12;

			// дальность
			double parrUZP_Ca130Shtat_MFIVU_F16_ArgTab2[] = {
				5499., 5500., 7882., 10000.
			};
			int NumUZP_Ca130Shtat_MFIVU_F16_ColsTab2 = 4;

			// высота
			double parrUZP_Ca130Shtat_MFIVU_F16_ArgTab3[] = {
				245., 250., 350., 355.
			};
			int NumUZP_Ca130Shtat_MFIVU_F16_ColsTab3 = 4;

			double parrUZP_Ca130Shtat_MFIVU_F16_Val[] =
			 { // высота 245
				 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				//
				// высота 250
				,0, 0, 0, 0, 0, 0, 0, 0,     0,     0,     0,     0
				,1, 1, 1, 1, 1, 1, 1, 0.999, 0.997, 0.993, 0.969, 0
				,1, 1, 1, 1, 1, 1, 1, 1,     0.998, 0.993, 0.982, 0
				,1, 1, 1, 1, 1, 1, 1, 1,     0.998, 0.994, 0.978, 0
				// высота 350
				,0, 0, 0, 0, 0, 0, 0, 0,     0,     0,     0,     0
				,1, 1, 1, 1, 1, 1, 1, 0.999, 0.997, 0.993, 0.969, 0
				,1, 1, 1, 1, 1, 1, 1, 1,     0.998, 0.993, 0.982, 0
				,1, 1, 1, 1, 1, 1, 1, 1,     0.998, 0.994, 0.978, 0

				// высота 355
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				//
			};

			TableUZP = TTable_3D(parrUZP_Ca130Shtat_MFIVU_F16_ArgTab1,
				NumUZP_Ca130Shtat_MFIVU_F16_ColsTab1,
				parrUZP_Ca130Shtat_MFIVU_F16_ArgTab2,
				NumUZP_Ca130Shtat_MFIVU_F16_ColsTab2,
				parrUZP_Ca130Shtat_MFIVU_F16_ArgTab3,
				NumUZP_Ca130Shtat_MFIVU_F16_ColsTab3,
				parrUZP_Ca130Shtat_MFIVU_F16_Val);

			return true;
		}

		if (mTarget.menumTargetType == JET_A_10A)
		{
            	// промах
			double parrUZP_Ca130Shtat_MFIVU_A10A_ArgTab1[] = {
				0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 10.1
			};
			int NumUZP_Ca130Shtat_MFIVU_A10A_ColsTab1 = 12;

			// дальность
			double parrUZP_Ca130Shtat_MFIVU_A10A_ArgTab2[] = {
				5499., 5500., 7882., 10000.
			};
			int NumUZP_Ca130Shtat_MFIVU_A10A_ColsTab2 = 4;

			// высота
			double parrUZP_Ca130Shtat_MFIVU_A10A_ArgTab3[] = {
				245., 250., 350., 355.
			};
			int NumUZP_Ca130Shtat_MFIVU_A10A_ColsTab3 = 4;

			double parrUZP_Ca130Shtat_MFIVU_A10A_Val[] = { // высота 245
				 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				//
				// высота 250
				,0	,0	,0	,0	,    0	,    0	,    0	,    0	,    0	,    0	,    0	,    0
				,1	,1	,1	,1	,    0.952	,0.779	,0.684	,0.641	,0.605	,0.558	,0.508	,0
				,1	,1	,1	,1	    ,0.963	,0.742	,0.706	,0.67	,0.554	,0.499	,0.41	,0
				,1	,1	,1	,0.996	,0.881	,0.79	,0.696	,0.655	,0.507	,0.332	,0.309	,0
				// высота 350
				,0	,0	,0	,0	,    0	,    0	,    0	,    0	,    0	,    0	,    0	,    0
				,1	,1	,1	,1	,    0.952	,0.779	,0.684	,0.641	,0.605	,0.558	,0.508	,0
				,1	,1	,1	,1	    ,0.963	,0.742	,0.706	,0.67	,0.554	,0.499	,0.41	,0
				,1	,1	,1	,0.996	,0.881	,0.79	,0.696	,0.655	,0.507	,0.332	,0.309	,0

				// высота 355
				 ,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				//
			};

			TableUZP = TTable_3D(parrUZP_Ca130Shtat_MFIVU_A10A_ArgTab1,
				NumUZP_Ca130Shtat_MFIVU_A10A_ColsTab1,
				parrUZP_Ca130Shtat_MFIVU_A10A_ArgTab2,
				NumUZP_Ca130Shtat_MFIVU_A10A_ColsTab2,
				parrUZP_Ca130Shtat_MFIVU_A10A_ArgTab3,
				NumUZP_Ca130Shtat_MFIVU_A10A_ColsTab3,
				parrUZP_Ca130Shtat_MFIVU_A10A_Val);

			return true;



		}

		if (mTarget.menumTargetType == GARPUN_V300)
		{


			double parrUZP_Ca130Shtat_MFIVU_Garp300_ArgTab1[] = {
				0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 10.1
			};
			int NumUZP_Ca130Shtat_MFIVU_Garp300_ColsTab1 = 12;

			// дальность
			double parrUZP_Ca130Shtat_MFIVU_Garp300_ArgTab2[] = {
				600., 930., 2342., 4455., 6000.
			};
			int NumUZP_Ca130Shtat_MFIVU_Garp300_ColsTab2 = 5;

			// высота
			double parrUZP_Ca130Shtat_MFIVU_Garp300_ArgTab3[] = {
				245., 250., 350., 355.
			};
			int NumUZP_Ca130Shtat_MFIVU_Garp300_ColsTab3 = 4;

			double parrUZP_Ca130Shtat_MFIVU_Garp300_Val[] = { // высота 245
				 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				//
				// высота 250
				,0, 0      ,0,     0,     0,     0,     0,     0,     0,     0,     0,     0
				,1, 0.9880 ,0.998, 0.898, 0.645, 0.358, 0.245, 0.015, 0.034, 0.009, 0,     0
				,1, 1      ,1,     1,     1,	 0.778, 0.285, 0.235, 0.101, 0.092, 0.067, 0
				,1, 1      ,1,     1,     1,	 0.97,  0.978, 0.724, 0.715, 0.676, 0.566, 0
				,1, 1,      1   ,  1,     1,     0.999, 0.797, 0.715, 0.635, 0.58, 0.574,  0
				// высота 350
				,0, 0      ,0,     0,     0,     0,     0,     0,     0,     0,     0,     0
				,1, 0.9880 ,0.998, 0.898, 0.645, 0.358, 0.245, 0.015, 0.034, 0.009, 0,     0
				,1, 1      ,1,     1,     1,	 0.778, 0.285, 0.235, 0.101, 0.092, 0.067, 0
				,1, 1      ,1,     1,     1,	 0.97,  0.978, 0.724, 0.715, 0.676, 0.566, 0
				,1, 1,      1   ,  1,     1,     0.999, 0.797, 0.715, 0.635, 0.58, 0.574,  0
				// высота 355
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0.	,0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0.	,0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.	,0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				//
			};

			TableUZP = TTable_3D(parrUZP_Ca130Shtat_MFIVU_Garp300_ArgTab1,
				NumUZP_Ca130Shtat_MFIVU_Garp300_ColsTab1,
				parrUZP_Ca130Shtat_MFIVU_Garp300_ArgTab2,
				NumUZP_Ca130Shtat_MFIVU_Garp300_ColsTab2,
				parrUZP_Ca130Shtat_MFIVU_Garp300_ArgTab3,
				NumUZP_Ca130Shtat_MFIVU_Garp300_ColsTab3,
				parrUZP_Ca130Shtat_MFIVU_Garp300_Val);
			return true;
		}

		if (mTarget.menumTargetType == GARPUN_V700) {
			// промах
			double parrUZP_Ca130Shtat_MFIVU_Garp700_ArgTab1[] = {
				0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.
			};
			int NumUZP_Ca130Shtat_MFIVU_Garp700_ColsTab1 = 11;

			// дальность
			double parrUZP_Ca130Shtat_MFIVU_Garp700_ArgTab2[] = {
				600., 930., 2000., 6000.
			};
			int NumUZP_Ca130Shtat_MFIVU_Garp700_ColsTab2 = 4;

			// высота
			double parrUZP_Ca130Shtat_MFIVU_Garp700_ArgTab3[] = {
				245., 250., 350., 355.
			};
			int NumUZP_Ca130Shtat_MFIVU_Garp700_ColsTab3 = 4;

			double parrUZP_Ca130Shtat_MFIVU_Garp700_Val[] = { // высота 245
				 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				//
				// высота 250
				,0., 0., 0.,    0.,    0.,    0.,    0.,    0.,    0.,    0.,    0.
				,1., 1,  0.997, 0.739, 0.806, 0.455, 0.274, 0.108, 0.,    0.,    0.
				,1., 1,  1,     1,     0.993, 1,     0.481, 0.104, 0.035, 0.,    0.
				,1., 1,  1,     1,     1,     0.967, 0.9,   0.755, 0.597, 0.095, 0.
				// высота 350
				,0., 0., 0.,    0.,    0.,    0.,    0.,    0.,    0.,    0.,    0.
				,1., 1,  0.997, 0.739, 0.806, 0.455, 0.274, 0.108, 0.,    0.,    0.
				,1., 1,  1,     1,     0.993, 1,     0.481, 0.104, 0.035, 0.,    0.
				,1., 1,  1,     1,     1,     0.967, 0.9,   0.755, 0.597, 0.095, 0.
				// высота 355
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				//
			};

			TableUZP = TTable_3D(parrUZP_Ca130Shtat_MFIVU_Garp700_ArgTab1,
				NumUZP_Ca130Shtat_MFIVU_Garp700_ColsTab1,
				parrUZP_Ca130Shtat_MFIVU_Garp700_ArgTab2,
				NumUZP_Ca130Shtat_MFIVU_Garp700_ColsTab2,
				parrUZP_Ca130Shtat_MFIVU_Garp700_ArgTab3,
				NumUZP_Ca130Shtat_MFIVU_Garp700_ColsTab3,
				parrUZP_Ca130Shtat_MFIVU_Garp700_Val);
			return true;

		}
		return false;
	}

	///
	if (mShellBody.mEnumShellType == CALIBRO_TARAN_130) {

		if (mTarget.menumTargetType == JET_F16)
		{
			// промах
			double parrUZP_Ca130Modern_MFIVU_F16_ArgTab1[] = {
				0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 10.1
			};
			int NumUZP_Ca130Modern_MFIVU_F16_ColsTab1 = 12;

			// дальность
			double parrUZP_Ca130Modern_MFIVU_F16_ArgTab2[] = {
				5499., 5500., 7882., 10000.
			};
			int NumUZP_Ca130Modern_MFIVU_F16_ColsTab2 = 4;

			// высота
			double parrUZP_Ca130Modern_MFIVU_F16_ArgTab3[] = {
				245., 250., 350., 355.
			};
			int NumUZP_Ca130Modern_MFIVU_F16_ColsTab3 = 4;

			double parrUZP_Ca130Modern_MFIVU_F16_Val[] = { // высота 245
				 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0.,0., 0., 0.,  0., 0., 0.,  0., 0
				,0., 0., 0., 0., 0., 0., 0., 0.	,0., 0.,  0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				//
				// высота 250
				,0	,0	,0	,0	,0	,0	,0	,0	,0	,0	    ,0	    ,0
				,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	    ,1	    ,0
				,1	,1	,1	,1	,1	,1	,1	,1	,1	,1   	,0.998	,0
				,1	,1	,1	,1	,1	,1	,1	,1	,1	,0.994	,0.994	,0
				// высота 350
				,0	,0	,0	,0	,0	,0	,0	,0	,0	,0	    ,0	    ,0
				,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	    ,1	    ,0
				,1	,1	,1	,1	,1	,1	,1	,1	,1	,1   	,0.998	,0
				,1	,1	,1	,1	,1	,1	,1	,1	,1	,0.994	,0.994	,0

				// высота 355
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0.,0., 0., 0., 0.,  0., 0.,  0., 0
				,0., 0., 0., 0., 0., 0., 0., 0.	,0., 0.,  0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				//
			};

			TableUZP = TTable_3D(parrUZP_Ca130Modern_MFIVU_F16_ArgTab1,
				NumUZP_Ca130Modern_MFIVU_F16_ColsTab1,
				parrUZP_Ca130Modern_MFIVU_F16_ArgTab2,
				NumUZP_Ca130Modern_MFIVU_F16_ColsTab2,
				parrUZP_Ca130Modern_MFIVU_F16_ArgTab3,
				NumUZP_Ca130Modern_MFIVU_F16_ColsTab3,
				parrUZP_Ca130Modern_MFIVU_F16_Val);

			return true;
		}

		if (mTarget.menumTargetType == JET_A_10A)
		{
			  	// промах
			double parrUZP_Ca130Modern_MFIVU_A10A_ArgTab1[] = {
				0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 10.1
			};
			int NumUZP_Ca130Modern_MFIVU_A10A_ColsTab1 = 12;

			// дальность
			double parrUZP_Ca130Modern_MFIVU_A10A_ArgTab2[] = {
				5499., 5500., 7882., 10000.
			};
			int NumUZP_Ca130Modern_MFIVU_A10A_ColsTab2 = 4;

			// высота
			double parrUZP_Ca130Modern_MFIVU_A10A_ArgTab3[] = {
				245., 250., 350., 355.
			};
			int NumUZP_Ca130Modern_MFIVU_A10A_ColsTab3 = 4;

			double parrUZP_Ca130Modern_MFIVU_A10A_Val[] = { // высота 245
				 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				//
				// высота 250
				,0	,0	,0	,0, 0, 0,  0,     0	,    0	,    0	,    0	,    0
				,1	,1	,1	,1, 1, 1,  0.98,  0.953	,0.749	,0.66	,0.659	,0
				,1	,1	,1	,1 ,1 ,1  ,0.999 ,0.891	,0.767	,0.657	,0.607	,0
				,1	,1	,1	,1,	1, 1,  0.962 ,0.831	,0.703	,0.633	,0.521	,0
				// высота 350
				,0	,0	,0	,0, 0, 0,  0,     0	,    0	,    0	,    0	,    0
				,1	,1	,1	,1, 1, 1,  0.98,  0.953	,0.749	,0.66	,0.659	,0
				,1	,1	,1	,1 ,1 ,1  ,0.999 ,0.891	,0.767	,0.657	,0.607	,0
				,1	,1	,1	,1,	1, 1,  0.962 ,0.831	,0.703	,0.633	,0.521	,0

				// высота 355
				 ,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0
				//
			};

			TableUZP = TTable_3D(parrUZP_Ca130Modern_MFIVU_A10A_ArgTab1,
				NumUZP_Ca130Modern_MFIVU_A10A_ColsTab1,
				parrUZP_Ca130Modern_MFIVU_A10A_ArgTab2,
				NumUZP_Ca130Modern_MFIVU_A10A_ColsTab2,
				parrUZP_Ca130Modern_MFIVU_A10A_ArgTab3,
				NumUZP_Ca130Modern_MFIVU_A10A_ColsTab3,
				parrUZP_Ca130Modern_MFIVU_A10A_Val);

			return true;
		}

		if (mTarget.menumTargetType == GARPUN_V300)
		 {
			 double parrUZP_Ca130ModernMFIVU_Garp300_ArgTab1[] = {0.,1.,2.,3.,4.,5.,6.,7.,8.,9.,10.,10.1
			};
			int NumUZP_Ca130ModernMFIVU_Garp300_ColsTab1 = 12;

			// дальность
			double parrUZP_Ca130ModernMFIVU_Garp300_ArgTab2[] = {600., 930.,2342.,4455.,6000.
			};
			int NumUZP_Ca130ModernMFIVU_Garp300_ColsTab2 = 5;

			// высота
			double parrUZP_Ca130ModernMFIVU_Garp300_ArgTab3[] = {245., 250.,350.,355.
			};
			int NumUZP_Ca130ModernMFIVU_Garp300_ColsTab3 =  4;


			double parrUZP_Ca130ModernMFIVU_Garp300_Val[] = {  // высота 245
			 0., 0., 0.,0.,0.,0.,0., 0., 0.,0.,0.,0.
			,0., 0., 0.,0.,0.,0.,0., 0., 0.,0.,0.,0.
			,0., 0., 0.,0.,0.,0.,0., 0., 0.,0.,0.,0.
			,0., 0., 0.,0.,0.,0.,0., 0., 0.,0.,0.,0.
			,0., 0., 0.,0.,0.,0.,0., 0., 0.,0.,0.,0.
			//
			// высота 250
			,0	,0	,0	,0	,0	,0	    ,0   	,0	    ,0      ,0      ,0      ,0
			,1	,1	,1	,1	,1	,0.945	,0.707	,0.601	,0.507	,0.303	,0.1	,0
			,1	,1	,1	,1	,1	,1	    ,1  	,0.77	,0.764	,0.688	,0.601	,0
			,1	,1	,1	,1	,1	,1	    ,1   	,1  	,1  	,0.793	,0.69	,0
			,1	,1	,1	,1	,1	,1	    ,1      ,0.944	,0.891	,0.801	,0.711	,0
			// высота 350
			,0	,0	,0	,0	,0	,0	    ,0   	,0	    ,0      ,0      ,0      ,0
			,1	,1	,1	,1	,1	,0.945	,0.707	,0.601	,0.507	,0.303	,0.1	,0
			,1	,1	,1	,1	,1	,1	    ,1  	,0.77	,0.764	,0.688	,0.601	,0
			,1	,1	,1	,1	,1	,1	    ,1   	,1  	,1  	,0.793	,0.69	,0
			,1	,1	,1	,1	,1	,1	    ,1      ,0.944	,0.891	,0.801	,0.711	,0
			// высота 355
			,0., 0., 0.,0.,0.,0.,0., 0., 0.,0.,0.,0.
			,0., 0., 0.,0.,0.,0.,0., 0., 0.,0.,0.,0.
			,0., 0., 0.,0.,0.,0.,0., 0., 0.,0.,0.,0.
			,0., 0., 0.,0.,0.,0.,0., 0., 0.,0.,0.,0.
			,0., 0., 0.,0.,0.,0.,0., 0., 0.,0.,0.,0.
			//
			};


			TableUZP = TTable_3D ( parrUZP_Ca130ModernMFIVU_Garp300_ArgTab1
			,  NumUZP_Ca130ModernMFIVU_Garp300_ColsTab1, parrUZP_Ca130ModernMFIVU_Garp300_ArgTab2
			,  NumUZP_Ca130ModernMFIVU_Garp300_ColsTab2,parrUZP_Ca130ModernMFIVU_Garp300_ArgTab3
			,  NumUZP_Ca130ModernMFIVU_Garp300_ColsTab3, parrUZP_Ca130ModernMFIVU_Garp300_Val ) ;
			return true;
		}

		if (mTarget.menumTargetType == GARPUN_V700)
		 {
			double parrUZP_Ca130ModernMFIVU_Garp700_ArgTab1[] = {
				0., 1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 10.1
			};
			int NumUZP_Ca130ModernMFIVU_Garp700_ColsTab1 = 12;

			// дальность
			double parrUZP_Ca130ModernMFIVU_Garp700_ArgTab2[] = {
				600., 930., 2000., 6000.
			};
			int NumUZP_Ca130ModernMFIVU_Garp700_ColsTab2 = 4;

			// высота
			double parrUZP_Ca130ModernMFIVU_Garp700_ArgTab3[] = {
				245., 250., 350., 355.
			};
			int NumUZP_Ca130ModernMFIVU_Garp700_ColsTab3 = 4;

			double parrUZP_Ca130ModernMFIVU_Garp700_Val[] = { // высота 245
				 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				//
				// высота 250
				,0, 0, 0, 0, 0, 0, 0,     0,     0,     0,     0,     0
				,1, 1, 1, 1, 1, 1, 0.908, 0.7,   0.651, 0.642, 0.481, 0
				,1, 1, 1, 1, 1, 1, 1,     0.972, 0.946,	0.777, 0.621, 0
				,1, 1, 1, 1, 1, 1, 1,     1,     1,     1,     1,     0
				// высота 350
				,0, 0, 0, 0, 0, 0, 0,     0,     0,     0,     0,     0
				,1, 1, 1, 1, 1, 1, 0.908, 0.7,   0.651, 0.642, 0.481, 0
				,1, 1, 1, 1, 1, 1, 1,     0.972, 0.946,	0.777, 0.621, 0
				,1, 1, 1, 1, 1, 1, 1,     1,     1,     1,     1,     0


				// высота 355
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				,0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.
				//
			};

			TableUZP = TTable_3D(parrUZP_Ca130ModernMFIVU_Garp700_ArgTab1,
				NumUZP_Ca130ModernMFIVU_Garp700_ColsTab1,
				parrUZP_Ca130ModernMFIVU_Garp700_ArgTab2,
				NumUZP_Ca130ModernMFIVU_Garp700_ColsTab2,
				parrUZP_Ca130ModernMFIVU_Garp700_ArgTab3,
				NumUZP_Ca130ModernMFIVU_Garp700_ColsTab3,
				parrUZP_Ca130ModernMFIVU_Garp700_Val);
			return true;
		}
		return false;
	}

}


TTable_2D  TNeighbourhoodAppPoint::createTblUZP_130CAL_MFIVU_SEATARG()
{

// 1. ТАблица УЗП для эсминца для МФИВУ 130 Cal штат

double arrDestrUZP_130CalShtat_Destr_MFIVU[71*5] = {
0.085	,0.18	,0.244	,0.302	,0.368	,0.412	,0.467	,0.516	,0.549	,0.594	,0.628	,0.655	,0.677	,0.696	,0.725	,0.74	,0.751	,0.767	,0.778	,0.792	,0.803	,0.815	,0.821	,0.831	,0.842	,0.849	,0.858	,0.862	,0.869	,0.873	,0.874	,0.878	,0.884	,0.886	,0.892	,0.894	,0.897	,0.898	,0.899	,0.904	,0.904	,0.904	,0.905	,0.907	,0.907	,0.907	,0.912	,0.917	,0.918	,0.92	,0.92	,0.922	,0.925	,0.929	,0.931	,0.932	,0.935	,0.936	,0.937	,0.94	,0.942	,0.944	,0.946	,0.947	,0.948	,0.949	,0.952	,0.953	,0.953	,0.954	,0.954
,0.102	,0.193	,0.288	,0.36	,0.443	,0.52	,0.573	,0.613	,0.661	,0.718	,0.755	,0.783	,0.802	,0.83	,0.847	,0.866	,0.877	,0.882	,0.899	,0.908	,0.913	,0.924	,0.934	,0.943	,0.944	,0.947	,0.949	,0.954	,0.957	,0.959	,0.962	,0.963	,0.965	,0.966	,0.968	,0.968	,0.968	,0.969	,0.97	,0.97	,0.974	,0.975	,0.976	,0.978	,0.979	,0.979	,0.982	,0.982	,0.982	,0.982	,0.982	,0.983	,0.983	,0.984	,0.985	,0.985	,0.985	,0.987	,0.987	,0.989	,0.991	,0.991	,0.992	,0.992	,0.992	,0.993	,0.994	,0.994	,0.994	,0.994	,0.994
,0.054	,0.108	,0.167	,0.242	,0.289	,0.341	,0.385	,0.437	,0.469	,0.522	,0.555	,0.594	,0.623	,0.656	,0.684	,0.713	,0.74	,0.761	,0.784	,0.8	,0.806	,0.82	,0.836	,0.845	,0.854	,0.865	,0.873	,0.882	,0.892	,0.901	,0.912	,0.917	,0.93	,0.937	,0.941	,0.944	,0.948	,0.953	,0.955	,0.958	,0.958	,0.961	,0.963	,0.963	,0.965	,0.967	,0.969	,0.972	,0.972	,0.977	,0.978	,0.981	,0.981	,0.982	,0.982	,0.982	,0.983	,0.983	,0.983	,0.983	,0.984	,0.984	,0.986	,0.987	,0.99	,0.992	,0.993	,0.994	,0.994	,0.994	,0.994
,0.061	,0.117	,0.188	,0.242	,0.299	,0.346	,0.404	,0.456	,0.52	,0.565	,0.606	,0.647	,0.68	,0.719	,0.743	,0.772	,0.791	,0.808	,0.831	,0.851	,0.862	,0.884	,0.898	,0.909	,0.927	,0.936	,0.944	,0.949	,0.958	,0.963	,0.971	,0.972	,0.975	,0.978	,0.982	,0.982	,0.983	,0.984	,0.986	,0.987	,0.988	,0.99	,0.991	,0.992	,0.992	,0.993	,0.994	,0.994	,0.996	,0.997	,0.997	,0.998	,0.998	,0.998	,0.999	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1
,0.049	,0.105	,0.166	,0.238	,0.276	,0.344	,0.401	,0.452	,0.502	,0.56	,0.6	,0.641	,0.673	,0.71	,0.745	,0.781	,0.797	,0.819	,0.835	,0.855	,0.869	,0.88	,0.891	,0.906	,0.915	,0.928	,0.935	,0.939	,0.949	,0.957	,0.961	,0.963	,0.965	,0.97	,0.972	,0.976	,0.982	,0.984	,0.987	,0.989	,0.99	,0.99	,0.991	,0.994	,0.994	,0.995	,0.996	,0.997	,0.998	,0.998	,0.998	,0.998	,0.998	,0.998	,0.999	,0.999	,0.999	,0.999	,0.999	,0.999	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1


};

const int NumColsTab2_DestrUZP = 5;
double arrArgTab2_DestrUZP[] = {
	7000., 10000., 14000., 16000., 18000.
};
const int NumColsTab1_DestrUZP = 71;
double arrArgTab1_DestrUZP[71*5] = {
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
	22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
	41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
	60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71
};
TTable_2D TableUZP_130CalShtat_Destr_MFIVU(arrArgTab1_DestrUZP, NumColsTab1_DestrUZP,
	arrArgTab2_DestrUZP, NumColsTab2_DestrUZP, arrDestrUZP_130CalShtat_Destr_MFIVU);
///


// 2. ТАблица УЗП для эсминца для МФИВУ 130 Cal модеониз

double arrDestrUZP_130CalModern_Destr_MFIVU[71*5] = {
0.129	,0.235	,0.305	,0.376	,0.452	,0.506	,0.554	,0.6	,0.632	,0.663	,0.707	,0.732	,0.755	,0.772	,0.783	,0.803	,0.818	,0.826	,0.835	,0.845	,0.852	,0.858	,0.867	,0.871	,0.876	,0.884	,0.892	,0.897	,0.902	,0.905	,0.909	,0.91	,0.915	,0.916	,0.917	,0.92	,0.921	,0.923	,0.925	,0.926	,0.929	,0.93	,0.933	,0.934	,0.936	,0.936	,0.938	,0.94	,0.941	,0.941	,0.943	,0.943	,0.944	,0.948	,0.949	,0.949	,0.951	,0.952	,0.952	,0.952	,0.954	,0.955	,0.957	,0.959	,0.959	,0.959	,0.959	,0.96	,0.961	,0.962	,0.963
,0.108	,0.208	,0.315	,0.416	,0.482	,0.551	,0.621	,0.674	,0.719	,0.757	,0.781	,0.813	,0.837	,0.858	,0.873	,0.888	,0.903	,0.911	,0.922	,0.93	,0.936	,0.943	,0.946	,0.955	,0.96	,0.963	,0.967	,0.97	,0.974	,0.976	,0.98	,0.981	,0.985	,0.987	,0.988	,0.99	,0.99	,0.99	,0.991	,0.993	,0.993	,0.993	,0.994	,0.994	,0.995	,0.995	,0.995	,0.996	,0.996	,0.996	,0.997	,0.997	,0.998	,0.998	,0.998	,0.998	,0.998	,0.998	,0.998	,0.999	,0.999	,0.999	,0.999	,0.999	,1	,1	,1	,1	,1	,1	,1
,0.072	,0.151	,0.215	,0.277	,0.331	,0.393	,0.455	,0.499	,0.544	,0.591	,0.625	,0.661	,0.683	,0.713	,0.738	,0.771	,0.797	,0.814	,0.837	,0.85	,0.861	,0.877	,0.895	,0.902	,0.914	,0.921	,0.927	,0.936	,0.94	,0.942	,0.945	,0.951	,0.959	,0.964	,0.965	,0.966	,0.971	,0.976	,0.977	,0.978	,0.981	,0.984	,0.984	,0.986	,0.987	,0.987	,0.989	,0.989	,0.99	,0.993	,0.993	,0.994	,0.994	,0.994	,0.995	,0.995	,0.995	,0.995	,0.996	,0.996	,0.996	,0.996	,0.996	,0.996	,0.997	,0.997	,0.997	,0.998	,0.998	,0.998	,0.998
,0.068	,0.157	,0.234	,0.288	,0.345	,0.42	,0.482	,0.54	,0.593	,0.638	,0.677	,0.727	,0.771	,0.804	,0.837	,0.867	,0.884	,0.894	,0.914	,0.927	,0.936	,0.945	,0.955	,0.96	,0.966	,0.968	,0.972	,0.976	,0.978	,0.979	,0.981	,0.989	,0.99	,0.992	,0.994	,0.994	,0.996	,0.996	,0.998	,0.999	,0.999	,0.999	,0.999	,0.999	,0.999	,0.999	,0.999	,0.999	,0.999	,0.999	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1
,0.065	,0.13	,0.201	,0.276	,0.332	,0.395	,0.473	,0.536	,0.586	,0.633	,0.678	,0.718	,0.762	,0.791	,0.816	,0.841	,0.861	,0.881	,0.891	,0.903	,0.919	,0.929	,0.94	,0.946	,0.95	,0.957	,0.968	,0.973	,0.976	,0.98	,0.985	,0.988	,0.992	,0.993	,0.993	,0.993	,0.996	,0.996	,0.998	,0.998	,0.998	,0.998	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1	,1



};


TTable_2D TableUZP_130CalModern_Destr_MFIVU(arrArgTab1_DestrUZP, NumColsTab1_DestrUZP,
	arrArgTab2_DestrUZP, NumColsTab2_DestrUZP, arrDestrUZP_130CalModern_Destr_MFIVU);
///




// 3. ТАблица УЗП для катреа для МФИВУ кал 130,штат


double arrCutterUZP_Cal130Shtat_MFIVU[17 *3] = {
0.319	,0.542	,0.691	,0.797	,0.871	,0.915	,0.945	,0.964	,0.978	,0.986	,0.992	,1.	,1.,	1.	,1.	,1.	,1.
,0.279	,0.485	,0.632	,0.741	,0.818	,0.874	,0.916	,0.944	,0.962	,0.975	,0.983	,0.989	,0.993	,0.996	,1.	,1.	,1.
,0.237	,0.422	,0.563	,0.668	,0.750	,0.812	,0.863	,0.899	,0.926	,0.948	,0.962	,0.974	,0.983	,0.989	,0.992	,0.995	,1.
};

const int NumColsTab2_CutterUZP = 3;
double arrArgTab2_CutterUZP[] = {
	7000., 10000., 14000.
};
const int NumColsTab1_CutterUZP = 17;
double arrArgTab1_CutterUZP[] = {
	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17
};
TTable_2D TableUZP_Cal130Shtat_MFIVU_Cutter(arrArgTab1_CutterUZP, NumColsTab1_CutterUZP,
	arrArgTab2_CutterUZP, NumColsTab2_CutterUZP, arrCutterUZP_Cal130Shtat_MFIVU);

// ТАблица УЗП для катреа для МФИВУ кал 130,модерн


double arrCutterUZP_Cal130Modern_MFIVU[17 *3] = {
0.416	,0.661	,0.804	,0.889	,0.939	,0.968	,0.983	,0.99	,0.995	,0.997	,0.998	,1	,1	,1	,1	,1	,1
,0.375	,0.613	,0.767	,0.855	,0.914	,0.947	,0.968	,0.981	,0.988	,0.993	,0.996	,0.998	,1	,1	,1	,1	,1
,0.325	,0.54	,0.691	,0.793	,0.862	,0.911	,0.942	,0.961	,0.977	,0.986	,0.991	,0.995	,1	,1	,1	,1	,1

};


TTable_2D TableUZP_Cal130Modern_MFIVU_Cutter(arrArgTab1_CutterUZP, NumColsTab1_CutterUZP,
	arrArgTab2_CutterUZP, NumColsTab2_CutterUZP, arrCutterUZP_Cal130Modern_MFIVU);

switch (mTarget.menumTargetType)
{
case DESTROYER:
  switch( mShellBody.mEnumShellType)
  {
	case CALIBRO_SHTAT_130:
	return TableUZP_130CalShtat_Destr_MFIVU;
	break;

	case CALIBRO_TARAN_130:
	 return TableUZP_130CalModern_Destr_MFIVU;
	break;

	default:
	ShowMessage( L"ERROR_IN_SHELL_BODY_TYPE");
	break;
  };

break;

case MOTORBOAT:

switch( mShellBody.mEnumShellType)
  {
	case CALIBRO_SHTAT_130:
	return TableUZP_Cal130Shtat_MFIVU_Cutter;
	break;

	case CALIBRO_TARAN_130:
     return TableUZP_Cal130Modern_MFIVU_Cutter;
	break;

	default:
	ShowMessage( L"ERROR_IN_SHELL_BODY_TYPE");
	break;
  };

break ;
default:
ShowMessage(L"ERROR_IN_TARG_TYPE");
   break ;
}
return TTable_2D();
}


//----------------------------------------------------------------
// вычисление радиуса поражения для береговой цели
double TNeighbourhoodAppPoint::calcKillingRange_130Cal_MFIVU_For_CoastTargs(const enumShellType EnShell
   , const enumDetonatorType  EnDetonatorType, const enumTargetType EnTargetType
   , const double ValDist, const double ValElev)
{

	if (!(
	 (EnTargetType == OPEN_MANPOWER_LIE)||(EnTargetType == OPEN_MANPOWER_STAND)
	 || (EnTargetType ==BULLET_PROOF_LIE)||(EnTargetType == BULLET_PROOF_STAND)
	 || (EnTargetType == COVERED_MANPOWER_ENTRENCH)||(EnTargetType == COVERED_MANPOWER_TRENCH)
	 || (EnTargetType ==MANPOWER_ARMOURED_CARRIER)||(EnTargetType == MANPOWER_CAR)
	 || (EnTargetType == PLATOON_POINT)
	 ))
	{
	  ShowMessage(L"ERROR_INP_DATA_calcKillingRange_130Cal_MFIVU_For_CoastTargs");
	  return -1.;
	}
  double valKillingRange = -1.;
	 if (EnDetonatorType == D4MRM )
	 {
			valKillingRange = sqrt( VAl_YZP_ForOpenManPower_Calibro130 /M_PI);
			if(EnShell == CALIBRO_100)
			{
			valKillingRange  = sqrt( VAl_YZP_ForOpenManPower_Calibro100 /M_PI);
			}
	 }
	 TTable_2D tableUZP;

	 if (EnDetonatorType == MFIVU )
	 {
	  if(EnShell == CALIBRO_SHTAT_130)
	  {
		switch( EnTargetType)
		{
		case OPEN_MANPOWER_LIE:   // лежа

		break;

		case OPEN_MANPOWER_STAND:     //стоя

		break;

		case BULLET_PROOF_LIE:     //  бж лежа

		break;

		case  BULLET_PROOF_STAND:  //   бж стоя

		break;

		case  COVERED_MANPOWER_ENTRENCH:    // окоп

		break;

		case  COVERED_MANPOWER_TRENCH:      //  траншея

		break;

		case MANPOWER_ARMOURED_CARRIER:      //   бтр

		break;

		case  MANPOWER_CAR:     //      ам

		break;

		case PLATOON_POINT:        //  взвод кп

		break;

		default:
		break;
		);

	  }  // end switch

	} // end if(EnShell == CALIBRO_SHTAT_130)

	 if(EnShell == CALIBRO_TARAN_130)
	  {
		switch( EnTargetType)
		{
		case OPEN_MANPOWER_LIE:   // лежа

		break;

		case OPEN_MANPOWER_STAND:     //стоя

		break;

		case BULLET_PROOF_LIE:     //  бж лежа

		break;

		case  BULLET_PROOF_STAND:  //   бж стоя

		break;

		case  COVERED_MANPOWER_ENTRENCH:    // окоп

		break;

		case  COVERED_MANPOWER_TRENCH:      //  траншея

		break;

		case MANPOWER_ARMOURED_CARRIER:      //   бтр

		break;

		case  MANPOWER_CAR:     //      ам

		break;

		case PLATOON_POINT:        //  взвод кп

		break;

		default:
		break;
		);

	  }  // end switch

	} // end if(EnShell == CALIBRO_TARAN_130)
		int index =  ( ComboBox3->ItemIndex) * 12 +  ( ComboBox5->ItemIndex)  * 4 +   ComboBox4->ItemIndex  ;
		mKillingRange =  sqrt(arrSPrived[index]/M_PI);
   }
return tableUZP.calcValue(ValDist, ValElev);
}

#pragma package(smart_init)
