//---------------------------------------------------------------------------


#pragma hdrstop

#include "LearnShellBody.h"

#include <string.h>
#include <math.h>
#include "Atmosphere.h"
#include "UrPointXY.h"
#include "URPolyLine.h"
#include "Constants.h"

// ТАБЛИЦА CxEtal
double arrTabCxEtal58[47] = {
		0.305,                             0.305,0.308,0.317,0.333,0.372
	   ,0.540,0.616, 0.619, 0.606,  0.581, 0.558,0.539,0.522,0.507,0.491
	   ,0.478,0.465, 0.452, 0.440,  0.428, 0.417,0.407,0.396,0.386,0.377
	   ,0.369,0.362, 0.354, 0.347,  0.339, 0.332,0.326,0.320,0.314,0.309
	   ,0.303,0.297, 0.291, 0.285,  0.280, 0.274,0.269,0.264,0.260,0.258
	   ,0.256
};

 double arrTabCxEtal43[47] = {
		0.157             ,0.157,0.157,0.157, 0.159,0.184
	   ,0.323,0.377,0.384,0.380,0.371,0.362,0.351,0.342,0.332,0.324
	   ,0.317,0.310,0.303,0.297,0.292,0.288,0.284,0.280,0.277,0.274
	   ,0.271,0.268,0.266,0.264,0.263,0.262,0.262,0.261,0.261,0.260
	   ,0.260,0.260,0.260,0.260,0.260,0.260,0.260,0.260,0.260,0.260
	   ,0.260
};
 double arrArgTabCxEtal[47]= {
	0.,                 0.5,0.6,0.7,0.8,0.9
	,1.,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9
	,2.,2.1, 2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9
	,3.,3.1,3.2,3.3,3.4,3.5,3.6,3.7,3.8,3.9
	,4.,4.1,4.2,4.3,4.4,4.5,4.6,4.7,4.8,4.9
	,5.
}  ;
 extern TURPolyLine PLN_CxEtal( arrArgTabCxEtal, arrTabCxEtal43, 47);
// ТАБЛИЦА Knm
 double arrTabKnm[47] = {
		0.206,            0.206,0.206,0.206,0.204, 0.197
	   ,0.190,0.86,0.187,0.196,0.205,0.213,0.221,0.230,0.239,0.248
	   ,0.257,0.266,0.274,0.282,0.289,0.296,0.303,0.310,0.316,0.320
	   ,0.324,0.328,0.332,0.335,0.338,0.341,0.344,0.347,0.350,0.353
	   ,0.355,0.358,0.360,0.362,0.364,0.365,0.366,0.368,0.369,0.370
	   ,0.370

};
 double arrArgTabKnm[47]= {
	0.,                 0.5,0.6,0.7,0.8,0.9
	,1.,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9
	,2.,2.1, 2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9
	,3.,3.1,3.2,3.3,3.4,3.5,3.6,3.7,3.8,3.9
	,4.,4.1,4.2,4.3,4.4,4.5,4.6,4.7,4.8,4.9
	,5.
}  ;
 extern const TURPolyLine PLN_Knm( arrArgTabKnm, arrTabKnm, 47);

// результаты аппроксимации коэффициентов Cx для 76
 const int NUmPointsCx_76 = 47;

  double ARrCx_76[] ={

0.000000 , 0.157000
, 0.500000 , 0.157000
, 0.600000 , 0.157000
, 0.700000 , 0.150000
, 0.800000 , 0.147721
, 0.900000 , 0.186866
, 1.000000 , 0.319760
, 1.100000 , 0.353685
, 1.200000 , 0.445927
, 1.300000 , 0.433717
, 1.400000 , 0.413099
, 1.500000 , 0.424427
, 1.600000 , 0.399684
, 1.700000 , 0.382428
, 1.800000 , 0.379230
, 1.900000 , 0.334044
, 2.000000 , 0.319637
, 2.100000 , 0.320354
, 2.200000 , 0.311231
, 2.300000 , 0.302466
, 2.400000 , 0.300999
, 2.500000 , 0.299126
, 2.600000 , 0.311995
, 2.700000 , 0.309792
, 2.800000 , 0.381626
, 2.900000 , 0.354908
, 3.000000 , 0.271000
, 3.100000 , 0.268000
, 3.200000 , 0.266000
, 3.300000 , 0.264000
, 3.400000 , 0.263000
, 3.500000 , 0.262000
, 3.600000 , 0.262000
, 3.700000 , 0.261000
, 3.800000 , 0.261000
, 3.900000 , 0.260000
, 4.000000 , 0.260000
, 4.100000 , 0.260000
, 4.200000 , 0.260000
, 4.300000 , 0.260000
, 4.400000 , 0.260000
, 4.500000 , 0.260000
, 4.600000 , 0.260000
, 4.700000 , 0.260000
, 4.800000 , 0.260000
, 4.900000 , 0.260000
, 5.000000 , 0.260000

  };

 extern const TURPolyLine PLN_Cx_76(ARrCx_76, NUmPointsCx_76);
 ///
 // результаты аппроксимации коэффициентов mxOmx для 76

  const int NUmPointsMxOmx_76 =  31 ;
 double ARrMxOmx_76[] ={
0.000000 , 0.000000
, 0.400000 , 0.000700
, 0.500000 , 0.000700
, 0.600000 , 0.000600
, 0.700000 , 0.000600
, 0.800000 , 0.029313
, 0.900000 , 0.013329
, 0.950000 , 0.018621
, 1.000000 , 0.024469
, 1.050000 , 0.030260
, 1.100000 , 0.032691
, 1.150000 , 0.043624
, 1.200000 , 0.029955
, 1.300000 , 0.024102
, 1.400000 , 0.025215
, 1.500000 , 0.026072
, 1.600000 , 0.034682
, 1.700000 , 0.035505
, 1.800000 , 0.036155
, 1.900000 , 0.045920
, 2.000000 , 0.046728
, 2.100000 , 0.057772
, 2.200000 , 0.058475
, 2.300000 , 0.070768
, 2.400000 , 0.084441
, 2.500000 , 0.099862
, 2.600000 , 0.115039
, 2.700000 , 0.134965
, 2.800000 , 0.141781
, 2.900000 , 0.145
, 3.000000 , 0.000300
 };
 extern  const TURPolyLine PLN_MxOmx_76(ARrMxOmx_76, NUmPointsMxOmx_76);
 ///


 // результаты аппроксимации коэффициентов Knm для 76
  const int NUmPointsKnm_76 =47 ;
double ARrKnm_76[] = {
0.000000 , 0.206000
, 0.500000 , 0.206000
, 0.600000 , 0.206000
, 0.700000 , 0.206000
, 0.800000 , 0.204000
, 0.900000 , 0.197000
, 1.000000 , 0.190000
, 1.100000 , 0.860000
, 1.200000 , 0.187000
, 1.300000 , 0.196000
, 1.400000 , 0.205000
, 1.500000 , 0.213000
, 1.600000 , 0.221000
, 1.700000 , 0.230000
, 1.800000 , 0.239000
, 1.900000 , 0.248000
, 2.000000 , 0.257000
, 2.100000 , 0.266000
, 2.200000 , 0.274000
, 2.300000 , 0.282000
, 2.400000 , 0.289000
, 2.500000 , 0.296
, 2.600000 , 0.303
, 2.700000 , 0.310
, 2.800000 , 0.316
, 2.900000 , 0.320
, 3.000000 , 0.324000
, 3.100000 , 0.328000
, 3.200000 , 0.332000
, 3.300000 , 0.335000
, 3.400000 , 0.338000
, 3.500000 , 0.341000
, 3.600000 , 0.344000
, 3.700000 , 0.347000
, 3.800000 , 0.350000
, 3.900000 , 0.353000
, 4.000000 , 0.355000
, 4.100000 , 0.358000
, 4.200000 , 0.360000
, 4.300000 , 0.362000
, 4.400000 , 0.364000
, 4.500000 , 0.365000
, 4.600000 , 0.366000
, 4.700000 , 0.368000
, 4.800000 , 0.369000
, 4.900000 , 0.370000
, 5.000000 , 0.370000

};

 extern const TURPolyLine PLN_Knm_76(ARrKnm_76, NUmPointsKnm_76);
 ///

  const int NUmPointsCz_76 = 47;

  double ARrCz_76[] ={
0.000000 , 0.040000
, 0.500000 , 0.040000
, 0.600000 , 0.040000
, 0.700000 , 0.040000
, 0.800000 , 0.032883
, 0.900000 , 0.001074
, 1.000000 , 0.009477
, 1.100000 , 0.019971
, 1.200000 , 0.028146
, 1.300000 , 0.033077
, 1.400000 , 0.037353
, 1.500000 , 0.041397
, 1.600000 , 0.045153
, 1.700000 , 0.048747
, 1.800000 , 0.052202
, 1.900000 , 0.056557
, 2.000000 , 0.060564
, 2.100000 , 0.063581
, 2.200000 , 0.066536
, 2.300000 , 0.069277
, 2.400000 , 0.071241
, 2.500000 , 0.072478
, 2.600000 , 0.072509
, 2.700000 , 0.071754
, 2.800000 , 0.067205
, 2.900000 , 0.048005
, 3.000000 , 0.040000
, 3.100000 , 0.040000
, 3.200000 , 0.040000
, 3.300000 , 0.040000
, 3.400000 , 0.040000
, 3.500000 , 0.040000
, 3.600000 , 0.040000
, 3.700000 , 0.040000
, 3.800000 , 0.040000
, 3.900000 , 0.040000
, 4.000000 , 0.040000
, 4.100000 , 0.040000
, 4.200000 , 0.040000
, 4.300000 , 0.040000
, 4.400000 , 0.040000
, 4.500000 , 0.040000
, 4.600000 , 0.040000
, 4.700000 , 0.040000
, 4.800000 , 0.040000
, 4.900000 , 0.040000
, 5.000000 , 0.040000
  };

 extern const TURPolyLine PLN_Cz_76(ARrCz_76, NUmPointsCz_76);
 ///

 // у Скклыги это коэффициенты alf0,  alf1,  alf2, alf3
/*const  double arrConst_CxEtal [9][5]=
{	0.0    ,   0.0,         0.0,        0.0,         0.0,
	0.73357,   0.157,       0.0,        0.0,         0.0,
	0.90962,  -3.871879,   15.734575, -20.511918,    8.928144,
	0.99765, 122.720358, -390.742644, 413.61313,  -145.266282,
	1.17371, -19.848947,   52.409513, -45.299813,   13.06484,
	1.58451,  -0.639686,    2.250136,  -1.600055,    0.363206,
	2.64084,   0.643812,   -0.278701,   0.069619,   -0.006051,
	3.72652,   0.621061,   -0.242875,   0.053243,   -0.003765,
	1000.0,    0.26,        0.0,        0.0,         0.0
};
*/

// У СКАЛЫГИ ЭТО mash И mmash
  double arrConst_MxOmegax [62]=
{   0.0,    0.0,
	0.4,    0.0007,
	0.5,    0.0007,
	0.6,    0.0006,
	0.7,    0.0006,
	0.8,    0.0006,
	0.9,    0.0006,
	0.95,   0.0006,
	1.0,    0.0006,
	1.05,   0.0006,
	1.1,    0.0006,
	1.15,   0.0005,
	1.2,    0.0005,
	1.3,    0.0005,
	1.4,    0.0005,
	1.5,    0.0005,
	1.6,    0.0005,
	1.7,    0.0005,
	1.8,    0.0005,
	1.9,    0.0004,
	2.0,    0.0004,
	2.1,    0.0004,
	2.2,    0.0004,
	2.3,    0.0004,
	2.4,    0.0004,
	2.5,    0.0004,
	2.6,    0.0004,
	2.7,    0.0004,
	2.8,    0.0004,
	2.9,    0.0003,
	3.0,    0.0003
};

 extern const TURPolyLine  PLN_MxOmegax(arrConst_MxOmegax,31);
// У СКАЛЫГИ ЭТО kn0, kn1,kn1, ky3
/*const  double arrConst_Knm [8][4]=
{   0.0, 0.206,     0.0,       0.0,
	0.6, 0.173903,  0.106376, -0.086023,
	0.8, 0.371089, -0.307251,  0.126190,
	1.1, 0.085860,  0.084315,  0.000399,
	1.5, 0.033077,  0.139076, -0.013524,
	2.9, 0.139043,  0.084848, -0.007699,
	4.9, 0.370,     0.0,       0.0,
	100.0, 0.370,     0.0,       0.0

}; */



 //  коэффициенты согласования по ё130
 double cbxm130_[31]//Массив коэффициентов согласования по координате Х
	 //в зависимости от угла наведения орудия в вертикальной плоскости
		={0.98,0.98/*3*/,0.9765/*6*/,0.9785/*9*/,0.98/*12*/,
	  0.9815/*15*/,0.9835/*18*/,0.9845/*21*/,0.986/*24*/,
	  0.9875/*27*/,0.9885/*30*/,0.9895/*33*/,0.9905/*36*/,
	  0.9925/*39*/,0.994/*42*/,0.996/*45*/,1.03/*48*/,
	  1.03/*51*/,1.03/*54*/,1.05/*57*/,1.05/*60*/,
		1.05/*63*/,1.05/*66*/,1.08/*69*/,1.08/*72*/,
	  1.1/*75*/,1.2/*78*/,1.2/*81*/,1.4/*84*/,
	  2.5/*87*/,2.5/*90*/};
 double cbym130_[31]//Массив коэффициентов согласования по координате Y
	 //в зависимости от угла наведения орудия в вертикальной плоскости
    ={0.88,0.88/*3*/,0.93/*6*/,0.95/*9*/,0.9575/*12*/,
	  0.965/*15*/,0.967/*18*/,0.9675/*21*/,0.9705/*24*/,
	  0.972/*27*/,0.974/*30*/,0.975/*33*/,0.9753/*36*/,
	  0.9755/*39*/,0.9757/*42*/,0.9759/*45*/,0.964/*48*/,
	  0.964/*51*/,0.964/*54*/,0.966/*57*/,0.968/*60*/,
	  0.968/*63*/,0.964/*66*/,0.964/*69*/,0.964/*72*/,
	  0.962/*75*/,0.962/*78*/,0.962/*81*/,0.962/*84*/,
	  0.962/*87*/,0.962/*90*/};

 //******************************************************************************
 // Изменение № 15
 //******************************************************************************
	 double cbzm130_[31]={0.35,0.35/*3*/,0.45/*6*/,0.55/*9*/,0.6/*12*/,
	  0.7/*15*/,0.75/*18*/,0.9/*21*/,0.9/*24*/,
	  1.0/*27*/,1.15/*30*/,1.3/*33*/,1.35/*36*/,
	  1.5/*39*/,1.6/*42*/,1.7/*45*/,1.75/*48*/,
	  1.9/*51*/,2.0/*54*/,2.2/*57*/,2.35/*60*/,
	  2.5/*63*/,2.65/*66*/,2.8/*69*/,2.95/*72*/,
	  3.15/*75*/,3.22/*78*/,3.5/*81*/,3.5/*84*/,
	  3.5/*87*/,3.5/*90*/};
 //******************************************************************************
 // Конец изменения № 15
 //******************************************************************************

 //Массив углов наведения орудия в вертикальной плоскости (градус)
 double fim130_[31]={0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,
		 48,51,54,57,60,63,66,69,72,75,78,81,84,87,90};

// TURPolyLine pln_iz_130( fim130, cbzm130, 31);
 TURPolyLine pln_ix_130( fim130_, cbxm130_, 31);
 TURPolyLine pln_iy_130( fim130_, cbym130_, 31);
 TURPolyLine pln_iz_130( fim130_, cbzm130_, 31);
 ///

	//  коэффициенты согласования по 100
 double cbxm100_[31]//Массив коэффициентов согласования по координате Х
	 //в зависимости от угла наведения орудия в вертикальной плоскости
	={0.919,0.918/*3*/,0.919/*6*/,0.92/*9*/,0.9201/*12*/,
	  0.9205/*15*/,0.9205/*18*/,0.9207/*21*/,0.921/*24*/,
	  0.921/*27*/,0.921/*30*/,0.9215/*33*/,0.9215/*36*/,
	  0.9215/*39*/,0.922/*42*/,0.9227/*45*/,0.923/*48*/,
	  0.9233/*51*/,0.9236/*54*/,0.9237/*57*/,0.924/*60*/,
	  0.9245/*63*/,0.9245/*66*/,0.925/*69*/,0.9255/*72*/,
	  0.926/*75*/,0.926/*78*/,0.926/*81*/,0.9265/*84*/,
	  0.9265/*87*/,0.9265/*90*/};
 double cbym100_[31]//Массив коэффициентов согласования по координате Y
	 //в зависимости от угла наведения орудия в вертикальной плоскости
	={1.0,1.00/*3*/,0.958/*6*/,0.947/*9*/,0.9445/*12*/,
	  0.9445/*15*/,0.9445/*18*/,0.9445/*21*/,0.9445/*24*/,
	  0.9445/*27*/,0.945/*30*/,0.945/*33*/,0.945/*36*/,
	  0.945/*39*/,0.945/*42*/,0.945/*45*/,0.9456/*48*/,
	  0.946/*51*/,0.946/*54*/,0.9463/*57*/,0.9464/*60*/,
	  0.9469/*63*/,0.9469/*66*/,0.9471/*69*/,0.9475/*72*/,
	  0.948/*75*/,0.9485/*78*/,0.949/*81*/,0.949/*84*/,
	  0.949/*87*/,0.949/*90*/};

 //Массив углов наведения орудия в вертикальной плоскости (градус)
 double fim100_[31]={0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,
		 48,51,54,57,60,63,66,69,72,75,78,81,84,87,90};


 //******************************************************************************
	double cbzm100_[31]={0.95,0.95/*3*/,0.88/*6*/,0.88/*9*/,0.85/*12*/,
	  0.8/*15*/,0.75/*18*/,0.73/*21*/,0.73/*24*/,
	  0.7/*27*/,0.7/*30*/,0.7/*33*/,0.65/*36*/,
	  0.65/*39*/,0.65/*42*/,0.65/*45*/,0.65/*48*/,
	  0.65/*51*/,0.65/*54*/,0.6/*57*/,0.55/*60*/,
		0.55/*63*/,0.55/*66*/,0.5/*69*/,0.45/*72*/,
	  0.4/*75*/,0.33/*78*/,0.25/*81*/,0.25/*84*/,
		0.25/*87*/,0.25/*90*/};

// TURPolyLine pln_iz_100( fim100, cbzm100, 31);
 TURPolyLine pln_ix_100( fim100_, cbxm100_, 31);
 TURPolyLine pln_iy_100( fim100_, cbym100_, 31);
 TURPolyLine pln_iz_100( fim100_, cbzm100_, 31);

 ///

 //  коэффициенты согласования по 76

 double cbxm76_[16]//Массив коэффициентов согласования по координате Х
	 //в зависимости от угла наведения орудия в вертикальной плоскости
	={1.088,1.088/*6*/,1.0925/*12*/,1.0975/*18*/,1.1/*24*/,
	  1.1035/*30*/,1.105/*36*/,1.1046/*42*/,1.10/*48*/,
	  1.096/*54*/,1.0915/*60*/,1.085/*66*/,1.078/*72*/,
	  1.075/*78*/,1.073/*84*/,1.073/*90*/};
 double cbym76_[16]//Массив коэффициентов согласования по координате Y
	 //в зависимости от угла наведения орудия в вертикальной плоскости
	={1.090,1.090/*6*/,1.0947/*12*/,1.1/*18*/,1.1026/*24*/,
	  1.107/*30*/,1.106/*36*/,1.106/*42*/,1.10175/*48*/,
	  1.0965/*54*/,1.092/*60*/,1.0867/*66*/,1.08/*72*/,
	  1.075/*78*/,1.0715/*84*/,1.0715/*90*/};
 //Массив углов наведения орудия в вертикальной плоскости (градус)
 double fim76_[16]={0,6,12,18,24,30,36,42,48,54,60,66,72,78,84,90};
 TURPolyLine pln_ix_76( fim76_, cbxm76_, 16);
 TURPolyLine pln_iy_76( fim76_, cbym76_, 16);
 TURPolyLine pln_iz_76( fim76_, cbxm76_, 16);


 ///
 double cbxm30_[31]={0.,1.063/*3*/,1.0624/*6*/,1.0623/*9*/,1.062/*12*/,
	 1.062/*15*/,1.062/*18*/,1.062/*21*/,1.062/*24*/,1.062/*27*/,
	 1.062/*30*/,1.062/*33*/,1.062/*36*/,1.062/*39*/,1.062/*42*/,
	 1.062/*45*/,1.062/*48*/,1.062/*51*/,1.062/*54*/,1.062/*57*/,
	 1.062/*60*/,1.062/*63*/,1.062/*66*/,1.062/*69*/,1.062/*72*/,
	 1.062/*75*/,1.062/*78*/,1.062/*81*/,1.062/*84*/,1.062/*87*/,
	 1.062/*90*/};
	double cbym30_[31]={0.,1.084/*3*/,1.086/*6*/,1.0845/*9*/,1.086/*12*/,
	1.085/*15*/,1.084/*18*/,1.084/*21*/,1.084/*24*/,1.0835/*27*/,
	1.0835/*30*/,1.0835/*33*/,1.0835/*36*/,1.083/*39*/,1.083/*42*/,
	1.083/*45*/,1.083/*48*/,1.083/*51*/,1.083/*54*/,1.083/*57*/,
	1.083/*60*/,1.0829/*63*/,1.0828/*66*/,1.0828/*69*/,1.0827/*72*/,
	1.0827/*75*/,1.0827/*78*/,1.0826/*81*/,1.0826/*84*/,1.0826/*87*/,
	1.0826/*90*/};
	double fim30_[31]={0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,
		54,57,60,63,66,69,72,75,78,81,84,87,90};
		TURPolyLine pln_ix_30( fim30_, cbxm30_, 31);
		TURPolyLine pln_iy_30( fim30_, cbym30_, 31);
		TURPolyLine pln_iz_30( fim30_, cbxm30_, 31);





//---------------------------------------------------------------------------
TLearnShellBody::TLearnShellBody()

{
	 mL =0.;// 0.6833;
// диаметр миделя, м
	 mDm = 0.;//0.13;
// константа h_гоб для расчета дериываци функции  mh_gob =  Lc + 0.57*Lg -0.16*Dm
	 mh_gob = 0.;//0.380691;
// расстояние от основания гч до цм
	 mLc =0.;// 0.3295;
// длина гч
	 mLg =0.;// 0.1263 ;
// масса
	 mMass = 33.4;
// момент инерции

	 mvalIx0 =0.;// 0.0797248955 ;
	mplnCx = TURPolyLine();//pln_ix_130;
	mplnKnm = TURPolyLine();//pln_iy_130;
	mplnMxOmx = TURPolyLine();//pln_iz_130;
	mplnCz =   TURPolyLine();

	mV0 = 0.;//850. ;   // нач скорость
	mOmega0 = 0.;//1643.;  // нач угловая скорость // нач угловая скорость

	mDispOmega0 = 0.;// (mOmega0 * 0.0001) * (mOmega0 * 0.0001);
	mDispMass0 =0.;// 0.05 * mMass * 0.05 * mMass;
	// дисперсия разброса начального значения путевой скорости
	mDispV0 = 0. ;

	// дисперсия относительного  разброса Cx (1 + delta)
	mDispCx = 0.;//0.0009;

	// дисперсия относительного  разброса Cz (1 + delta)
	mDispCz = 0.;//0.0009;

}

//---------------------------------------------------------------------------


// конструктор копирования
 TLearnShellBody ::TLearnShellBody (const TLearnShellBody &R)
 {
	 mEnumShellType = R.mEnumShellType;
	 mL = R.mL ;
// диаметр миделя, м
	 mDm = R.mDm;
	 mLc = R.mLc;
	 mLg =  R.mLg;
// константа h_гоб для расчета дериываци функции  mh_gob =  Lc + 0.57*Lg -0.16*Dm
	 mh_gob = R.mh_gob ;
// масса
	 mMass = R.mMass;
// момент инерции
	 mvalIx0 = R.mvalIx0 ;

	 mplnCx = R.mplnCx;//pln_ix_130;

	 mplnKnm = R.mplnKnm;//pln_iy_130;

	 mplnMxOmx = R.mplnMxOmx ;

	 mplnCz = R.mplnCz ;

	// вектор дисперсий случайных разбросов начальных условий движения
// снваряда и 2-х параметорв - коэффиц формы и массы
   //	 memcpy(marrDispScatters, R.marrDispScatters, 10 * sizeof( double));

	mV0 = R.mV0 ;   // нач скорость

	mOmega0 = R.mOmega0 ;  // нач угловая скорость // нач угловая скорость

	mDispOmega0 = R.mDispOmega0;
	mDispMass0 = R.mDispMass0;
	mDispV0 = R.mDispV0;
	mDispCx = R.mDispCx;
	mDispCz = R.mDispCz;

 }

 // оператор присваивания
 TLearnShellBody TLearnShellBody::operator=(TLearnShellBody  R)
 {
	 mEnumShellType = R.mEnumShellType ;

	 mL = R.mL ;
// диаметр миделя, м
	 mDm = R.mDm;
	 mLc = R.mLc;
	 mLg =  R.mLg;
// константа h_гоб для расчета дериываци функции  mh_gob =  Lc + 0.57*Lg -0.16*Dm
	 mh_gob = R.mh_gob ;
// масса
	 mMass = R.mMass;
// момент инерции
	 mvalIx0 = R.mvalIx0 ;

	 mplnCx = R.mplnCx;//pln_ix_130;

	 mplnKnm = R.mplnKnm;//pln_iy_130;

	 mplnMxOmx = R.mplnMxOmx ;

	 mplnCz = R.mplnCz ;


	mV0 = R.mV0 ;   // нач скорость

	mOmega0 = R.mOmega0 ;  // нач угловая скорость // нач угловая скорость
	mDispOmega0 = R.mDispOmega0;
	mDispMass0 = R.mDispMass0;
	mDispV0 = R.mDispV0;
	mDispCx = R.mDispCx;
	mDispCz = R.mDispCz;


	return *this ;
 }




// параметрическийц конструктор
 TLearnShellBody::TLearnShellBody( enumShellType EnumShellType, const TDetonator Detonator)
{
			mplnCx = PLN_CxEtal;
			mplnKnm = PLN_Knm;
			mplnMxOmx = PLN_MxOmegax;
			mplnCz  = PLN_Cz_76 ;
	switch(EnumShellType)
	{
		case CALIBRO_130:
			mL = 0.6833;
			// диаметр миделя, м
			mDm = 0.13;
			// расстояние от основания гч до цм
			mLc = 0.3295;
			// длина гч
			mLg = 0.1263 ;
			// масса
			mMass = 33.4;
			// момент инерции
			mvalIx0 = 0.07896;



			mV0 = 850. ;   // нач скорость
			mOmega0 = 1643.;  // нач угловая скорость
		break;

		case CALIBRO_100:
			mL = 0.522;
			// диаметр миделя, м
			mDm = 0.1;

			// расстояние от основания гч до цм
			 mLc = 0.21871;
			// длина гч
				 mLg = 0.12229; ;
			// масса
			mMass = 15.6;
			// момент инерции

			mvalIx0 = 0.02163;



			mV0 =  880.0;   // нач скорость
			mOmega0 = 1843.1;  // нач угловая скорость
		break;

		case CALIBRO_76_SHTAT:
		case CALIBRO_76_BARRIER:
			mL = 0.3524;
			// диаметр миделя, м
			mDm = 0.0762;
			// расстояние от основания гч до цм
			mLc = 0.1412;
			// длина гч
			 mLg = 0.05 ;
			// масса
			mMass = 5.9;
			// момент инерции
			mvalIx0 = 0.004282;// = m*r*r/2

			mV0 = 980.;  // нач скорость
			mOmega0 = 2500.;  // нач угловая скорость ??????

		break;


		case CALIBRO_30:
			mL = 0.1385;;
			// диаметр миделя, м
			mDm = 0.03;

			// расстояние от основания гч до цм
			 mLc = 0.0206;
			// длина гч
				 mLg = 0.0625;
			// масса
			mMass = 0.384;
			// момент инерции
			mvalIx0 = 4.96386e-05;



			mV0 =  880.;   // нач скорость
			mOmega0 = 7728;  // нач угловая скорость

		break;

		case CALIBRO_UNKNOWN:

		break;
		default:
		break;
	}
	///////////////////////////////////////////////
   // константа h_гоб для расчета дериываци функции  mh_gob =  Lc + 0.57*Lg -0.16*Dm
	mh_gob = mLc + 0.57 * mLg - 0.16 * mDm ;

	mDispOmega0 =  (mOmega0 * 0.0001) * (mOmega0 * 0.0001);
	mDispMass0 =  0.0011* mMass * 0.0011 * mMass;  // vesovoj znak 1/3 %
	// дисперсия разброса начального значения путевой скорости
	mDispV0 = (0.0005* mV0 ) * (0.0005 * mV0 ) ;

	// дисперсия относительного  разброса Cx (1 + delta)
	mDispCx = 0.01 * 0.01;//0.0033 * 0.0033;

	// дисперсия относительного  разброса Cz (1 + delta)
	mDispCz = 0.0033 * 0.0033;

	if ((mEnumShellType == CALIBRO_76_BARRIER) || (mEnumShellType == CALIBRO_76_SHTAT))
	{
	mDispOmega0 =  (mOmega0 * 0.0001) * (mOmega0 * 0.0001);
	mDispMass0 =  0.0011* mMass * 0.0011* mMass;  // vesovoj znak 1/3 %
	// дисперсия разброса начального значения путевой скорости
	mDispV0 = (0.00389* mV0 ) * (0.00389* mV0 ) ;

	// дисперсия относительного  разброса Cx (1 + delta)
	mDispCx = 0.009781 * 0.009781;

	// дисперсия относительного  разброса Cz (1 + delta)
	mDispCz = 0.05 * 0.05;//0.001 * 0.001;
	}


}

//---------------------------------------------------------------------------



// параметрическийц конструктор
 TLearnShellBody::TLearnShellBody( enumShellType EnumShellType)
{
	mEnumShellType = EnumShellType;
	mplnCx = PLN_CxEtal;
	mplnKnm = PLN_Knm;
	mplnMxOmx = PLN_MxOmegax;
	mplnCz  = PLN_Cz_76 ;


	switch(EnumShellType)
	{
		case CALIBRO_130:
			mL = 0.6833;
			// диаметр миделя, м
			mDm = 0.13;
			// расстояние от основания гч до цм
			mLc = 0.3295;
			// длина гч
			mLg = 0.1263 ;
			// масса
			mMass = 33.4;
			// момент инерции
			mvalIx0 = 0.07896;


			mV0 = 850. ;   // нач скорость
			mOmega0 = 1643.;  // нач угловая скорость
		break;

		case CALIBRO_100:
			mL = 0.522;
			// диаметр миделя, м
			mDm = 0.1;

			// расстояние от основания гч до цм
			 mLc = 0.21871;
			// длина гч
				 mLg = 0.12229; ;
			// масса
			mMass = 15.6;
			// момент инерции

			mvalIx0 = 0.02163;

			mV0 =  880.0;   // нач скорость
			mOmega0 = 1843.1;  // нач угловая скорость
		break;

		case CALIBRO_76_SHTAT:
		case CALIBRO_76_BARRIER:
			mL = 0.3524;
			// диаметр миделя, м
			mDm = 0.0762;
			// расстояние от основания гч до цм
			mLc = 0.1412;
			// длина гч
			 mLg = 0.05 ;
			// масса
			mMass = 5.9;
			// момент инерции
			mvalIx0 = 0.004282;// = m*r*r/2

			mV0 = 980.;  // нач скорость
			mOmega0 = 2500.;  // нач угловая скорость ??????
			mplnCx  =  PLN_Cx_76;

			mplnMxOmx = PLN_MxOmx_76;

			mplnKnm = PLN_Knm_76 ;


		break;


		case CALIBRO_30:
			mL = 0.1385;;
			// диаметр миделя, м
			mDm = 0.03;

			// расстояние от основания гч до цм
			 mLc = 0.0206;
			// длина гч
				 mLg = 0.0625;
			// масса
			mMass = 0.384;
			// момент инерции
			mvalIx0 = 4.96386e-05;


			mV0 =  880.;   // нач скорость
			mOmega0 = 7728;  // нач угловая скорость

		break;

		case CALIBRO_UNKNOWN:

		break;
		default:
		break;
	}
	///////////////////////////////////////////////
   // константа h_гоб для расчета дериываци функции  mh_gob =  Lc + 0.57*Lg -0.16*Dm
	mh_gob = mLc + 0.57 * mLg - 0.16 * mDm ;

	mDispOmega0 =  (mOmega0 * 0.0001) * (mOmega0 * 0.0001);
	mDispMass0 =  0.0011* mMass * 0.0011 * mMass;  // vesovoj znak 1/3 %
	// дисперсия разброса начального значения путевой скорости
	mDispV0 = (0.0005* mV0 ) * (0.0005 * mV0 ) ;

	// дисперсия относительного  разброса Cx (1 + delta)
	mDispCx = 0.01 * 0.01;//0.0033 * 0.0033;

	// дисперсия относительного  разброса Cz (1 + delta)
	mDispCz = 0.0033 * 0.0033;

	if ((mEnumShellType == CALIBRO_76_BARRIER) || (mEnumShellType == CALIBRO_76_SHTAT))
	{
		mDispOmega0 =  (mOmega0 * 0.0001) * (mOmega0 * 0.0001);
		mDispMass0 =  0.0011* mMass * 0.0011* mMass;  // vesovoj znak 1/3 %
	// дисперсия разброса начального значения путевой скорости
	mDispV0 = (0.00389* mV0 ) * (0.00389* mV0 ) ;

	// дисперсия относительного  разброса Cx (1 + delta)
	mDispCx = 0.009781 * 0.009781;

		// дисперсия относительного  разброса Cz (1 + delta)
		mDispCz = 0.05 * 0.05;//0.001 * 0.001;
	}
}

//---------------------------------------------------------------------------


// параметрическийц конструктор
 TLearnShellBody::TLearnShellBody( enumShellType EnumShellType, const TURPolyLine PLN_CxEtal0
	 , const TURPolyLine PLN_Knm0 ,const TURPolyLine PLN_MxOmegax0)
{
	mEnumShellType = EnumShellType;
	mplnCx = PLN_CxEtal0;
	mplnKnm = PLN_Knm0;
	mplnMxOmx = PLN_MxOmegax0;
	mplnCz  = PLN_Cz_76 ;


	switch(EnumShellType)
	{
		case CALIBRO_130:
			mL = 0.6833;
			// диаметр миделя, м
			mDm = 0.13;
			// расстояние от основания гч до цм
			mLc = 0.3295;
			// длина гч
			mLg = 0.1263 ;
			// масса
			mMass = 33.4;
			// момент инерции
			mvalIx0 = 0.07896;


			mV0 = 850. ;   // нач скорость
			mOmega0 = 1643.;  // нач угловая скорость
		break;

		case CALIBRO_100:
			mL = 0.522;
			// диаметр миделя, м
			mDm = 0.1;

			// расстояние от основания гч до цм
			 mLc = 0.21871;
			// длина гч
				 mLg = 0.12229; ;
			// масса
			mMass = 15.6;
			// момент инерции

			mvalIx0 = 0.02163;

			mV0 =  880.0;   // нач скорость
			mOmega0 = 1843.1;  // нач угловая скорость
		break;

		case CALIBRO_76_SHTAT:
		case CALIBRO_76_BARRIER:
			mL = 0.3524;
			// диаметр миделя, м
			mDm = 0.0762;
			// расстояние от основания гч до цм
			mLc = 0.1412;
			// длина гч
			 mLg = 0.05 ;
			// масса
			mMass = 5.9;
			// момент инерции
			mvalIx0 = 0.004282;// = m*r*r/2

			mV0 = 980.;  // нач скорость

			mOmega0 = 2500.;  // нач угловая скорость ??????

			mplnCx  =  PLN_Cx_76;

			mplnMxOmx = PLN_MxOmx_76;

			mplnKnm = PLN_Knm_76 ;


		break;


		case CALIBRO_30:
			mL = 0.1385;;
			// диаметр миделя, м
			mDm = 0.03;

			// расстояние от основания гч до цм
			 mLc = 0.0206;
			// длина гч
				 mLg = 0.0625;
			// масса
			mMass = 0.384;
			// момент инерции
			mvalIx0 = 4.96386e-05;


			mV0 =  880.;   // нач скорость
			mOmega0 = 7728;  // нач угловая скорость

		break;

		case CALIBRO_UNKNOWN:

		break;
		default:
		break;
	}
	///////////////////////////////////////////////
   // константа h_гоб для расчета дериываци функции  mh_gob =  Lc + 0.57*Lg -0.16*Dm
	mh_gob = mLc + 0.57 * mLg - 0.16 * mDm ;

	mDispOmega0 =  (mOmega0 * 0.0001) * (mOmega0 * 0.0001);
	mDispMass0 =  0.0011* mMass * 0.0011 * mMass;  // vesovoj znak 1/3 %
	// дисперсия разброса начального значения путевой скорости
	mDispV0 = (0.0005* mV0 ) * (0.0005 * mV0 ) ;

	// дисперсия относительного  разброса Cx (1 + delta)
	mDispCx = 0.01 * 0.01;//0.0033 * 0.0033;

	// дисперсия относительного  разброса Cz (1 + delta)
	mDispCz = 0.0033 * 0.0033;

	if ((mEnumShellType == CALIBRO_76_BARRIER) || (mEnumShellType == CALIBRO_76_SHTAT))
	{
		mDispOmega0 =  (mOmega0 * 0.0001) * (mOmega0 * 0.0001);
		mDispMass0 =  0.0011* mMass * 0.0011* mMass;  // vesovoj znak 1/3 %
	// дисперсия разброса начального значения путевой скорости
	mDispV0 = (0.00389* mV0 ) * (0.00389* mV0 ) ;

	// дисперсия относительного  разброса Cx (1 + delta)
	mDispCx = 0.009781 * 0.009781;

		// дисперсия относительного  разброса Cz (1 + delta)
		mDispCz = 0.05 * 0.05;//0.001 * 0.001;
	}
}

//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
 void TLearnShellBody::fnkCxEtal (const  double valM,  double &val_CxEtal, double &val_Grad_CxEtal)
 {
  val_CxEtal = mplnCx.LinearValueApprox(valM);
  val_Grad_CxEtal = mplnCx.LinearDerivApprox(valM);
 }
//---------------------------------------------------------------------------
 void TLearnShellBody::fnkMxOmegax (const  double valM,  double &val_MxOmegax, double &val_Grad_MxOmegax)
 {
 val_MxOmegax = mplnMxOmx.LinearValueApprox(valM);
 val_Grad_MxOmegax = mplnMxOmx.LinearDerivApprox(valM);
 }
//---------------------------------------------------------------------------
void TLearnShellBody::fnkKnm (const  double valM,  double &val_Knm, double &val_Grad_Knm)
{
 val_Knm = mplnKnm.LinearValueApprox(valM);
 val_Grad_Knm = mplnKnm.LinearDerivApprox(valM);
}

double TLearnShellBody::calcBallisticCoeff()
{
	return 0.474 * mDm * mDm / mMass;
}
//---------------------------------------------------------------------------
double TLearnShellBody::fnkCz (const  double valM)
  {
  return mplnCz.LinearValueApprox(valM);
  }


// формирование 10х10 диагональной матрицы возмущений для снаряда
// при стрельбе с земли
// INPUT:
// VAlSigPiAtm  - СКЗ относительного рассеяния плотности атмосферы, доли 1
// VAlSigTechAngAU  - СКЗ технического рассеивания АУ по углам, рад

void TLearnShellBody::fillShellVozmDispMatr_ShootingEarth (const double VAlSigTechAngAU
, const double VAlSigPiAtm, double *arrMtrxShellDisp)
{



// 0. marrStrSK_VS [3]-  угол Пси

// 1. marrStrSK_VS [5]-  относит плотность атмосферы Пи
// 2.  marrStrSK_VS [7]-  угол Тетта
// 3. marrStrSK_VS [6]-  путевая скорость
// дополнительные разбросы:
// 4.  масса
// 5.  коэфф формы Cx
// 6. коэф формы по оси Z
// 7. модуль горизонтальной скорости ветра
// 8. направление горизонтального ветра
// 9. модуль вертикального ветра
 memset(arrMtrxShellDisp, 0,  sizeof(double) * LEN_ARR_SCATTERS * LEN_ARR_SCATTERS);





 arrMtrxShellDisp[0] =  VAlSigTechAngAU * VAlSigTechAngAU ; //путевой угол      это для 76 кал
 arrMtrxShellDisp[ 2 * LEN_ARR_SCATTERS + 2] =  VAlSigTechAngAU * VAlSigTechAngAU ; // угол наклона траетктории  это для 76 кал
 arrMtrxShellDisp[ 3 * LEN_ARR_SCATTERS + 3] = mDispV0; // путевая скорость
 arrMtrxShellDisp[ 4 * LEN_ARR_SCATTERS + 4] = mDispMass0; // масса
 arrMtrxShellDisp[ 5 * LEN_ARR_SCATTERS + 5] = mDispCx; // коэф Cx
 arrMtrxShellDisp[ 6 * LEN_ARR_SCATTERS + 6] = mDispCz;//клэф Cz




 //arrMtrxShellDisp[ 7 * LEN_ARR_SCATTERS + 7] =  (mEnvironment.mWind_V * 0.1 ) * (mEnvironment.mWind_V * 0.1); // гориз ветер модуль
 //arrMtrxShellDisp[ 8 * LEN_ARR_SCATTERS + 8] = (5. / 180. * M_PI) * (5. / 180. * M_PI);
 //arrMtrxShellDisp[9 * LEN_ARR_SCATTERS + 9] =  (mEnvironment.mWind_VertV * 0.1 ) * (mEnvironment.mWind_VertV * 0.1); // вертик ветер модуль
 arrMtrxShellDisp[  LEN_ARR_SCATTERS +1 ] = VAlSigPiAtm * VAlSigPiAtm;// плотн атмосфкеры


}


#pragma package(smart_init)
