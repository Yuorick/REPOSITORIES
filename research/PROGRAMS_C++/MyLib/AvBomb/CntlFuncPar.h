//---------------------------------------------------------------------------

#ifndef CntlFuncParH
#define CntlFuncParH
//---------------------------------------------------------------------------
#define NUM_INT_PARAMS 5
#define NUM_LD_PARAMS 20
// класс описываетфункцияю управления УАБ
// miControlType - указывает тип управлкения
// в массивах  miArrParams и  mDblArrParams хранятся параетры, описывающие оуправляющую фунцию
// В зависимости от типа управления miControlType форируется во внешней програме алгорит управления
// 1. Если тип управления 0 = miControlType , то движение происходит по баллистике,  alfaAt = 0
// 2. Если тип управления 1 = miControlType   - на последнем участке  планирование  alfaAt = -  mBomb.mMaxAt
//    При этом, массивы параметров хранят следующую информацию
//    miArrParams[0] = длина массива времен траектории (число переключений +2)
//    mDblArrParams - массив времен
//    mDblArrParams[0] - время начала движениея
//    mDblArrParams[i], i = 1,..., (miArrParams[0] -2) - времена переключений управления
//    mDblArrParams[ miArrParams[0] -1 ]  - конец движения
// 3. Если тип управления 2 = miControlType   - на последнем участке  пикирование  alfaAt =   mBomb.mMaxAt
//    остальное аналогично случаю 2.
// 4. Если тип управления 10 = miControlType - самонаведение методом пропорциональной навигации
//    mDblArrParams[0] - коэфиициент навигации
// 5. Если тип управления 11 = miControlType - самонаведение методом параллельного сближения
// 6. Если тип управления 12 = miControlType - метод оптимального управления по быстродействию на встречу с целью

// 7. Если тип управления 21 = miControlType - то это 3-х мерная задача с упрощенным принципом управления.
//    УГол атаки разбивается на вертикальный и горизонтальный углы, имеющие  постоянную величину
//    на всем протяжении полета  mBomb.mMaxAt * mBomb.mMaxAt = agoriz * agoriz + avertic * avertic
//    Горизонтальный угол не изменяется на всем протяжении полета
//    Вертикальный угол может иметь одну  точку переключения
//    При этом, массивы параметров хранят следующую информацию
//    miArrParams[0] = длина массива времен траектории (число переключений +2) - это или 2 или 3
//    mDblArrParams - массив времен
//    mDblArrParams[0] - время начала движениея
//    mDblArrParams[i], i = 1,..., (miArrParams[0] -2) - времена переключений управления
//    mDblArrParams[ miArrParams[0] -1 ]  - конец движения
//    mDblArrParams[ miArrParams[0]] = k - коэффициент , меньший 1, в соответствии скотороым распределяется угол ататки между
//    вертикальным и горизонтальным движением, то есть
//    avertic = mBomb.mMaxAt *  k, agoriz = mBomb.mMaxAt * sqrtl( 1 - k * k)
//    на последнем участке  планирование  avertic = -  mBomb.mMaxAt * k
// 8. Если тип управления 22 = miControlType - то это 3-х мерная задача с упрощенным принципом управления.
//    на последнем участке  планирование  avertic =   mBomb.mMaxAt * k
//    в остальнм аналогично случаю 7.
class TCntlFuncPar
{
public:
// Тип управления
  //1. 0 = miControlType -  баллистика  alfaAt = 0
   // 2. УПРАВЛЕНИЯ С ПЕРЕКЛЮЧЕНИЯМИ
// 1 = miControlType   - на последнем участке  планирование  alfaAt = -  mBomb.mMaxAt
// 2 = miControlType   - на последнем участке  пикирование  alfaAt =   mBomb.mMaxAt
// Для этих управлений  mDblArrParams - массив моментов перключений,
// miArrParams[0] - длина массива переключений
//
	int miControlType;
// 2.  масиив целочисленнных параетров
	int miArrParams[NUM_INT_PARAMS] ;
//3. масиив параметров long double
	long double mDblArrParams[NUM_LD_PARAMS] ;


	// конструктор по умолчанию
	TCntlFuncPar () ;
	// конструктор копирования
	TCntlFuncPar  (const TCntlFuncPar  &R) ;
	// оператор присваивания
	TCntlFuncPar  operator=(TCntlFuncPar   R2) ;

	// парам конструктор
	TCntlFuncPar  ( const int  iControlType, int *iArrParams , long double *DblArrParams) ;

  };


#endif
