//---------------------------------------------------------------------------


#pragma hdrstop

#include "ProbabilityTheory.h"

#include <float.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

//---------------------------------------------------------------------------
// Вычисление вероятности того, что число успехов   из последовательности
// QUantIsp независимых испытаний биномиального распределения случ величины
// будет меньше VAlNesessarySuccess
//INPUT:
// QUantIsp  - обющее к-во испытаний
// VAlP - вероятность успеха в одном испытании
// VAlNesessarySuccess - необходимое число успехов
double __fastcall TProbabilityTheory::funcDistributionOfProbabilitiesForBinom (const int QUantIsp,
   const double VAlP, const double VAlNesessarySuccess )
{
double valSig = sqrt(((double)QUantIsp) * VAlP * (1. - VAlP));
double valMean = ((double)QUantIsp) * VAlP /valSig;
double valx =  VAlNesessarySuccess / valSig - valMean;
double val_return =  fncGaussDistrib01_Dim1 ( valx);

return val_return;
}

// функция распределения одномерного гауссовго распределения  c нулевым средним и един дисперсией
// INPUT:
// VAlx  - аргумент
// Вычисляет вероятность тогоБ что сл величина будет меньше  VAlx
double __fastcall TProbabilityTheory::fncGaussDistrib01_Dim1 (const double VAlx)
{
	double valGaussIntegral = calcGaussIntegral( VAlx );
	double valreturn = 0.5 +  valGaussIntegral;
 //	if (VAlx < 0.)
 //	{
 //	 valreturn = 0.5 -  valGaussIntegral;
 //	}
	return valreturn ;
}


// вычисление интеграла от функции exp(-x*x/2.)/sqrt(2.* M_PI)
// на отрезке [0; VAlx]
double __fastcall TProbabilityTheory::calcGaussIntegral(const double VAlx )
{
	if (fabs(VAlx) > 3.)
	{
	 return 0.5 * SIGNUM(VAlx);
	}
	double valStep = 0.0001;
	int iC = VAlx / valStep;
	double valSum = 0.;
	for (int i =0; i < iC; i++)
	{
	  double temp = ((double)i) * valStep;
	  valSum += exp(-temp * temp /2.);
	}
	 valSum *=  valStep / sqrt(2. * M_PI);
	return valSum;
}


// Вычисление вероятности к-ва успехов биномиального распределения
// INPUT:
//VAl_q - вероятность успеха обдного испытания
// QUantM - число испытаний
// QUantN - число успехов
// возвращает вероятность осуществления QUantN  успешных испытаний
double __fastcall TProbabilityTheory::calcBinomSuccessProbability(const double VAl_q, const int QUantM, const int QUantN )
{
	const long double VAl_ql = VAl_q;
	const long double VAl_M =  (long double) QUantM;
	const long double VAl_N =  (long double) QUantN;
	long double valSumLn = VAl_N *  logl(VAl_ql) + (VAl_M -VAl_N) * logl( 1. - VAl_ql);
	for (int i = 0; i < QUantN; i++)
	{
	 valSumLn += logl(VAl_M - (long double)i) - logl((long double)(i + 1));
	}
	long double temp = expl(valSumLn);
	double temp1 = (double) temp;
	return temp1;

}

//------------------------------------------------------------------
// Вычисдление интьеграла от нормальной плотности одномерного распределения
// VAla - среднее(мат ожидание)
// VAlSig - СКЗ
// VAlX0, VAlX0 - нижний и верхний пределы интегрирования
// VAlStepIntegr - шаг интегрирования
//
//
double TProbabilityTheory::calcIntegralNormalDensity(const double VAla, const double VAlSig
	, const double VAlX0, const double VAlX1,  const double VAlStepIntegr)
{
 double iC = (VAlX1 - VAlX0) / VAlStepIntegr;
 double sum = 0.;
 for (int i =0 ; i < iC; i++)
 {
	double temp = (VAlX0 + ((double)i) * VAlStepIntegr  - VAla) /VAlSig;
	sum +=  exp(- temp * temp / 2.);
 }
 sum = sum * VAlStepIntegr / sqrt(2. * M_PI) / VAlSig;
 return sum ;
 }
#pragma package(smart_init)
