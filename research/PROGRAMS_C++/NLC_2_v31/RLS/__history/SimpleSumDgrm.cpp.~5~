//---------------------------------------------------------------------------


#pragma hdrstop

#include "SimpleSumDgrm.h"

#include <math.h>
#include <stdlib.h>
#include <string.h>
#include "YrWriteShapeFile.h"
#include "URPolyLine.h"
#include "UrPointXY.h"
#include "DiagrSinX.h"
#include "MatrixProccess.h"
#include "Comp.h"

_fastcall  TSimpleSumDgrm ::TSimpleSumDgrm()
{

 // понижающий коэфф суммарнй диаграммы
  mKSum = 0.9;
 //угол сканирования суммарной диаграммы
  mScnSum = -10. * 3000./ M_PI;
 // коэффиц растяжения суммарной диаграммы
   mTension = 127.;

}

// Конструктор копирования
__fastcall  TSimpleSumDgrm::TSimpleSumDgrm (const TSimpleSumDgrm &R)
 {

	// понижающий коэфф суммарнй диаграммы
	mKSum = R.mKSum;
	//угол сканирования суммарной диаграммы
	mScnSum = R.mScnSum;
	// коэффиц растяжения суммарной диаграммы
	mTension = R.mTension;
 }
// оператор присваивания
  TSimpleSumDgrm TSimpleSumDgrm::operator=(TSimpleSumDgrm  R)
 {

	// понижающий коэфф суммарнй диаграммы
	mKSum = R.mKSum;
	//угол сканирования суммарной диаграммы
	mScnSum = R.mScnSum;
	// коэффиц растяжения суммарной диаграммы
	mTension = R.mTension;
	 return *this ;
 }

 // парам констр
 __fastcall TSimpleSumDgrm::TSimpleSumDgrm(const double KSum , const double ScnSum, const double Tension )
 {

	 mKSum = KSum ;
	 mScnSum =ScnSum ;
	 mTension = Tension ;
 }

//----------------------------------------------------------
void  _fastcall TSimpleSumDgrm::calcPartial_vectG_and_mtrxH(TComp cmpSZv, double alfTrg,double  alfAnp,double valK11, double valK12
	 ,double valK21,double valK22,double* arr_gradK11, double* arr_gradK12, double* arr_gradK21
	 ,double* arr_gradK22, double*arr_HessK11, double* arr_HessK12, double* arr_HessK21
	 ,double* arr_HessK22,double*   arr_FGreek, double*  arr_dFGreek )
{
  double valF1 = mKSum *fncDiagrSinx_div_x(alfTrg) ;
  double val_dF1 = mKSum * mTension *fncDerivDiagrSinx_div_x(alfTrg) ;
  double val_d2F1 = mKSum *mTension *mTension *fncDeriv2DiagrSinx_div_x(alfTrg) ;

  double valF2 = mKSum *fncDiagrSinx_div_x( alfAnp) ;
  double val_dF2 = mKSum * mTension *fncDerivDiagrSinx_div_x( alfAnp) ;
  double val_d2F2 = mKSum * mTension *mTension *fncDeriv2DiagrSinx_div_x( alfAnp) ;

  double valA1 = valK11 * valF1 + valK12 * valF2 -  cmpSZv.m_Re ;
  double valA2 = valK12* valF1 + valK22 * valF2 -  cmpSZv.m_Im ;

  // вычисление градиента G

}

#pragma package(smart_init)
