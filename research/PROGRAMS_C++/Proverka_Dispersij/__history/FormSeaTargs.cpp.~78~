// ---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "FormSeaTargs.h"
// ---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"

#include "YrString.h"
#include <stdio.h>
#include <stdlib.h>
#include "AM_2D.h"
#include "Far_2D.h"
#include "Comp.h"
#include "Faceta.h"
#include "Far.h"
#include "Diagrams.h"
#include "Gauss.h"

#include "MatrixProccess.h"

#include "Target.h"
#include "YrWrite.h"

#include "Sins.h"
#include "DriverMech.h"

#include "Measurer.h"
#include "YrWriteShapeFile.h"

#include "InitTargData.h"
#include "CalcCorMatrx.h"

#include "Environment.h"
#include "Equations.h"
#include "MyShellTraj.h"

#include "SincDgr.h"
#include "URPointZ.h"
#include "ShellBody.h"
#include "ControlSyst.h"
#include "Line.h"
#include "SeaTargPicturte.h"

#include "NeighbourhoodAppPoint.h"

static int I_ENTER_COUNT1 = 0;
extern const double VAL_C;
TForm4 *Form4;
extern TPlanePolygon PlanePlgDEBUG;
extern double arrDestrUZP [];
extern const int NumColsTab1_DestrUZP;
extern double arrCutterUZP [];
extern const int NumColsTab1_CutterUZP;
// ---------------------------------------------------------------------------
__fastcall TForm4::TForm4(TComponent* Owner) : TForm(Owner)
{
}
// ---------------------------------------------------------------------------

void __fastcall TForm4::fncInputData() {
	String s_22 = LabeledEdit27->Text;
 //	if (wcschr(s_22.w_str(), L',')) {

		// Цель
		// угол пеленга, град

		mBearing0 = StrTo_Dbl_(LabeledEdit23->Text) * M_PI / 180.;

		// дальность, м

	 //	mDist0 = StrTo_Dbl_(ComboBox5->Items->Text); // ЦЕЛЬ
		mDist0 = StrTo_Dbl_(ComboBox5->Text);

		// угол курса
		mTargCourse0 = StrTo_Dbl_(LabeledEdit29->Text) * M_PI / 180.;

		///

		double valAUDelayT = StrTo_Dbl_(LabeledEdit50->Text)/ 1000.;
		mSigAUDelayT = sqrt(TProbabilityTheory::calcDispRavnomern(valAUDelayT) );

		mSigDrivAY_U = StrTo_Dbl_(LabeledEdit52->Text) / 1000.;
		mSigDrivAY_dU_po_dt = StrTo_Dbl_(LabeledEdit53->Text) / 1000.;

 //	}
 //	else {
		// ширинадиаграммы
		// mWidthDgr =  StrTo_Dbl_(LabeledEdit3->Text) * M_PI/3000./2. ;
 //	}

	// высота, м
	mElev0 = 0.;
	//
	mTargZenitAng0 = M_PI / 2.;

	switch(ComboBox3->ItemIndex) // ЦЕЛЬ
	{
	case 0:
		mEnumTargType = DESTROYER;
		mVelocity0 = 10.;
		mTargEPR = 1000.;
		mWSkz = 0.002;
		break;
	case 1:
		mEnumTargType = MOTORBOAT;
		mVelocity0 = 20.;
		mTargEPR = 500.;
		mWSkz = 0.01;
		break;

	default:

		break;

	}
	LabeledEdit25->Text = int(mVelocity0);
	LabeledEdit28->Text = double(int(mTargEPR * 1000.)) / 1000.;
	LabeledEdit27->Text = double(int(mWSkz * 1000.)) / 1000.;
	// LabeledEdit22->Text = mElev0 ;
	// АУ. определяет ShellBody (mEnumShellType). ShellBody определяет набор возможных детонаторов
	switch(ComboBox1->ItemIndex) {
	case 0:
		mEnumShellType = CALIBRO_130;
		menumCannonType = A_192M;
		LabeledEdit2->Text = 130;
		break;

	case 1:
		mEnumShellType = CALIBRO_100;
		menumCannonType = A_190_01;
		LabeledEdit2->Text = 100;
		break;
	default:
		mEnumShellType = CALIBRO_UNKNOWN;
		menumCannonType = CANNON_UNKNOWN;
		break;
	}

	///
	// тип взрывателя
			// тип взрывателя
		switch(ComboBox2->ItemIndex)
		{
			case 0:
			mDetonatorType = D4MRM;
			break;

			case 1:
			mDetonatorType = MFIVU;
			break;

			default:
			mDetonatorType = DETONATOR_UNKNOWN;
			break;
		}


		///


	TDetonator Detonator(mDetonatorType);
	mShellBody = TShellBody(mEnumShellType, Detonator);
	mArtCannon = TArtCannon(menumCannonType, mAUDelayT);
	mArtComplex = TArtComplex(mArtCannon, mSigDrivAY_U, mSigDrivAY_dU_po_dt);

	LabeledEdit49->Text = mArtCannon.mRateOfFire;

	mQuantShells = StrToInt(LabeledEdit10->Text);

	mInitTargData = TInitTargData(mBearing0, mTargCourse0, mTargZenitAng0,
		mVelocity0, mDist0, mElev0, 0.);
	const double TCur0 = 0.;
	double arrWSkz[3] = {
		0.
	};
	arrWSkz[0] = mWSkz;
	arrWSkz[1] = mWSkz;
	arrWSkz[2] = 0.;
	TTraject Traj0(TCur0, arrWSkz, mInitTargData);
	TTarget Target(Traj0, mEnumTargType, mTargEPR, NULL);
	mVessel = TVessel(mShellBody, mFar_2D, mTransmitAnt, mDriverSigBet,
		mDriverSigEps, mDriverDynamicSigBet, mDriverDynamicSigEps, mMaxSig_Q,
		mMaxSig_Psi, mMaxSig_Tet, mMaxSig_dQdt, mMaxSig_dPsidt, mMaxSig_dTetdt
		// СИНС
		, mMaxSig_H, mMaxSig_VH, mK1, mSigV, mEnvironment, mVesselWidth,
		mVesselLength, marrFarParallacs, mMaxQ, mT_Q, mMaxPsi, mT_Psi, mMaxTet,
		mT_Tet, mMaxVert, mQ0, mVVess, mInitTargData, mMaxAmp_AftFlexure,
		mT_AftFlexure, mMaxAmp_BoardFlexure, mT_BoardFlexure, mControlSyst, marrArtParral,
		mArtComplex, NULL);
	mFight = TFight(mVessel, Target, mVessel.mControlSyst.mFiltT, mEtalonSign,
		mEnvironment, NULL);

  //	TFar Far(mVessel.mFar_2D, true);
  //	const double VAlTetta0 = findDiagrWidth
   //			(Far.mFaceta.m_d, Far.m_D, Far.mFaceta.m_n, Far.m_N, mVessel.mFar_2D.mLambda);
   //	int ib = (VAlTetta0 * 100000.);
   //	LabeledEdit34->Text = ((double)ib) / 100.;

	LabeledEdit51->Text = double
			(int(mVessel.mArtComplex.mArtCannon.mAngGroupedFire * 100000.)) / 100.;

}

void __fastcall TForm4::Button4Click(TObject *Sender) {

	OpenDialog1->Filter = L"файлы с графиками (*.shp)|*.shp";

	if (OpenDialog1->Execute()) {
		mpwchOutFile0 = (OpenDialog1->FileName).w_str();

	}
	Edit2->Text = mpwchOutFile0;
}
// ---------------------------------------------------------------------------

void __fastcall TForm4::Button1Click(TObject *Sender) {
	Close();
}
// ---------------------------------------------------------------------------

void __fastcall TForm4::Button3Click(TObject *Sender)
{

//double valOmega = TNeighbourhoodAppPoint::calcOmega(&arrCutterUZP[NumColsTab1_CutterUZP], NumColsTab1_CutterUZP);
/*
 PlanePlgDEBUG;
	 double arrTargV [3] = {0.}, arrVMiss[3] = {0.};
	 double valTargCourse = 225. * M_PI / 180.;
	 arrTargV [0] = 10. * sin(valTargCourse);
	 arrTargV [1] = 10. * cos(valTargCourse);

	 double valTet = -45. * M_PI /180.;
	 double valBet =   45. * M_PI / 180.;
	 double valV0 = 300.;
	 arrVMiss[0] = valV0 * cos (valTet) * sin ( valBet);
	 arrVMiss[1] = valV0 * cos (valTet) * cos ( valBet);
	 arrVMiss[2] = valV0 * sin (valTet) ;



	TURPolygon 	pPllShadow =  PlanePlgDEBUG.createShadowPlg(arrTargV,  arrVMiss);
	pPllShadow.WriteSetSHPFiles(L"E:\\PROJECTS_C++\\TARAN\\New\\tempShadow3.shp", &pPllShadow, 1) ;
	 return;    */
	// создание пути к папке с отчетом
	if (!mpwchOutFile0) {
		if (I_ENTER_COUNT1 > 4)
			Close();

		ShowMessage(L"Укажите путь к папке с графиками");
		I_ENTER_COUNT1++;
		return;
	}
	wcscpy(mwchOutFold, mpwchOutFile0);
	wchar_t *pwchr = wcsrchr(mwchOutFold, L'\\');
	pwchr[0] = 0;
	String wchFoldName = mwchOutFold;

	fncInputData();

	double  valProb = -1.0, valProb0 = -1.0;
	double valSKZPromach = -1.0, valHAntenna = 20.;
	double arrCoMtrx_1_and_3_Groups [36] = {0.} // коррел матрица вектора промаха обусловленная ошибками 1 и 3 групп
	  , arrCoMtrx_2_Group [36] = {0.}; // коррел матрица вектора промаха обусловленная ошибками 1 и 3 групп
	double valKGSKEps = -1.0, valKGSKBet = -1.0, valTFlight = -1.0; // ПУВН, ПУГН, ПОлетное время
	double arrCorrMatrxVectMiss_GSK [36] = {0.}; // колррел матрица вектонра промаха
	double arrVectMiss_GSK[6] = {0.}; // средний вектор промаха в точке встречи

	if (!mFight.calcSuccessProbSeaTarg(mQuantShells, valHAntenna, &valSKZPromach
	,arrCoMtrx_1_and_3_Groups, arrCoMtrx_2_Group, &valKGSKEps , &valKGSKBet, &valTFlight
	, arrVectMiss_GSK, &valProb, &valProb0))
	{

	}

	MtrxSumMatrx(arrCoMtrx_1_and_3_Groups, arrCoMtrx_2_Group, 6, 6, arrCorrMatrxVectMiss_GSK);
	///
	int ia = (valProb * 100);
	LabeledEdit46->Text = ((double)ia) / 100.;

	ia = (valProb0 * 1000);
	LabeledEdit34->Text = ((double)ia) / 1000.;

	createNibourAppointmPointPictureForSeaTarg(wchFoldName.w_str(),arrCoMtrx_1_and_3_Groups, arrCoMtrx_2_Group,arrVectMiss_GSK
	, mFight.mTarget, mQuantShells) ;


}
// ---------------------------------------------------------------------------

void __fastcall TForm4::Button2Click(TObject *Sender) {

	if (!mpwchOutDataFileTaran)
	{
		if (I_ENTER_COUNT1 > 4)
			Close();

		ShowMessage(L"Укажите путь к папке с графиками");
		I_ENTER_COUNT1++;
		return;
	}

	double arrCoMtrx_1_and_3_Groups[36] = {	0.}, arrCoMtrx_2_Group[36] = {0.}
				,arrCorMtrx[36] = {0.}, arrCorMtrxRez[4] = {0.};
	int iNumCols = 3;
	int iNumRows = ComboBox5->GetCount();
	int iLenName = 30;
	double *parrBuff = new double[iNumCols * iNumRows];

	wchar_t *pwcharrColNames = new wchar_t[iNumCols * iLenName];
	memset(pwcharrColNames, 0, iNumCols * iLenName*sizeof(wchar_t));

	wcscpy(pwcharrColNames, L"DIST");
	wcscpy(&pwcharrColNames[iLenName], L"FIRST_SEMIAXIS");
	wcscpy(&pwcharrColNames[2 * iLenName], L"SECOND_SEMIAXIS");

	for (int i = 0; i < iNumRows; i++)
 //	for (int i = 2; i < 3; i++)
	 {
		ComboBox5->ItemIndex = i;
		fncInputData();
		mFight.mVessel.mMaxQ = 0.; // корабль двигается по идеальной прямой
		memset( mFight.mTarget.mTraject.marrSigW, 0, 3 * sizeof(double));  // цель двигается по идеальной прямой
		// РЕшение задачи о точке встречи

			// 1. Решение задачи о точке встречи
  // вычисление вектора положения АУ в КГСК
	double arrPositionAY_KGSK[3] = {0.};
	mFight.mVessel.calcAY_Position(arrPositionAY_KGSK);
	double valKGSKEps = 0., valKGSKBet  = 0.;
	double arrVectAppointmentPointGSK[6] = {0.};
	double valMiss = -1., valTFlight = -1.;

	// вычисление истинного вектора состояния цели в КГСК на момомент выстрела
	double arrTargVS_KGSK0[6] ={0.};
	MtrxMinusMatrx(mFight.mTarget.mTraject.marrVectSostGSK_Begin, mFight.mVessel.marrVectSost,1, 6, arrTargVS_KGSK0);
	///
	if (!mFight.calcAppointmentPoint(NULL, NULL, &(mFight.mVessel.marrVectSost[3])
	,arrTargVS_KGSK0, arrPositionAY_KGSK
	, &valKGSKEps, &valKGSKBet, &valTFlight, arrVectAppointmentPointGSK, &valMiss))
	{
		ShowMessage(L"ERROR_ TFight::calcSuccessProbCoast");
		return ;
	}
///
 /////////////////////////////////////////////////////////////////////////
	//////////////  ЭТО ДЛЯ ОТЛАДКИ!!! СВЕРХУ РАСКОММЕНТИРОВАТЬ А ЭТО УДАЛИТЬ !!!!///////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////

//valKGSKEps =	0.35873669492725 ;
//valKGSKBet =	6.27370551180827 ;
//valTFlight =	43.3708000003162 ;
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////


    double arrShellVS_GSK [6] = {0.};
		mFight.calcCorMtrx_First_And_Third_Group(true,valKGSKEps, valKGSKBet, valTFlight,arrCoMtrx_1_and_3_Groups, arrShellVS_GSK);
		const double VAlObservTime = 10.;
		mFight.calcCorMtrx_Second_Group(VAlObservTime, valTFlight, arrCoMtrx_2_Group);
		MtrxSumMatrx(arrCoMtrx_1_and_3_Groups, arrCoMtrx_2_Group, 6, 6, arrCorMtrx);
		arrCorMtrxRez[0] = arrCorMtrx[0];
		arrCorMtrxRez[1] = arrCorMtrx[1];
		arrCorMtrxRez[2] = arrCorMtrx[1];
		arrCorMtrxRez[3] = arrCorMtrx[7];

		double arrV[4] = {0.}, arrLamb[4] = {0.};
		CalcProperVectors2(arrCorMtrxRez, arrV, arrLamb);
		parrBuff[i * iNumCols] = mDist0;
		parrBuff[i * iNumCols + 1] = sqrt(arrLamb[0]);
		parrBuff[i * iNumCols + 2] = sqrt(arrLamb[3]);

	}
	TYrWrite::WriteMassiveInFIleSCV(mpwchOutDataFileTaran, parrBuff, iNumRows, iNumCols,
		NULL, pwcharrColNames, iLenName);
	delete parrBuff;
	delete pwcharrColNames;
}

// ---------------------------------------------------------------------------

void __fastcall TForm4::Button5Click(TObject *Sender)
{
 SaveDialog1->Filter = L"TXT файлы (*.csv)|*.csv" ;


	if (SaveDialog1->Execute())
	{
	 //	ShowMessage( (SaveDialog1->FileName).w_str()) ;
	 mpwchOutDataFileTaran =  (SaveDialog1->FileName).w_str();

	}
	Edit1->Text =mpwchOutDataFileTaran;

}
//---------------------------------------------------------------------------

// ---------------------------------------------------------------------------

void __fastcall TForm4::create5P10()
{
   	//амплитуда
	 double valEtalonAmp = 500.;
	//дальность
	 double valEtalonDist = 12000.;
	//ЭПР
	 double valEtalonAPR = 1.;
	//СКО внутр шума суммарной диаграммы 5П10
	 double valNoiseSKZ_5P10 = 18.735;
	// СКЗ разброса коэффиц усиления суммарной диаграммы 5П10
	 double valEtalonSigAmplFact_5P10 = 0.01;
	//
	// мощность на передачу
	 double valEtalonPowerPrd = 4000.;
	// КУ на передачу
	 double valEtalonKYPrd = 840.;
	// мощность на прием
	 double valEtalonKYPriem = 5200.;

	 mEtalonSign = TEtalonSign( valEtalonAmp, valEtalonDist,  valEtalonAPR,
			 valNoiseSKZ_5P10, valEtalonSigAmplFact_5P10, valEtalonPowerPrd,  valEtalonKYPrd
			,  valEtalonKYPriem);

	///

	// АНТЕННА
	// данные по АМ
	// к-во излучателей по горизонтали
	 int iNumEmitCols = 8;
	// к-во излучателей по вертикали
	 int iNumEmitRows = 8;
		// длина волны
		double valLambda = VAL_C / 8.* 100. / 1000000000.;

			// расстояние между излучателями
		double valdEmitCol = valLambda * 0.55;
		double valdEmitRow = valLambda * 0.55;


	// данные по ФАР
	// к-во АМ  по горизонтали
	 int iNumAMCols = 8;
	// к-во АМ по вертикали
	 int iNumAMRows = 8;
		// расстояние между АМ по вериткали
	double valdAMRow = ((double)iNumEmitRows) *  valdEmitRow;
	// расстояние между АМ по горизонтали
	double valdAMCol = ((double)iNumEmitCols) *  valdEmitCol;
	// СКЗ шума в суммарной диаграмме
	bool barrAM [5000] = {0};
	 for (int i = 0; i < 5000; i++)
	{
		barrAM[i] = true;
	}


 //	double arrArtParral[3] ={0.},  arrFarParallacs[3] ={0.};



	// мощность на передачу
	 double valPowerPrd =4000.;
	// КУ на передачу
	 double valKYPrd = 3000.;
	 mTransmitAnt.mKYPrd  =valKYPrd;
	 mTransmitAnt.mPowerPrd = valPowerPrd;


	///

const double SigEmitNoise =  valNoiseSKZ_5P10 / sqrt(((double)(8 * 16 * 28)));
	const double SigEmitAmplFact = valEtalonSigAmplFact_5P10 / sqrt
		(((double)(8 * 16 * 28)));
 TAM_2D AM_2D(iNumEmitCols, iNumEmitRows,  valdEmitCol,  valdEmitRow,
		SigEmitNoise, SigEmitAmplFact);

	mFar_2D = TFar_2D(iNumAMCols, iNumAMRows,  valLambda,  valdAMCol,  valdAMRow,
		AM_2D, barrAM);

	for (int i = 0; i < iNumAMCols * iNumAMRows; i++) {

		if (!barrAM[i]) {
			mFar_2D.mpAm2D[i].mOtklCoefUs = 1.;
			mFar_2D.mpAm2D[i].mSigEmitNoise = 0.;
		}
	}


	//-------------------------------------------------------------------
	// СКЗ угловой ошибки СИНС (углов качек)
	mSigSins = 0.00041;

	// СКЗ угловой ошибки СИНСпо скорости углов (углов качек)
	mSig_d_po_dt_Sins = 0.00116;

	// корабль наш
	 mVesselWidth = 0.; // ширина(м)
	 mVesselLength = 0. ;

	mMaxQ =     3./180.*M_PI; /// максимальный угол отклонения от генерального курса(амплитуда угла рыскания)
	mT_Q = 18.; // период рыскания
	mMaxPsi =      3./180.*M_PI;// максимальный угол килевой качки(амплитуда)
	mT_Psi = 12; // период килевой качки
	mMaxTet =      12./180.*M_PI; //максимальный угол боротовой качки(амплитуда)
	mT_Tet = 6; // период бортовой качки
	mMaxVert =     1. ;

	// парамеитры движения  корабля нашего
	 mQ0 = 0. ; // генеральный курс
	 mVVess = 20. * 0.514 ;// скорость корабля своего 20 узлов
	 //double arrDelt[4] = {0.};


	mMaxAmp_AftFlexure  = 1. * M_PI/180.;
	// период колебаний кормового изгиба
	mT_AftFlexure = 4.;
	//максимальная амплитуда бортового изгиба корабля в рад на 100 м
	mMaxAmp_BoardFlexure =  1. * M_PI/180.;
	// период колебаний бортового изгиба
	mT_BoardFlexure = 2.;

		 // 3.1 создание СИНС
	mMaxSig_Q      =     mSigSins ; //0.000582;
	mMaxSig_Psi    =      mSigSins ; //0.00145;
	mMaxSig_Tet    =    mSigSins ; // 0.00145;
	mMaxSig_dQdt   =      mSig_d_po_dt_Sins ;
	mMaxSig_dPsidt =      mSig_d_po_dt_Sins ;
	mMaxSig_dTetdt =      mSig_d_po_dt_Sins ;
	mK1         = 0.01 ;
	mSigV       =      0.2 * sqrt(2.) ;
	mSigH       =      0.1 ;
	mMaxSig_H =     0.1 ;
	mMaxSig_VH =     0.05 ;

    	// 3.3 создание привода
	mDriverSigBet  =      0.00021 ;
	mDriverSigEps  =      0.00021 ;
	mDriverDynamicSigBet =      0.0003141;
	mDriverDynamicSigEps =      0.0003141;

		// интервал между измерениями

	mMeasT = 0.02;
	// Задержка СИНС
	mSinsDelayT = 0.02;
		// темп решения РЗВ
	mRzvT = 0.00001;
	mControlSyst = TControlSyst(mMeasT, mSinsDelayT,mRzvT );

}
void __fastcall TForm4::Button6Click(TObject *Sender)
{

	if (mpwchOutFile0 == NULL) {
		if (I_ENTER_COUNT1 > 4)
			Close();

		ShowMessage(L"Укажите путь к папке с графиками");
		I_ENTER_COUNT1++;
		return;
	}
	wcscpy(mwchOutFold, mpwchOutFile0);
	wchar_t *pwchr = wcsrchr(mwchOutFold, L'\\');
	pwchr[0] = 0;
	String wchFoldName = mwchOutFold;




	int iNumCols = 2;


	int iNumRows = 90./ 5. + 1;
	int iLenName = 30;
	double *parrBuff = new double[iNumCols * iNumRows];

	wchar_t *pwcharrColNames = new wchar_t[iNumCols * iLenName];
	memset(pwcharrColNames, 0, iNumCols * iLenName*sizeof(wchar_t));

	wcscpy(pwcharrColNames, L"TargCourse");
	wcscpy(&pwcharrColNames[iLenName], L"Probability");

	double pValSum  = 0.;
	for (int i = 0; i < iNumRows; i++)
 //	for (int i = 2; i < 3; i++)
	 {
	 LabeledEdit29->Text = 180. +((double)i) * 5.;
	 Button3Click(Sender);
	 double valPCur =  StrTo_Dbl_(LabeledEdit46->Text) ;
	 pValSum   += valPCur;

		parrBuff[i * iNumCols] = mTargCourse0 * 180./ M_PI;
		parrBuff[i * iNumCols + 1] = valPCur * 100.;

	}

	// оси  координат
	wchar_t wchAxesFileName[300] ={0};
	wcscpy(  wchAxesFileName,  wchFoldName.w_str());
	wcscat(wchAxesFileName, L"AxesArr.shp");
	TYrWriteShapeFile::CreateShpArrowedAxes(wchAxesFileName,-500., 500.
	,-500., 500.,30.) ;
	// график

	TYrWriteShapeFile::WriteOneReport(wchFoldName.w_str() // путь к папке
									,parrBuff // массив с информацией - матрица nBuffRows x nBuffCols
									,iNumCols  // - к-во переменных о корорых накоплена информация в буфере
									,iNumRows //  - к-во точек
									,pwcharrColNames //матрица с именаими переменных - матрица nBuffCols x lenName
									,30 // максимальная длина имени переменной
									,0  // номер переменной по оси Y
									,1  // номер переменной по оси X
									,1  //  масштаб по оси Y
								  ,1  // масштаб по оси X
									 ) ;

	delete parrBuff;
	delete pwcharrColNames;



	int ia = (pValSum / ((double)iNumRows) * 100.);
	LabeledEdit46->Text = ((double)ia) / 100.;
}
//---------------------------------------------------------------------------

