//---------------------------------------------------------------------------


#pragma hdrstop
#include "MatrixProccess.h"
#include "SimpleBody_3D.h"

__fastcall TSimpleBody_3D::TSimpleBody_3D()
{
	/*RecNumber = 0 ;
	RecLength = 0 ;
	Type = ShapeType::NullShape ;
	FigureColor = (TColor)0 ;*/
	 mPlane = TPlane();
	 mM = 0.; // масса
}
// конструктор копирования
 TSimpleBody_3D ::TSimpleBody_3D  (const TSimpleBody_3D &R)
  {
	mPlane  = R.mPlane;
	mM = 0.;
 }

  // оператор присваивания
  TSimpleBody_3D TSimpleBody_3D::operator=(TSimpleBody_3D  R)
  {
	mPlane  = R.mPlane;
	mM = 0.;

	return *this;
 }
//---------------------------------------------------------------------------
__fastcall TSimpleBody_3D::TSimpleBody_3D(const TPlane Plane, const double M)
{
	 mPlane = Plane;
	 mM = M;
}
//---------------------------------------------------------------------------

//__fastcall TSimpleBody_3D::~TSimpleBody_3D()
//{
//}
//---------------------------------------------------------------


// вычисление объема
double TSimpleBody_3D::calcCapacity()
{

}

// вычисление координат центра тяжести  в системе собственных координат простого тела
void TSimpleBody_3D::calcCentreOfGravity(double *arrCentreGrav)
{

}

// вычисление координат центра тяжести  в собственной системе координат сложного тела
void TSimpleBody_3D::calcCentreOfGravityComplicatedAxes(double *arrCentreGrav)
{
  double arrCentreGrav0 [3] = {0.};
  calcCentreOfGravity(arrCentreGrav0) ;
  mPlane.transform_xyzSKP_to_xyzSSK(arrCentreGrav0, arrCentreGrav) ;
}
// вычисление тензора моментов инерции  ля единичной массы
void TSimpleBody_3D::calcInertiaMtrx(double *arrInertTens)
{

}


// вычисление тензора моментов инерции постого тела для массы mM
// задано простое тело  TSimpleBody_3D
// требуется вычислить тензор инерции тела относительно
// прямоугольной декартовой системы координат, с осями параллельными осям
// начальной связанной  сиситемы координат  с центром в точке центра масс тела
// Бухгольц Основной курс теорет миеханики, ч 2, стр 136
//  делается поворот и сдвиг по теореме Штейнера
// OUTPUT:
// arrInertTens[9] - матрица моментов инерции
void TSimpleBody_3D::calcInertiaMtrxMass( double *arrInertMtrx)
{
 double arr0[9] = {0.},arr1[9] = {0.},arr2[9] = {0.};
 // относительно главных осей инерции
 calcInertiaMtrx(arr2);
 ///


  MatrxMultScalar(arr2, 3, 3, mM,arr0);

 // поворот
 calcF_D_FTransp(mPlane.marrF,arr0,3,arr1 ) ;
 ///

 // сдвиг по теореме Штейнера

 calcInertiaMtrxShteinerSdvig(mM, mPlane.marrS0

 , arr1, arrInertMtrx)  ;

}
// вычисление матрицы моментов инерции отностиельно сиситемы коорлинат сдвинутой на вектор  arrS
// INPUT:
// VAlM -  масса тела
// arrS[3] -  вектор положения начала координат системы в которой	 надо вычислить матрицу моментов  мнерции
// arrInertTensInp[9] -  матрица ммоментов инерции в старой системе координат
// OUTPUT:
// arrInertTensOut - -  матрица ммоментов инерции в новой  системе координат
void TSimpleBody_3D::calcInertiaMtrxShteinerSdvig(const double VAlM, double *arrS
 , double *arrInertMtrxInp, double *arrInertMtrxOut)
 {
  double arr0[9] = {0.} , arr1[9] = {0.};
  MtrxMultMatrx(arrS,3, 1, arrS, 3, arr0) ;
  MatrxMultScalar(arr0, 3, 3, VAlM, arr1);
  MtrxSumMatrx(arrInertMtrxInp, arr1, 3, 3, arrInertMtrxOut) ;
 }
#pragma package(smart_init)
