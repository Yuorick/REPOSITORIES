//---------------------------------------------------------------------------


#pragma hdrstop

#include "Far.h"
 #include "Faceta.h"
//---------------------------------------------------------------------------

#include <vcl.h>

#pragma hdrstop
#include <math.h>
#include "Comp.h"
#include <stdio.h>
#include <stdlib.h>
#include "YrWriteShapeFile.h"
#include "URPolyLine.h"
#include "UrPointXY.h"
 TFar::~TFar()
{
 
 if(mparrCmpElCurrent)
 {
	 free (mparrCmpElCurrent);
 }
}

 TFar::TFar()
{
 // количество модулей (фасет)
  m_N = 4;
 // расстояние между модулями
   m_D = 32.;
 // длина волны
   mLambda = 3.15;;
 // массив фасет
  mFaceta = TFaceta();
 // массив токов по модулям
  mparrCmpElCurrent = (TComp*)malloc(m_N * sizeof(TComp));
   double delFi =  m_D * sin(0.01)/ 2./ mLambda * 2. * M_PI;

  mparrCmpElCurrent[0] = TComp:: exp_(-3. *delFi);
  mparrCmpElCurrent[1] = TComp:: exp_(-delFi);
  mparrCmpElCurrent[2] = TComp:: exp_(delFi);
  mparrCmpElCurrent[3] = TComp:: exp_(3.* delFi);
  TComp cmp(0.25,0.);

  for (int i=0; i < 4; i++)
  {
	mparrCmpElCurrent[i] *= cmp;
  }
}
// Конструктор копирования
TFar::TFar (const TFar &R2)
 {
 // количество модулей (фасет)
  m_N = R2.m_N;
 // расстояние между модулями
  m_D = R2.m_D;
 // длина волны
  mLambda = R2.mLambda;

  mFaceta = R2.mFaceta;

  if (mparrCmpElCurrent)
  {
	free (mparrCmpElCurrent);
	mparrCmpElCurrent = NULL;  
  }
  if (R2.mparrCmpElCurrent)
  {
   mparrCmpElCurrent = (TComp*)malloc(m_N * sizeof(TComp));
   memcpy(mparrCmpElCurrent, R2.mparrCmpElCurrent,m_N * sizeof(TComp)); 	  
  }

 }

// парам констр
 __fastcall TFar::TFar(const int N,const double D,const double Lambda
   ,TFaceta Faceta, TComp *parrCmpElCurrent)
 {
	 m_N = N ;
	 m_D= D;
	 mLambda = Lambda ;
	 mFaceta = Faceta;
	 if (parrCmpElCurrent)
	 {
		mparrCmpElCurrent =  (TComp *)malloc( m_N * sizeof(TComp));
		memcpy(mparrCmpElCurrent, parrCmpElCurrent, m_N * sizeof(TComp));
	 }

 }
// {

// }

 // оператор присваивания
 TFar TFar::operator=(TFar  R2)
{
 // количество модулей (фасет)
  m_N = 4;
 // расстояние между модулями
   m_D = 32.;
 // длина волны
   mLambda = 3.15;;
 // массив фасет
  mFaceta = TFaceta();
 // массив токов по модулям
  mparrCmpElCurrent = (TComp*)malloc(m_N * sizeof(TComp));
	return *this ;
}


 TComp TFar::fncF (const double tet)
{
  TComp cmpRez(0.,0.) ;
  TComp delFas(0.,  m_D * sin(tet)/ 2./ mLambda * 2. * M_PI);

  TComp delFas0(0.,  -m_D * sin(tet)/ 2./ mLambda * 2. * M_PI * ((double)(m_N -1)));
  for (int i = 0; i < m_N; i++)
  {
	TComp cmpTemp;
	double valS =  mFaceta.fncFFaceta(tet);
	TComp cmpFasCur ( 0.,((double)i) * 2. * delFas.m_Im+delFas0.m_Im);
	TComp cmpTemp1 = TComp::exp_(cmpFasCur);
	cmpTemp.m_Re = cmpTemp1.m_Re * valS;
	cmpTemp.m_Im = cmpTemp1.m_Im * valS;
	cmpTemp *=  mparrCmpElCurrent[i] ;
	cmpRez += cmpTemp ;
  }
  return  cmpRez;
}

void TFar::createDiagrGraphs(wchar_t *wchFoldName1 )
{

	wchar_t wchFoldName[300] ={0};
	wcscpy(  wchFoldName,  wchFoldName1);
	wcscat(wchFoldName, L"\\");
	double step = M_PI / 3000./ 10.;
	const int nBuffRows = 1500 *2;
	const int nBuffCols =2;
	double  *parrBuff = new double [nBuffRows  * nBuffCols] ;
	memset(parrBuff, 0, nBuffRows * nBuffCols * sizeof(double));

	const int lenName = 30;
	wchar_t wcharrFileNames [150] ={0};
	wcscpy( wcharrFileNames, L"Tetta");
	wcscpy( &wcharrFileNames[30], L"ModF");
  for (int i=0 ; i < nBuffRows; i++)
  {

   parrBuff[ i * nBuffCols] = ((double) (-nBuffRows/2 +i)) / 10.;
   double tet = step * ((double) (-nBuffRows/2 +i));
   TComp cmp = fncF( tet);
   parrBuff[ i * nBuffCols + 1]= cmp.modul();;

  }

  double scaley = 100.;
  for (int i=1; i < nBuffCols; i++)
  {

  TYrWriteShapeFile::WriteOneReport(                 wchFoldName  // путь к папке
								  , parrBuff // массив с информацией - матрица nBuffRows x nBuffCols
								  , nBuffCols // - к-во переменных о корорых накоплена информация в буфере
								  , nBuffRows //  - к-во точек
								  ,wcharrFileNames //матрица с именаими переменных - матрица nBuffCols x lenName
								  ,lenName // максимальная длина имени переменной
								  ,0  // номер переменной по оси X
								  ,i  // номер переменной по оси Y
								  ,1. //  масштаб по оси X
								  ,scaley // масштаб по оси Y
								   ) ;
  }

	delete parrBuff;
	wchar_t wchAxesFileName[300] ={0};
	wcscpy(  wchAxesFileName,  wchFoldName);
	wcscat(wchAxesFileName, L"AxesArr.shp");
	TYrWriteShapeFile::CreateShpArrowedAxes(wchAxesFileName,-parrBuff[ (nBuffRows-1) * nBuffCols]-100000.*step, parrBuff[ (nBuffRows-1) * nBuffCols]+100000.*step
	 ,0,scaley * 1.1, 50000.*step) ;
	TURPointXY pPoints[2];
	pPoints[0] =  TURPointXY (-100., scaley * sqrt(2.)/2.);
	pPoints[1] =  TURPointXY (100., scaley * sqrt(2.)/2.);
	TURPolyLine pln( pPoints,2) ;

	wcscpy(  wchAxesFileName,  wchFoldName);
	wcscat(wchAxesFileName, L"Line0.shp");
	TURPolyLine::WriteSetSHPFiles(wchAxesFileName,&pln, 1) ;
 }

#pragma package(smart_init)
