//---------------------------------------------------------------------------


#pragma hdrstop

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "TruncatedConeCircle.h"


  TTruncatedConeCircle ::TTruncatedConeCircle()
{

	mR = 0. ;
	mr = 0. ;
	mH = 0.;
	mM = 0.;


}
TTruncatedConeCircle ::TTruncatedConeCircle( const double R, const double r,const double H,const double M)
{
 mR = R;
 mr = r;
 mH = H;
 mM = M;

}

// конструктор копировани€
 TTruncatedConeCircle ::TTruncatedConeCircle (const TTruncatedConeCircle &R)
 {
	mR  = R.mR;
	mr = R.mr ;
	mH = R.mH;
	mM = R.mM   ;
 }
 // оператор присваивани€
 TTruncatedConeCircle TTruncatedConeCircle::operator=(TTruncatedConeCircle  R)
 {
	mR  = R.mR;
	mr = R.mr ;
	mH = R.mH;
	mM = R.mM   ;
	return *this ;
  }


// вычисление объема
double TTruncatedConeCircle::calcCapacity()
{
 return  M_PI * mH * (mR * mR + mR * mr + mr * mr)/3.;
}

// вычисление координат центра т€жести
void TTruncatedConeCircle::calcCentreOfGravity(double *arrCentreGrav)
{
  arrCentreGrav [0] = mH * (mR * mR + 2. * mR * mr + 3. * mr * mr)/ (mR * mR + mR * mr + mr * mr) / 4.;
  arrCentreGrav [1] = 0.;
  arrCentreGrav [2] = 0.;
}

// вычисление тензора моментов инерции
// это диагональна€ матрица
// относительно оси вращени€ считаетс€ по формуле
// относительно осей X и Z прмиен€тс€ формула Ўтейнера
//  усеченный конус достраиваетс€ до неусеченного, большого.
// “о есть добавл€етс€ маленький конус сверху.
// ¬ычисл€ютс€ координаты центра т€жести усеченного, большого и малого конусов.
// вычисл€ютмс€ моменты инерции большого и малого конусов.
// ѕо теореме Ўтейнера находитс€ момент инерции относительно осей  X и Z
void TTruncatedConeCircle::calcInertiaTensor(double *arrInertTens)
{
  // 1. вычисление момента инерции относительно оси Y
  memset(arrInertTens, 0, 9 * sizeof(double));
  arrInertTens[4] = 3. * mM * (mR*mR*mR*mR*mR - mr*mr*mr*mr*mr)/ (mR*mR*mR - mr*mr*mr) / 10.;
  ////


  double arrCentreGravLittle [3] = {0.}  ,arrCentreGravBig [3] = {0.};
  // 2. вычисление высот малого и большого конусов
   double valHLittle = mH * mr / (mR - mr);
	double valHBig =  valHLittle + mH;
	///


   //  3. вычисление  координат центра масс малого конуса
   calcCentreOfGravity_For_ConeCircle(valHLittle, arrCentreGravLittle) ;
   arrCentreGravLittle [1] += mH;
   ///

   // 4. вычисление  координат центра масс большого конуса
   calcCentreOfGravity_For_ConeCircle(valHBig, arrCentreGravBig) ;
   ///


   //       5.   вычисление массы малого конуса
  double valMLittle = mM / calcCapacity() * calcCapacity_For_ConeCircle(mr, valHLittle);
   ///


   //    6. вычисление массы , большого  конуса
  double valMBig = mM + valMLittle;
  ///



   // 7. вычисление  координат центра масс усеченного  конуса
   double arrCentreGrav[3] = {0.};
   calcCentreOfGravity(arrCentreGrav)  ;
   ///

   // 8.рассто€ние между ÷ћ малого и большого конусов
   double valDelRLittle =  arrCentreGravLittle[1] - arrCentreGravBig[1];
   ///

   // 9.рассто€ние между ÷ћ усеченного  и большого конусов
   double valDelR =  arrCentreGrav[1] - arrCentreGravBig[1];
   ///

   // формула Ўтейнера

   arrInertTens[0] = calcJxx_For_ConeCircle(mR, valHBig,valMBig) - calcJxx_For_ConeCircle(mr, valHLittle,valMLittle)
				  -valMLittle * valDelRLittle * valDelRLittle - mM * valDelR * valDelR;

   arrInertTens[8] = arrInertTens[0];


}

double TTruncatedConeCircle::calcJxx_For_ConeCircle(const double VAlR, const double VAlM) // +
{
return 3. * VAlM * VAlR * VAlR /10.;

}
double TTruncatedConeCircle::calcJyy_For_ConeCircle(const double VAlR, const double VAlH, const double VAlM)  // +
{
return 3. * VAlM * (VAlR * VAlR   +  VAlH * VAlH / 4.)/20.;

}

double TTruncatedConeCircle::calcCapacity_For_ConeCircle(const double VAlR, const double VAlH)  // +
{
  return  M_PI * VAlR *VAlR * VAlH / 3.;
}

void TTruncatedConeCircle::calcCentreOfGravity_For_ConeCircle(const double VAlH, double *arrCentreGrav)   // +
{
  arrCentreGrav [1] = 0.;
  arrCentreGrav [0] = VAlH ;
  arrCentreGrav [2] = 0.;
}
// вычисление тензора моментов инерции
void TTruncatedConeCircle::calcInertiaTensor_For_ConeCircle(const double VAlR, const double VAlH, const double VAlM  // +
,double *arrInertTens)
{
   memset(arrInertTens, 0, 9 * sizeof(double));
   arrInertTens [0] = calcJxx_For_ConeCircle(VAlR,VAlH, VAlM);
   arrInertTens [1] = calcJyy_For_ConeCircle( VAlR, VAlM);
   arrInertTens [2] = arrInertTens [1] ;

}
#pragma package(smart_init)
