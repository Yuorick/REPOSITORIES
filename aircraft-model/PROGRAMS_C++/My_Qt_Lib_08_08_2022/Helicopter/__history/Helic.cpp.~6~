//---------------------------------------------------------------------------


#pragma hdrstop
#include <math.h>
#include <string.h>

#include "Helic.h"


__fastcall  THelic::THelic()
{

	 memset(marrRotor, 0, 2 * sizeof(TRotor));
	// частота вращениеия винта
	 memset(marrRotorOmega, 0, 2 * sizeof(double));
	// масса вертолетв
	 mHelicMass = 0.;

}
// Конструктор копирования
__fastcall  THelic::THelic (const THelic &R)
 {
	 memcpy(marrRotor, R.marrRotor, 2 * sizeof(TRotor));
	 memcpy(marrRotorOmega, R.marrRotorOmega, 2 * sizeof(double));
	 mHelicMass  = R.mHelicMass ;

 }
 // оператор присваивания
  THelic THelic::operator=(THelic  R)
 {
	 memcpy(marrRotor, R.marrRotor, 2 * sizeof(TRotor));
	 memcpy(marrRotorOmega, R.marrRotorOmega, 2 * sizeof(double));
	 mHelicMass  = R.mHelicMass ;
	 return *this ;
 }

 // парам констр 1
 __fastcall THelic::THelic(TRotor *arrRotor, double *arrRotorOmega
   ,const double HelicMass)
 {
	 memcpy(marrRotor,arrRotor, 2 * sizeof(TRotor));
	 memcpy(marrRotorOmega, arrRotorOmega, 2 * sizeof(double));
	 mHelicMass  = HelicMass ;
 }
 //-------------------------------------------------------
 //---------------------------------------------------------------------------
// вычисление константы Ct по данным РЛЭ
// задана точка еа высоте висения (максимальной), масса вертолета, температура у поверхнсти земли
// требуется накйти константу Ct
	// TKel0 - температура на поверхности земли, град Кельвина
	// HeliH -  высота  висения, м
	// BladeOmega  - частота вращениеия винта
double THelic::calcCt(const double TKel0,const double HeliH)
{
	  double valTKel = TKel0  - 0.0065 * 5500;
	  double valTCel = valTKel- 273.15;
	  double valPAm = 101325. * exp(log(valTKel/ TKel0) * 9.81* 0.028964/ 8.31/ 0.0065);
	  double valRo =   valPAm * 0.028964/8.31/  valTKel;

	  // радиус ометаемой площади несущего винта
	  double valR = marrRotor[0].mBlade.mBladeR;
	  ///

	  double valCt = 2.* 9.81 * mHelicMass/
	  (valRo   *M_PI * valR* valR *valR *valR
			*marrRotorOmega[0] * marrRotorOmega[0]);
	  return valCt;
}
//--------------------------------------------------------------
//-------------------------------------------------------------
	// вычисление коэффициента подъемной силы лопасти  по данным РЛЭ
	// Задана точка висения при заданных данных - масса вертолета
	// , температура забортного воздуха и высота висения
	// На основании этих данных можно вычислить плотность воздуха, подъемную силу
	// и найти коэффициент Cyalfa
	/// TKel0 - температура на поверхности земли, град Кельвина
	// HeliH -  высота  висения, м
	// BladeOmega  - частота вращениеия винта
	// максимальный общий шаг задан 15 град !!!!
double THelic::calc_C_y_alfa(const double TKel0,const double HeliH)
{
	double valTKel = TKel0  - 0.0065 * 5500;
	double valTCel = valTKel- 273.15;
	double valPAm = 101325. * exp(log(valTKel/ TKel0) * 9.81* 0.028964/ 8.31/ 0.0065);
	double valRo =   valPAm * 0.028964/8.31/  valTKel;

	double valTemp = marrRotor[0].mBlade.mBladeR *  marrRotor[0].mBlade.mBladeR *  marrRotor[0].mBlade.mBladeR
	- marrRotor[0].mBlade.mRadHorizHsarnir * marrRotor[0].mBlade.mRadHorizHsarnir * marrRotor[0].mBlade.mRadHorizHsarnir;
	double valC_y_alfa = 6. * mHelicMass * 9.81
	/ (((double)(marrRotor[0].mQuantBlades)) *  valRo
	* marrRotor[0].mBlade.mBlade_b *marrRotor[0].mFiMax
	* marrRotorOmega[0] * marrRotorOmega[0] * valTemp );
   return valC_y_alfa ;
}

//-------------------------------------------------------------
	// вычисление массовой характеристики лопасти  по данным РЛЭ
	// Задана точка висения при заданных данных - масса вертолета
	// , температура забортного воздуха и высота висения
	// На основании этих данных можно вычислить плотность воздуха, подъемную силу
	// и найти коэффициент Cyalfa и вычислить Gamma_L
	/// TKel0 - температура на поверхности земли, град Кельвина
	// HeliH -  высота  висения, м
double THelic::calc_Gamma_L(const double TKel0,const double HeliH)
{

	valC_y_alfa  = calc_C_y_alfa( TKel0,HeliH) ;
	return  valC_y_alfa *  double valTKel = TKel0  - 0.0065 * 5500;
	double valTCel = valTKel- 273.15;
	double valPAm = 101325. * exp(log(valTKel/ TKel0) * 9.81* 0.028964/ 8.31/ 0.0065);
	double valRo =   valPAm * 0.028964/8.31/  valTKel;

}
#pragma package(smart_init)
